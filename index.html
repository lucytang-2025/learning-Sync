<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤ä¹ æ‰“å¡è®¡åˆ’</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .app-description {
            font-size: 14px;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            background: #f1f5f9;
            border-bottom: 1px solid #e2e8f0;
        }

        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .tab.active {
            background: white;
            color: #4facfe;
            border-bottom: 3px solid #4facfe;
        }

        .tab-content {
            display: none;
            padding: 20px;
            min-height: 500px;
        }

        .tab-content.active {
            display: block;
        }

        .task-list {
            margin-bottom: 20px;
        }

        .task-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border-left: 4px solid #4facfe;
            transition: transform 0.2s;
        }

        .task-item:hover {
            transform: translateY(-2px);
        }

        .task-item.overdue {
            border-left-color: #ff6b6b;
            background: #fff5f5;
        }

        .task-item.completed {
            border-left-color: #1dd1a1;
            background: #f0fff4;
        }

        .task-item.pending-review {
            border-left-color: #feca57;
            background: #fff9e6;
        }

        .task-item.needs-redo {
            border-left-color: #ff9f43;
            background: #fff9e6;
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .task-name {
            font-weight: 600;
            font-size: 18px;
        }

        .task-status {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            color: white;
        }

        .status-overdue {
            background: #ff6b6b;
        }

        .status-today {
            background: #4ecdc4;
        }

        .status-future {
            background: #45aaf2;
        }

        .status-completed {
            background: #1dd1a1;
        }

        .status-pending {
            background: #feca57;
        }

        .status-pending-review {
            background: #ff9ff3;
        }

        .status-rejected {
            background: #ff9f43;
        }

        .task-progress {
            margin: 10px 0;
        }

        .progress-bar {
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            border-radius: 4px;
            transition: width 0.5s;
        }

        .progress-text {
            font-size: 12px;
            color: #64748b;
            margin-top: 5px;
        }

        .task-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #4facfe;
            color: white;
        }

        .btn-primary:hover {
            background: #3a9bf7;
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #475569;
        }

        .btn-secondary:hover {
            background: #cbd5e1;
        }

        .btn-danger {
            background: #ff6b6b;
            color: white;
        }

        .btn-danger:hover {
            background: #ff5252;
        }

        .btn-warning {
            background: #ff9f43;
            color: white;
        }

        .btn-warning:hover {
            background: #ff8c2a;
        }

        .btn-disabled {
            background: #cbd5e1;
            color: #94a3b8;
            cursor: not-allowed;
        }

        .btn-disabled:hover {
            background: #cbd5e1;
        }

        .recorder-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }

        .recorder-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .recorder-display {
            text-align: center;
            margin: 20px 0;
        }

        .timer {
            font-size: 48px;
            font-weight: 700;
            color: #4facfe;
            margin: 20px 0;
        }

        .recorder-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .recorder-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .record-btn {
            background: #ff6b6b;
            color: white;
        }

        .record-btn.recording {
            animation: pulse 1.5s infinite;
        }

        .pause-btn {
            background: #feca57;
            color: white;
        }

        .stop-btn {
            background: #48dbfb;
            color: white;
        }

        .play-btn {
            background: #1dd1a1;
            color: white;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .waveform {
            height: 100px;
            background: #f8fafc;
            border-radius: 10px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 4px;
            background: #4facfe;
            border-radius: 2px 2px 0 0;
        }

        .recordings-list {
            margin-top: 20px;
        }

        .recording-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .recording-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .recording-name {
            font-weight: 600;
        }

        .recording-duration {
            font-size: 12px;
            color: #64748b;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px 0;
        }

        .calendar-nav {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .calendar-nav-btn {
            background: #4facfe;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .calendar-nav-btn:hover {
            background: #3a9bf7;
        }

        .calendar-title {
            font-size: 18px;
            font-weight: 600;
            color: #475569;
        }

        .calendar {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .calendar-weekday {
            text-align: center;
            font-weight: 600;
            padding: 10px 0;
            color: #475569;
            background: #f8fafc;
            border-radius: 5px;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            padding: 5px;
            position: relative;
            border: 2px solid transparent;
        }

        .calendar-day:hover {
            background: #f1f5f9;
        }

        .calendar-day.active {
            background: #4facfe;
            color: white;
        }

        .calendar-day.selected {
            background: #ff6b6b;
            color: white;
            border-color: #ff6b6b;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .calendar-day.today {
            border-color: #ff6b6b;
        }

        .calendar-day.other-month {
            color: #cbd5e1;
        }

        .day-number {
            font-size: 16px;
            font-weight: 600;
        }

        .task-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-top: 2px;
        }

        .indicator-overdue {
            background: #ff6b6b;
        }

        .indicator-today {
            background: #4ecdc4;
        }

        .indicator-future {
            background: #45aaf2;
        }

        .indicator-completed {
            background: #1dd1a1;
        }

        .indicator-pending-review {
            background: #ff9ff3;
        }

        .indicator-rejected {
            background: #ff9f43;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #475569;
        }

        input, textarea, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            font-size: 16px;
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #64748b;
        }

        .empty-state i {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .hidden {
            display: none;
        }

        .checkin-history {
            margin-top: 10px;
        }

        .history-item {
            padding: 8px 12px;
            border-left: 3px solid #4facfe;
            background: #f8fafc;
            margin-bottom: 8px;
            border-radius: 0 8px 8px 0;
            font-size: 12px;
        }

        .history-date {
            font-weight: 600;
            margin-bottom: 3px;
        }

        .history-status {
            font-size: 11px;
            color: #64748b;
        }

        .status-completed {
            color: #1dd1a1;
        }

        .status-pending {
            color: #feca57;
        }

        .status-missed {
            color: #ff6b6b;
        }

        .status-pending-review {
            color: #ff9ff3;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #64748b;
            font-size: 14px;
            border-top: 1px solid #e2e8f0;
        }

        .task-form-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .audio-player {
            width: 100%;
            margin: 10px 0;
        }

        .recording-status {
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: 600;
        }

        .status-recording {
            background: #fff5f5;
            color: #ff6b6b;
        }

        .status-playing {
            background: #f0fff4;
            color: #1dd1a1;
        }

        .last-recording-time {
            font-size: 12px;
            color: #64748b;
            margin-top: 5px;
        }

        .edit-task-form {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .compact-checkin-info {
            font-size: 12px;
            color: #64748b;
            margin-top: 5px;
        }

        .compact-checkin-item {
            display: inline-block;
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 5px;
            margin-bottom: 3px;
        }
        
        .upload-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .upload-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .upload-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-input-btn {
            display: block;
            padding: 12px 20px;
            background: #4facfe;
            color: white;
            border-radius: 6px;
            text-align: center;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .file-input-btn:hover {
            background: #3a9bf7;
        }
        
        .file-info {
            margin-top: 10px;
            padding: 10px;
            background: #f8fafc;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .recorder-mode-selector {
            display: flex;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #cbd5e1;
        }
        
        .recorder-mode {
            flex: 1;
            padding: 12px;
            text-align: center;
            background: #f8fafc;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .recorder-mode.active {
            background: #4facfe;
            color: white;
        }
        
        .uploaded-audio-player {
            width: 100%;
            margin: 15px 0;
        }

        .data-management-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .data-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .data-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border-left: 4px solid #4facfe;
        }

        .stat-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .stat-number {
            font-size: 24px;
            font-weight: 700;
            color: #4facfe;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: #64748b;
        }

        .instructions-list {
            padding-left: 20px;
            margin-top: 10px;
        }

        .instructions-list li {
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .modal-header h3 {
            margin: 0;
            color: #475569;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #64748b;
        }

        .close-btn:hover {
            color: #475569;
        }

        .modal-body {
            padding: 20px;
        }

        .data-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .data-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .data-section h4 {
            margin-bottom: 10px;
            color: #475569;
        }

        .data-section p {
            margin-bottom: 15px;
            color: #64748b;
            font-size: 14px;
        }

        .data-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f1f5f9;
        }

        .stat-label {
            color: #64748b;
            font-size: 14px;
        }

        .stat-value {
            font-weight: 600;
            color: #475569;
        }

        .hidden {
            display: none !important;
        }

        .subject-chinese {
            color: #4facfe;
        }

        .subject-math {
            color: #764ba2;
        }

        .subject-english {
            color: #ff6b6b;
        }

        .subject-science {
            color: #1dd1a1;
        }

        .subject-other {
            color: #feca57;
        }

        .task-details-modal {
            max-width: 600px;
        }

        .checkin-progress {
            margin-top: 15px;
        }

        .checkin-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f1f5f9;
        }

        .checkin-day {
            font-weight: 600;
            width: 120px;
        }

        .checkin-status {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-icon {
            font-size: 16px;
        }

        .status-completed-icon {
            color: #1dd1a1;
        }

        .status-pending-icon {
            color: #feca57;
        }

        .status-missed-icon {
            color: #ff6b6b;
        }

        .today-tasks-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
        }

        .tasks-count {
            background: #4facfe;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .rejection-reason {
            font-size: 12px;
            color: #ff6b6b;
            margin-top: 5px;
            padding: 5px;
            background: #fff5f5;
            border-radius: 4px;
            border-left: 3px solid #ff6b6b;
        }

        .redo-notice {
            background: #fff9e6;
            border: 1px solid #ff9f43;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 14px;
            width: 100%;
        }

        .redo-notice h4 {
            color: #ff9f43;
            margin-bottom: 5px;
        }

        .storage-warning {
            background: #fff5f5;
            border: 2px solid #ff6b6b;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .storage-warning.high {
            background: #fff5f5;
            border-color: #ff6b6b;
            animation: pulse-warning 2s infinite;
        }

        .storage-warning.medium {
            background: #fff9e6;
            border-color: #feca57;
        }

        .storage-warning.low {
            background: #f0fff4;
            border-color: #1dd1a1;
        }

        @keyframes pulse-warning {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .storage-size {
            font-weight: 700;
            font-size: 18px;
            margin: 5px 0;
        }

        .storage-size.high {
            color: #ff6b6b;
        }

        .storage-size.medium {
            color: #feca57;
        }

        .storage-size.low {
            color: #1dd1a1;
        }

        .rejection-history {
            margin-top: 10px;
            padding: 10px;
            background: #f8fafc;
            border-radius: 6px;
        }

        .rejection-history-item {
            padding: 8px;
            margin-bottom: 5px;
            background: white;
            border-radius: 4px;
            border-left: 3px solid #ff9f43;
        }

        .rejection-date {
            font-size: 11px;
            color: #64748b;
        }

        .rejection-reason-text {
            font-size: 12px;
            color: #475569;
        }

        /* æ–°å¢æ ·å¼ - è‡ªå®šä¹‰æ—¥æœŸæ‰“å¡ */
        .schedule-type-selector {
            display: flex;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #cbd5e1;
        }
        
        .schedule-type {
            flex: 1;
            padding: 12px;
            text-align: center;
            background: #f8fafc;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .schedule-type.active {
            background: #4facfe;
            color: white;
        }
        
        .custom-schedule-container {
            margin-top: 15px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .daily-schedule-container {
            margin-top: 15px;
            padding: 15px;
            background: #f0f9ff;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .custom-date-input {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .custom-date-input label {
            width: 120px;
            margin-bottom: 0;
            margin-right: 10px;
        }
        
        .custom-date-input input {
            flex: 1;
        }
        
        .add-date-btn {
            background: #4facfe;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
        }
        
        .custom-dates-list {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .custom-date-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            margin-bottom: 8px;
            border-left: 3px solid #4facfe;
        }
        
        .remove-date-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        /* æ–°å¢æ ·å¼ - ä»»åŠ¡æè¿°æ˜¾ç¤º */
        .task-description-display {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #4facfe;
            white-space: pre-line; /* ä¿ç•™æ¢è¡Œç¬¦ */
        }

        .task-description-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #475569;
        }

        .task-description-content {
            color: #64748b;
            line-height: 1.5;
            white-space: pre-line; /* ä¿ç•™æ¢è¡Œç¬¦ */
        }

        /* æ—¥å†ä»»åŠ¡æ•°é‡æŒ‡ç¤ºå™¨ */
        .task-count-indicator {
            position: absolute;
            top: 2px;
            right: 2px;
            background: #ff6b6b;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .calendar-day {
            position: relative;
        }

        /* æ¯æ—¥æ‰“å¡æ ‡è¯† */
        .daily-task-badge {
            display: inline-block;
            background: #4facfe;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 8px;
            font-weight: normal;
        }

        .daily-schedule-info {
            background: #f0f9ff;
            border-radius: 6px;
            padding: 10px;
            margin: 8px 0;
            border-left: 3px solid #4facfe;
        }

        .daily-schedule-dates {
            font-size: 12px;
            color: #64748b;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>å¤ä¹ æ‰“å¡è®¡åˆ’</h1>
            <p class="app-description">æ—¥ç§¯æœˆç´¯ã€æŒä¹‹ä»¥æ’ï¼Œå†²åˆº100åˆ†</p>
        </header>

        <div class="tabs">
            <div class="tab active" data-tab="today">ä»Šæ—¥ä»»åŠ¡</div>
            <div class="tab" data-tab="tasks">ä»»åŠ¡ç®¡ç†</div>
            <div class="tab" data-tab="calendar">æ—¥å†è§†å›¾</div>
            <div class="tab" data-tab="recorder">å½•éŸ³æ‰“å¡</div>
            <div class="tab" data-tab="data">æ•°æ®ç®¡ç†</div>
        </div>

        <div class="tab-content active" id="today-tab">
            <div class="today-tasks-header">
                <h2>ä»Šæ—¥ä»»åŠ¡</h2>
                <div class="tasks-count" id="today-tasks-count">0/0 ä¸ªä»»åŠ¡</div>
            </div>
            <div class="task-list" id="today-tasks">
                <!-- ä»Šæ—¥ä»»åŠ¡å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <div class="tab-content" id="tasks-tab">
            <h2>ä»»åŠ¡ç®¡ç†</h2>
            
            <div id="task-form" class="task-form-container hidden">
                <h3>æ–°å»ºä»»åŠ¡</h3>
                <div class="form-group">
                    <label for="task-subject">ç§‘ç›®</label>
                    <select id="task-subject">
                        <option value="è¯­æ–‡">è¯­æ–‡</option>
                        <option value="æ•°å­¦">æ•°å­¦</option>
                        <option value="è‹±è¯­">è‹±è¯­</option>
                        <option value="ç§‘å­¦">ç§‘å­¦</option>
                        <option value="å…¶ä»–">å…¶ä»–</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="task-name">ä»»åŠ¡åç§°</label>
                    <input type="text" id="task-name" placeholder="è¾“å…¥ä»»åŠ¡åç§°">
                </div>
                <div class="form-group">
                    <label for="task-desc">ä»»åŠ¡æè¿°</label>
                    <textarea id="task-desc" placeholder="è¾“å…¥ä»»åŠ¡æè¿°ï¼ˆå¯é€‰ï¼‰"></textarea>
                </div>
                <div class="form-group">
                    <label for="task-date">å¼€å§‹æ—¥æœŸ</label>
                    <input type="date" id="task-date">
                </div>
                
                <!-- æ‰“å¡è®¡åˆ’ç±»å‹é€‰æ‹© -->
                <div class="form-group">
                    <label>æ‰“å¡è®¡åˆ’ç±»å‹</label>
                    <div class="schedule-type-selector">
                        <div class="schedule-type active" data-type="default">é»˜è®¤è®¡åˆ’</div>
                        <div class="schedule-type" data-type="daily">æ¯æ—¥æ‰“å¡</div>
                        <div class="schedule-type" data-type="custom">è‡ªå®šä¹‰æ—¥æœŸ</div>
                    </div>
                </div>
                
                <!-- é»˜è®¤è®¡åˆ’è¯´æ˜ -->
                <div id="default-schedule-info" class="custom-schedule-container">
                    <p><strong>é»˜è®¤æ‰“å¡è®¡åˆ’:</strong> ç¬¬1, 2, 3, 5, 8, 15, 30, 90, 180å¤©æ‰“å¡</p>
                </div>
                
                <!-- æ¯æ—¥æ‰“å¡è®¾ç½® -->
                <div id="daily-schedule-container" class="daily-schedule-container hidden">
                    <p><strong>æ¯æ—¥æ‰“å¡è®¾ç½®:</strong> ä»»åŠ¡å°†æ¯å¤©éƒ½éœ€è¦æ‰“å¡</p>
                    
                    <div class="form-group">
                        <label for="daily-start-date">å¼€å§‹æ—¥æœŸ</label>
                        <input type="date" id="daily-start-date">
                    </div>
                    
                    <div class="form-group">
                        <label for="daily-end-date">ç»“æŸæ—¥æœŸï¼ˆå¯é€‰ï¼‰</label>
                        <input type="date" id="daily-end-date">
                        <small>å¦‚æœä¸è®¾ç½®ç»“æŸæ—¥æœŸï¼Œä»»åŠ¡å°†ä¸€ç›´æŒç»­</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="daily-duration">ä»»åŠ¡æŒç»­å¤©æ•°</label>
                        <input type="number" id="daily-duration" min="1" max="365" value="30" placeholder="ä¾‹å¦‚ï¼š30å¤©">
                        <small>ä»»åŠ¡å°†æŒç»­çš„å¤©æ•°</small>
                    </div>
                </div>
                
                <!-- è‡ªå®šä¹‰æ—¥æœŸè®¾ç½® -->
                <div id="custom-schedule-container" class="custom-schedule-container hidden">
                    <p><strong>è‡ªå®šä¹‰æ‰“å¡æ—¥æœŸ:</strong> è¯·æ·»åŠ å…·ä½“çš„æ‰“å¡æ—¥æœŸ</p>
                    
                    <div class="custom-date-input">
                        <label for="custom-date">æ‰“å¡æ—¥æœŸ</label>
                        <input type="date" id="custom-date">
                    </div>
                    
                    <button class="add-date-btn" id="add-custom-date">æ·»åŠ æ—¥æœŸ</button>
                    
                    <div class="custom-dates-list" id="custom-dates-list">
                        <!-- è‡ªå®šä¹‰æ—¥æœŸåˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
                
                <div class="task-actions">
                    <button class="btn btn-primary" id="save-task">ä¿å­˜ä»»åŠ¡</button>
                    <button class="btn btn-secondary" id="cancel-task">å–æ¶ˆ</button>
                </div>
            </div>

            <div id="edit-task-form" class="edit-task-form hidden">
                <h3>ç¼–è¾‘ä»»åŠ¡</h3>
                <div class="form-group">
                    <label for="edit-task-subject">ç§‘ç›®</label>
                    <select id="edit-task-subject">
                        <option value="è¯­æ–‡">è¯­æ–‡</option>
                        <option value="æ•°å­¦">æ•°å­¦</option>
                        <option value="è‹±è¯­">è‹±è¯­</option>
                        <option value="ç§‘å­¦">ç§‘å­¦</option>
                        <option value="å…¶ä»–">å…¶ä»–</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="edit-task-name">ä»»åŠ¡åç§°</label>
                    <input type="text" id="edit-task-name" placeholder="è¾“å…¥ä»»åŠ¡åç§°">
                </div>
                <div class="form-group">
                    <label for="edit-task-desc">ä»»åŠ¡æè¿°</label>
                    <textarea id="edit-task-desc" placeholder="è¾“å…¥ä»»åŠ¡æè¿°ï¼ˆå¯é€‰ï¼‰"></textarea>
                </div>
                <div class="task-actions">
                    <button class="btn btn-primary" id="update-task">æ›´æ–°ä»»åŠ¡</button>
                    <button class="btn btn-secondary" id="cancel-edit-task">å–æ¶ˆ</button>
                </div>
            </div>
            
            <button class="btn btn-primary" id="add-task-btn">æ–°å»ºä»»åŠ¡</button>
            
            <div class="task-list" id="all-tasks">
                <!-- æ‰€æœ‰ä»»åŠ¡å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <div class="tab-content" id="calendar-tab">
            <h2>æ—¥å†è§†å›¾</h2>
            <div class="calendar-header">
                <div class="calendar-nav">
                    <button class="calendar-nav-btn" id="prev-month">â†</button>
                    <button class="calendar-nav-btn" id="next-month">â†’</button>
                </div>
                <div class="calendar-title" id="calendar-title"></div>
                <button class="btn btn-secondary" id="today-btn">ä»Šå¤©</button>
            </div>
            <div class="calendar" id="calendar">
                <!-- æ—¥å†å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
            <div class="checkin-history" id="selected-date-tasks">
                <!-- é€‰ä¸­æ—¥æœŸçš„ä»»åŠ¡å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <div class="tab-content" id="recorder-tab">
            <h2>å½•éŸ³æ‰“å¡</h2>
            
            <div class="recorder-mode-selector">
                <div class="recorder-mode active" data-mode="record">å®æ—¶å½•éŸ³</div>
                <div class="recorder-mode" data-mode="upload">ä¸Šä¼ å½•éŸ³</div>
            </div>
            
            <div class="recorder-container" id="record-container">
                <div class="recorder-header">
                    <h3 id="recorder-task-name">é€‰æ‹©ä»»åŠ¡è¿›è¡Œæ‰“å¡</h3>
                    <p id="recorder-checkpoint">è¯·å…ˆä»ä»Šæ—¥ä»»åŠ¡ä¸­é€‰æ‹©ä¸€ä¸ªä»»åŠ¡</p>
                </div>
                
                <!-- æ–°å¢ï¼šä»»åŠ¡æè¿°æ˜¾ç¤ºåŒºåŸŸ -->
                <div id="recorder-task-description" class="task-description-display hidden">
                    <div class="task-description-title">ä»»åŠ¡æè¿°</div>
                    <div class="task-description-content" id="recorder-task-desc-content"></div>
                </div>
                
                <div class="recording-status hidden" id="recording-status"></div>
                
                <div class="recorder-display">
                    <div class="timer" id="timer">00:00:00</div>
                    <div class="waveform" id="waveform">
                        <!-- æ³¢å½¢å›¾å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
                
                <div class="recorder-controls">
                    <button class="recorder-btn record-btn" id="record-btn" title="å¼€å§‹å½•éŸ³">
                        â—
                    </button>
                    <button class="recorder-btn pause-btn hidden" id="pause-btn" title="æš‚åœ">
                        âšâš
                    </button>
                    <button class="recorder-btn stop-btn hidden" id="stop-btn" title="åœæ­¢">
                        â– 
                    </button>
                    <button class="recorder-btn play-btn hidden" id="play-btn" title="æ’­æ”¾">
                        â–¶
                    </button>
                </div>

                <audio id="audio-player" class="audio-player hidden" controls></audio>
                
                <div class="task-actions">
                    <button class="btn btn-primary" id="submit-recording" disabled>æäº¤æ‰“å¡</button>
                    <button class="btn btn-secondary" id="reset-recorder">é‡ç½®</button>
                </div>
            </div>
            
            <div class="upload-container hidden" id="upload-container">
                <div class="upload-header">
                    <h3 id="upload-task-name">é€‰æ‹©ä»»åŠ¡è¿›è¡Œæ‰“å¡</h3>
                    <p id="upload-checkpoint">è¯·å…ˆä»ä»Šæ—¥ä»»åŠ¡ä¸­é€‰æ‹©ä¸€ä¸ªä»»åŠ¡</p>
                </div>
                
                <!-- æ–°å¢ï¼šä»»åŠ¡æè¿°æ˜¾ç¤ºåŒºåŸŸ -->
                <div id="upload-task-description" class="task-description-display hidden">
                    <div class="task-description-title">ä»»åŠ¡æè¿°</div>
                    <div class="task-description-content" id="upload-task-desc-content"></div>
                </div>
                
                <div class="upload-controls">
                    <div class="file-input-wrapper">
                        <div class="file-input-btn">é€‰æ‹©å½•éŸ³æ–‡ä»¶</div>
                        <input type="file" id="audio-file" accept="audio/*">
                    </div>
                    
                    <div class="file-info hidden" id="file-info">
                        <div>æ–‡ä»¶å: <span id="file-name"></span></div>
                        <div>æ–‡ä»¶å¤§å°: <span id="file-size"></span></div>
                        <div>æ—¶é•¿: <span id="file-duration">è®¡ç®—ä¸­...</span></div>
                    </div>
                    
                    <audio id="uploaded-audio-player" class="uploaded-audio-player hidden" controls></audio>
                </div>
                
                <div class="task-actions">
                    <button class="btn btn-primary" id="submit-upload" disabled>æäº¤æ‰“å¡</button>
                    <button class="btn btn-secondary" id="reset-upload">é‡ç½®</button>
                </div>
            </div>
            
            <div class="recordings-list" id="recordings-list">
                <h3>æ‰“å¡è®°å½•</h3>
                <!-- å½•éŸ³è®°å½•å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <div class="tab-content" id="data-tab">
            <h2>æ•°æ®ç®¡ç†</h2>
            
            <div class="data-management-container">
                <div class="data-card">
                    <h3>æ•°æ®å¤‡ä»½ä¸æ¢å¤</h3>
                    <p>æ‚¨å¯ä»¥å°†æ•°æ®å¯¼å‡ºä¸ºJSONæ–‡ä»¶è¿›è¡Œå¤‡ä»½ï¼Œæˆ–ä»å¤‡ä»½æ–‡ä»¶æ¢å¤æ•°æ®ã€‚</p>
                    
                    <div class="data-actions">
                        <button class="btn btn-primary" id="show-data-modal">ç®¡ç†æ•°æ®</button>
                        <button class="btn btn-secondary" id="clear-data-btn">æ¸…é™¤æ‰€æœ‰æ•°æ®</button>
                    </div>
                </div>
                
                <div class="data-card">
                    <h3>æ•°æ®ç»Ÿè®¡</h3>
                    <div id="storage-warning" class="storage-warning hidden">
                        <h4>âš ï¸ å­˜å‚¨ç©ºé—´è­¦å‘Š</h4>
                        <div class="storage-size" id="storage-size-display">0 MB</div>
                        <p id="storage-message">å½“å‰æ•°æ®å­˜å‚¨é‡è¾ƒå¤§ï¼Œå»ºè®®åŠæ—¶æ¸…ç†æˆ–å¯¼å‡ºå¤‡ä»½</p>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-icon">ğŸ“</div>
                            <div class="stat-number" id="stats-total-tasks">0</div>
                            <div class="stat-label">æ€»ä»»åŠ¡æ•°</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">âœ…</div>
                            <div class="stat-number" id="stats-completed-tasks">0</div>
                            <div class="stat-label">å·²å®Œæˆ</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">ğŸ¤</div>
                            <div class="stat-number" id="stats-total-recordings">0</div>
                            <div class="stat-label">ä»Šæ—¥å½•éŸ³</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">â±ï¸</div>
                            <div class="stat-number" id="stats-total-duration">0</div>
                            <div class="stat-label">æ€»å½•éŸ³æ—¶é•¿</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">ğŸ“Š</div>
                            <div class="stat-number" id="stats-data-size">0 MB</div>
                            <div class="stat-label">æ•°æ®å¤§å°</div>
                        </div>
                    </div>
                </div>
                
                <div class="data-card">
                    <h3>ä½¿ç”¨è¯´æ˜</h3>
                    <ol class="instructions-list">
                        <li>ä½¿ç”¨"å¯¼å‡ºæ•°æ®"åŠŸèƒ½å°†æ•°æ®ä¿å­˜ä¸ºJSONæ–‡ä»¶ä½œä¸ºå¤‡ä»½</li>
                        <li>åœ¨å…¶ä»–è®¾å¤‡ä¸Šä½¿ç”¨"å¯¼å…¥æ•°æ®"åŠŸèƒ½æ¢å¤å¤‡ä»½</li>
                        <li>æ³¨æ„ï¼šå¯¼å…¥æ•°æ®å°†è¦†ç›–å½“å‰è®¾å¤‡ä¸Šçš„æ‰€æœ‰æ•°æ®</li>
                        <li>æ¯ä¸ªä»»åŠ¡åªä¿ç•™æœ€æ–°ä¸€æ¬¡æ‰“å¡å½•éŸ³</li>
                        <li>åˆ é™¤çš„ä»»åŠ¡ä¼šæ°¸ä¹…åˆ é™¤ï¼Œä¸å ç”¨å­˜å‚¨ç©ºé—´</li>
                        <li>å½•éŸ³ä¼šåœ¨ç¬¬äºŒå¤©è‡ªåŠ¨æ¸…é›¶ï¼Œåªä¿ç•™ä»Šæ—¥å½•éŸ³</li>
                    </ol>
                </div>
            </div>
        </div>

        <footer>
            <p>å¤ä¹ æ‰“å¡è®¡åˆ’ &copy; 2023 - ç¬¬180å¤©æ‰“å¡å®Œæˆåä»»åŠ¡å®Œæˆ</p>
        </footer>
    </div>

    <!-- æ•°æ®ç®¡ç†æ¨¡æ€æ¡† -->
    <div id="data-management-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>æ•°æ®ç®¡ç†</h3>
                <button class="close-btn" id="close-data-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="data-section">
                    <h4>å¯¼å‡ºæ•°æ®</h4>
                    <p>å°†æ‚¨çš„ä»»åŠ¡å’Œæ‰“å¡è®°å½•å¯¼å‡ºä¸ºJSONæ–‡ä»¶ï¼Œç”¨äºå¤‡ä»½ã€‚</p>
                    <button class="btn btn-primary" id="export-data-btn">å¯¼å‡ºæ•°æ®</button>
                </div>
                
                <div class="data-section">
                    <h4>å¯¼å…¥æ•°æ®</h4>
                    <p>ä»JSONæ–‡ä»¶å¯¼å…¥ä»»åŠ¡å’Œæ‰“å¡è®°å½•ï¼Œå°†è¦†ç›–å½“å‰è®¾å¤‡ä¸Šçš„æ‰€æœ‰æ•°æ®ã€‚</p>
                    <div class="file-input-wrapper">
                        <div class="file-input-btn">é€‰æ‹©æ•°æ®æ–‡ä»¶</div>
                        <input type="file" id="import-data-file" accept=".json">
                    </div>
                    <div class="file-info hidden" id="import-file-info">
                        <div>æ–‡ä»¶å: <span id="import-file-name"></span></div>
                        <div>æ–‡ä»¶å¤§å°: <span id="import-file-size"></span></div>
                    </div>
                    <button class="btn btn-danger" id="import-data-btn" disabled>å¯¼å…¥æ•°æ®</button>
                </div>
                
                <div class="data-section">
                    <h4>æ•°æ®ç»Ÿè®¡</h4>
                    <div class="data-stats">
                        <div class="stat-item">
                            <span class="stat-label">ä»»åŠ¡æ€»æ•°:</span>
                            <span class="stat-value" id="stat-total-tasks">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">å·²å®Œæˆä»»åŠ¡:</span>
                            <span class="stat-value" id="stat-completed-tasks">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">ä»Šæ—¥å½•éŸ³:</span>
                            <span class="stat-value" id="stat-total-recordings">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">æ•°æ®å¤§å°:</span>
                            <span class="stat-value" id="stat-data-size">0 MB</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ä»»åŠ¡è¯¦æƒ…æ¨¡æ€æ¡† -->
    <div id="task-details-modal" class="modal hidden">
        <div class="modal-content task-details-modal">
            <div class="modal-header">
                <h3 id="task-details-title">ä»»åŠ¡è¯¦æƒ…</h3>
                <button class="close-btn" id="close-task-details">&times;</button>
            </div>
            <div class="modal-body">
                <div id="task-details-content">
                    <!-- ä»»åŠ¡è¯¦æƒ…å†…å®¹å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // åº”ç”¨æ•°æ®
        const appData = {
            tasks: [],
            recordings: [],
            feedbacks: [],
            currentTask: null,
            currentRecording: null,
            isRecording: false,
            isPaused: false,
            isPlaying: false,
            timerInterval: null,
            recordingTime: 0,
            mediaRecorder: null,
            audioChunks: [],
            audioContext: null,
            analyser: null,
            currentCalendarDate: new Date(),
            selectedCalendarDate: null,
            recordingState: null,
            editingTask: null,
            currentCheckpointIndex: null,
            uploadedAudio: null,
            currentMode: 'record',
            customDates: [],
            currentScheduleType: 'default'
        };

        // é»˜è®¤æ‰“å¡æ—¶é—´è¡¨
        const checkinSchedule = [1, 2, 3, 5, 8, 15, 30, 90, 180];

        // IndexedDBå­˜å‚¨ç®¡ç†
        class AudioStorage {
            constructor() {
                this.dbName = 'AudioRecorderDB';
                this.version = 2;
                this.db = null;
            }

            async open() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve(this.db);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains('recordings')) {
                            const store = db.createObjectStore('recordings', { keyPath: 'id' });
                            store.createIndex('date', 'date', { unique: false });
                            store.createIndex('taskId', 'taskId', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('tasks')) {
                            db.createObjectStore('tasks', { keyPath: 'id' });
                        }
                    };
                });
            }

            async saveRecording(recording) {
                if (!this.db) await this.open();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['recordings'], 'readwrite');
                    const store = transaction.objectStore('recordings');
                    
                    const recordingToSave = {
                        id: recording.id,
                        taskId: recording.taskId,
                        checkpointIndex: recording.checkpointIndex,
                        date: recording.date,
                        duration: recording.duration,
                        audioData: recording.audioData,
                        mimeType: recording.mimeType,
                        source: recording.source
                    };
                    
                    const request = store.put(recordingToSave);
                    
                    request.onsuccess = () => resolve(recording.id);
                    request.onerror = () => reject(request.error);
                });
            }

            async getRecording(recordingId) {
                if (!this.db) await this.open();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['recordings'], 'readonly');
                    const store = transaction.objectStore('recordings');
                    const request = store.get(recordingId);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getRecordingsByTask(taskId) {
                if (!this.db) await this.open();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['recordings'], 'readonly');
                    const store = transaction.objectStore('recordings');
                    const index = store.index('taskId');
                    const request = index.getAll(taskId);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getTodayRecordings() {
                if (!this.db) await this.open();
                
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['recordings'], 'readonly');
                    const store = transaction.objectStore('recordings');
                    const index = store.index('date');
                    const range = IDBKeyRange.bound(today.toISOString(), tomorrow.toISOString());
                    const request = index.getAll(range);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async deleteRecording(recordingId) {
                if (!this.db) await this.open();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['recordings'], 'readwrite');
                    const store = transaction.objectStore('recordings');
                    const request = store.delete(recordingId);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async cleanupOldRecordings() {
                if (!this.db) await this.open();
                
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['recordings'], 'readwrite');
                    const store = transaction.objectStore('recordings');
                    const index = store.index('date');
                    const range = IDBKeyRange.upperBound(today.toISOString());
                    const request = index.openCursor(range);
                    
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            cursor.delete();
                            cursor.continue();
                        } else {
                            resolve();
                        }
                    };
                    
                    request.onerror = () => reject(request.error);
                });
            }

            async saveTasks(tasks) {
                if (!this.db) await this.open();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['tasks'], 'readwrite');
                    const store = transaction.objectStore('tasks');
                    
                    const clearRequest = store.clear();
                    
                    clearRequest.onsuccess = () => {
                        const promises = tasks.map(task => {
                            return new Promise((res, rej) => {
                                const request = store.add(task);
                                request.onsuccess = () => res();
                                request.onerror = () => rej(request.error);
                            });
                        });
                        
                        Promise.all(promises).then(resolve).catch(reject);
                    };
                    
                    clearRequest.onerror = () => reject(clearRequest.error);
                });
            }

            async getTasks() {
                if (!this.db) await this.open();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['tasks'], 'readonly');
                    const store = transaction.objectStore('tasks');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }
        }

        // åˆå§‹åŒ–å…¨å±€å­˜å‚¨å®ä¾‹
        const audioStorage = new AudioStorage();

        // DOM å…ƒç´ 
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const todayTasksEl = document.getElementById('today-tasks');
        const todayTasksCountEl = document.getElementById('today-tasks-count');
        const allTasksEl = document.getElementById('all-tasks');
        const taskFormEl = document.getElementById('task-form');
        const editTaskFormEl = document.getElementById('edit-task-form');
        const addTaskBtn = document.getElementById('add-task-btn');
        const saveTaskBtn = document.getElementById('save-task');
        const cancelTaskBtn = document.getElementById('cancel-task');
        const updateTaskBtn = document.getElementById('update-task');
        const cancelEditTaskBtn = document.getElementById('cancel-edit-task');
        const calendarEl = document.getElementById('calendar');
        const calendarTitleEl = document.getElementById('calendar-title');
        const prevMonthBtn = document.getElementById('prev-month');
        const nextMonthBtn = document.getElementById('next-month');
        const todayBtn = document.getElementById('today-btn');
        const selectedDateTasksEl = document.getElementById('selected-date-tasks');
        const recorderTaskNameEl = document.getElementById('recorder-task-name');
        const recorderCheckpointEl = document.getElementById('recorder-checkpoint');
        const recordingStatusEl = document.getElementById('recording-status');
        const timerEl = document.getElementById('timer');
        const waveformEl = document.getElementById('waveform');
        const recordBtn = document.getElementById('record-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const playBtn = document.getElementById('play-btn');
        const audioPlayer = document.getElementById('audio-player');
        const submitRecordingBtn = document.getElementById('submit-recording');
        const resetRecorderBtn = document.getElementById('reset-recorder');
        const recordingsListEl = document.getElementById('recordings-list');
        
        const recordModeBtn = document.querySelector('.recorder-mode[data-mode="record"]');
        const uploadModeBtn = document.querySelector('.recorder-mode[data-mode="upload"]');
        const recordContainer = document.getElementById('record-container');
        const uploadContainer = document.getElementById('upload-container');
        const audioFileInput = document.getElementById('audio-file');
        const fileInfoEl = document.getElementById('file-info');
        const fileNameEl = document.getElementById('file-name');
        const fileSizeEl = document.getElementById('file-size');
        const fileDurationEl = document.getElementById('file-duration');
        const uploadedAudioPlayer = document.getElementById('uploaded-audio-player');
        const submitUploadBtn = document.getElementById('submit-upload');
        const resetUploadBtn = document.getElementById('reset-upload');
        const uploadTaskNameEl = document.getElementById('upload-task-name');
        const uploadCheckpointEl = document.getElementById('upload-checkpoint');

        const dataManagementModal = document.getElementById('data-management-modal');
        const closeDataModalBtn = document.getElementById('close-data-modal');
        const showDataModalBtn = document.getElementById('show-data-modal');
        const exportDataBtn = document.getElementById('export-data-btn');
        const importDataFile = document.getElementById('import-data-file');
        const importDataBtn = document.getElementById('import-data-btn');
        const importFileInfo = document.getElementById('import-file-info');
        const importFileName = document.getElementById('import-file-name');
        const importFileSize = document.getElementById('import-file-size');
        const clearDataBtn = document.getElementById('clear-data-btn');

        const taskDetailsModal = document.getElementById('task-details-modal');
        const taskDetailsTitle = document.getElementById('task-details-title');
        const taskDetailsContent = document.getElementById('task-details-content');
        const closeTaskDetailsBtn = document.getElementById('close-task-details');

        // æ–°å¢ï¼šè‡ªå®šä¹‰æ—¥æœŸç›¸å…³å…ƒç´ 
        const scheduleTypeSelectors = document.querySelectorAll('.schedule-type');
        const defaultScheduleInfo = document.getElementById('default-schedule-info');
        const dailyScheduleContainer = document.getElementById('daily-schedule-container');
        const customScheduleContainer = document.getElementById('custom-schedule-container');
        const customDateInput = document.getElementById('custom-date');
        const addCustomDateBtn = document.getElementById('add-custom-date');
        const customDatesList = document.getElementById('custom-dates-list');
        
        // æ–°å¢ï¼šæ¯æ—¥æ‰“å¡ç›¸å…³å…ƒç´ 
        const dailyStartDateInput = document.getElementById('daily-start-date');
        const dailyEndDateInput = document.getElementById('daily-end-date');
        const dailyDurationInput = document.getElementById('daily-duration');
        
        // æ–°å¢ï¼šä»»åŠ¡æè¿°æ˜¾ç¤ºå…ƒç´ 
        const recorderTaskDescriptionEl = document.getElementById('recorder-task-description');
        const recorderTaskDescContentEl = document.getElementById('recorder-task-desc-content');
        const uploadTaskDescriptionEl = document.getElementById('upload-task-description');
        const uploadTaskDescContentEl = document.getElementById('upload-task-desc-content');
        
        // æ–°å¢ï¼šå­˜å‚¨è­¦å‘Šç›¸å…³å…ƒç´ 
        const storageWarningEl = document.getElementById('storage-warning');
        const storageSizeDisplayEl = document.getElementById('storage-size-display');
        const storageMessageEl = document.getElementById('storage-message');

        // åˆå§‹åŒ–åº”ç”¨
        async function initApp() {
            console.log('åˆå§‹åŒ–åº”ç”¨...');
            
            // æ·»åŠ æ¯æ—¥æ¸…ç†æ£€æŸ¥
            checkDailyCleanup();
            
            await loadLocalData();
            setupEventListeners();
            setupUploadEventListeners();
            setupDataManagementEventListeners();
            setupTaskDetailsEventListeners();
            setupCustomDateEventListeners();
            
            restoreRecordingUrls();
            
            renderTodayTasks();
            renderAllTasks();
            renderCalendar();
            renderRecordings();
            renderDataStats();
            
            restoreRecordingState();
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            console.log('åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
        }

        // æ¯æ—¥æ¸…ç†æ£€æŸ¥
        function checkDailyCleanup() {
            const lastCleanupDate = localStorage.getItem('lastCleanupDate');
            const today = new Date().toDateString();
            
            if (lastCleanupDate !== today) {
                strictDailyCleanup();
                localStorage.setItem('lastCleanupDate', today);
            }
        }

        // ä¸¥æ ¼çš„æ¯æ—¥æ¸…é›¶ - åªä¿ç•™ä»Šå¤©çš„å½•éŸ³
        async function strictDailyCleanup() {
            try {
                await audioStorage.cleanupOldRecordings();
                console.log('éä»Šæ—¥å½•éŸ³æ¸…ç†å®Œæˆ');
                
                // é‡æ–°åŠ è½½ä»Šæ—¥å½•éŸ³
                appData.recordings = await audioStorage.getTodayRecordings();
            } catch (error) {
                console.error('æ¸…ç†å½•éŸ³å¤±è´¥:', error);
            }
        }

        // è®¾ç½®è‡ªå®šä¹‰æ—¥æœŸäº‹ä»¶ç›‘å¬
        function setupCustomDateEventListeners() {
            scheduleTypeSelectors.forEach(type => {
                type.addEventListener('click', () => {
                    const scheduleType = type.getAttribute('data-type');
                    switchScheduleType(scheduleType);
                });
            });
            
            addCustomDateBtn.addEventListener('click', addCustomDate);
            
            // è®¾ç½®æ¯æ—¥æ‰“å¡çš„é»˜è®¤æ—¥æœŸ
            const today = new Date().toISOString().split('T')[0];
            dailyStartDateInput.value = today;
        }

        // åˆ‡æ¢æ‰“å¡è®¡åˆ’ç±»å‹
        function switchScheduleType(type) {
            appData.currentScheduleType = type;
            
            scheduleTypeSelectors.forEach(t => {
                if (t.getAttribute('data-type') === type) {
                    t.classList.add('active');
                } else {
                    t.classList.remove('active');
                }
            });
            
            // éšè—æ‰€æœ‰å®¹å™¨
            defaultScheduleInfo.classList.add('hidden');
            dailyScheduleContainer.classList.add('hidden');
            customScheduleContainer.classList.add('hidden');
            
            // æ˜¾ç¤ºå¯¹åº”çš„å®¹å™¨
            if (type === 'default') {
                defaultScheduleInfo.classList.remove('hidden');
            } else if (type === 'daily') {
                dailyScheduleContainer.classList.remove('hidden');
            } else if (type === 'custom') {
                customScheduleContainer.classList.remove('hidden');
            }
        }

        // æ·»åŠ è‡ªå®šä¹‰æ—¥æœŸ
        function addCustomDate() {
            const dateValue = customDateInput.value;
            if (!dateValue) {
                alert('è¯·é€‰æ‹©æ—¥æœŸ');
                return;
            }
            
            const selectedDate = new Date(dateValue);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            if (selectedDate < today) {
                alert('ä¸èƒ½é€‰æ‹©è¿‡å»çš„æ—¥æœŸ');
                return;
            }
            
            const dateExists = appData.customDates.some(date => 
                new Date(date).getTime() === selectedDate.getTime()
            );
            
            if (dateExists) {
                alert('è¯¥æ—¥æœŸå·²å­˜åœ¨');
                return;
            }
            
            appData.customDates.push(selectedDate.toISOString());
            renderCustomDatesList();
            customDateInput.value = '';
        }

        // æ¸²æŸ“è‡ªå®šä¹‰æ—¥æœŸåˆ—è¡¨
        function renderCustomDatesList() {
            customDatesList.innerHTML = '';
            
            if (appData.customDates.length === 0) {
                customDatesList.innerHTML = '<p style="text-align: center; color: #64748b; padding: 10px;">æš‚æ— è‡ªå®šä¹‰æ—¥æœŸ</p>';
                return;
            }
            
            const sortedDates = [...appData.customDates].sort((a, b) => new Date(a) - new Date(b));
            
            sortedDates.forEach((date, index) => {
                const dateObj = new Date(date);
                const dateItem = document.createElement('div');
                dateItem.className = 'custom-date-item';
                dateItem.innerHTML = `
                    <span>${dateObj.toLocaleDateString()}</span>
                    <button class="remove-date-btn" data-index="${index}">Ã—</button>
                `;
                customDatesList.appendChild(dateItem);
            });
            
            document.querySelectorAll('.remove-date-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.getAttribute('data-index'));
                    removeCustomDate(index);
                });
            });
        }

        // åˆ é™¤è‡ªå®šä¹‰æ—¥æœŸ
        function removeCustomDate(index) {
            appData.customDates.splice(index, 1);
            renderCustomDatesList();
        }

        // å¤„ç†é¡µé¢å¯è§æ€§å˜åŒ–
        function handleVisibilityChange() {
            if (document.hidden) {
                saveRecordingState();
            } else {
                restoreRecordingState();
            }
        }

        // ä¿å­˜å½•éŸ³çŠ¶æ€
        function saveRecordingState() {
            if (appData.isRecording || appData.currentRecording) {
                appData.recordingState = {
                    isRecording: appData.isRecording,
                    isPaused: appData.isPaused,
                    recordingTime: appData.recordingTime,
                    currentTask: appData.currentTask,
                    currentCheckpointIndex: appData.currentCheckpointIndex,
                    audioChunks: appData.audioChunks
                };
                localStorage.setItem('recordingState', JSON.stringify(appData.recordingState));
            }
        }

        // æ¢å¤å½•éŸ³çŠ¶æ€
        function restoreRecordingState() {
            const savedState = localStorage.getItem('recordingState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    
                    if (state.isRecording && !state.isPaused) {
                        if (confirm('æ£€æµ‹åˆ°æœªå®Œæˆçš„å½•éŸ³ï¼Œæ˜¯å¦æ¢å¤å½•éŸ³ï¼Ÿ')) {
                            appData.isRecording = state.isRecording;
                            appData.isPaused = state.isPaused;
                            appData.recordingTime = state.recordingTime;
                            appData.currentTask = state.currentTask;
                            appData.currentCheckpointIndex = state.currentCheckpointIndex;
                            appData.audioChunks = state.audioChunks || [];
                            
                            updateTimer();
                            recordBtn.classList.add('hidden');
                            pauseBtn.classList.remove('hidden');
                            stopBtn.classList.remove('hidden');
                            updatePlaybackStatus('å½•éŸ³å·²æ¢å¤ï¼Œç‚¹å‡»æš‚åœ', 'status-recording');
                            
                            switchTab('recorder');
                            resumeRecording();
                        } else {
                            clearRecordingState();
                        }
                    }
                } catch (e) {
                    console.error('æ¢å¤å½•éŸ³çŠ¶æ€å¤±è´¥:', e);
                    clearRecordingState();
                }
            }
        }

        // æ¢å¤å½•éŸ³
        async function resumeRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                appData.mediaRecorder = new MediaRecorder(stream);
                
                appData.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        appData.audioChunks.push(event.data);
                    }
                };
                
                appData.mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(appData.audioChunks, { type: 'audio/wav' });
                    
                    const reader = new FileReader();
                    reader.onload = async function() {
                        const base64Audio = reader.result;
                        
                        const recording = {
                            id: Date.now(),
                            taskId: appData.currentTask.id,
                            checkpointIndex: appData.currentCheckpointIndex,
                            date: new Date().toISOString(),
                            duration: appData.recordingTime,
                            audioData: base64Audio,
                            mimeType: 'audio/wav'
                        };
                        
                        createAudioUrlFromData(recording);
                        
                        // ä¿å­˜åˆ°IndexedDB
                        await audioStorage.saveRecording(recording);
                        
                        appData.currentRecording = recording;
                        
                        stream.getTracks().forEach(track => track.stop());
                        clearRecordingState();
                        
                        recordBtn.classList.remove('recording', 'hidden');
                        pauseBtn.classList.add('hidden');
                        stopBtn.classList.add('hidden');
                        playBtn.classList.remove('hidden');
                        submitRecordingBtn.disabled = false;
                        
                        audioPlayer.src = recording.audioUrl;
                        audioPlayer.classList.remove('hidden');
                        
                        alert('å½•éŸ³å·²ä¿å­˜ï¼');
                        renderRecordings();
                        renderTodayTasks();
                        renderAllTasks();
                        renderDataStats();
                    };
                    reader.readAsDataURL(audioBlob);
                };
                
                appData.mediaRecorder.start();
                
                appData.timerInterval = setInterval(() => {
                    appData.recordingTime += 10;
                    updateTimer();
                    updateWaveform();
                }, 10);
                
            } catch (error) {
                console.error('æ¢å¤å½•éŸ³å¤±è´¥:', error);
                alert('æ— æ³•æ¢å¤å½•éŸ³ï¼Œè¯·é‡æ–°å¼€å§‹');
                resetRecorder();
            }
        }

        // æ¸…é™¤å½•éŸ³çŠ¶æ€
        function clearRecordingState() {
            localStorage.removeItem('recordingState');
            appData.recordingState = null;
        }

        // è·å–é»˜è®¤ä»»åŠ¡
        function getDefaultTasks() {
            return [
                {
                    id: 1,
                    subject: 'è‹±è¯­',
                    name: 'å­¦ä¹ è‹±è¯­',
                    description: 'æ¯å¤©å­¦ä¹ 30åˆ†é’Ÿè‹±è¯­ï¼ŒåŒ…æ‹¬å•è¯è®°å¿†ã€è¯­æ³•ç»ƒä¹ å’Œå¬åŠ›è®­ç»ƒ',
                    createDate: new Date().toISOString(),
                    status: 'active',
                    checkins: [],
                    scheduleType: 'default'
                },
                {
                    id: 2,
                    subject: 'å…¶ä»–',
                    name: 'å¥èº«è®¡åˆ’',
                    description: 'æ¯å‘¨ä¸‰æ¬¡å¥èº«æˆ¿é”»ç‚¼ï¼ŒåŒ…æ‹¬æœ‰æ°§è¿åŠ¨å’ŒåŠ›é‡è®­ç»ƒ',
                    createDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
                    status: 'active',
                    checkins: [],
                    scheduleType: 'default'
                }
            ];
        }

        // ä¿å­˜ä»»åŠ¡æ•°æ®
        async function saveTasks() {
            try {
                await audioStorage.saveTasks(appData.tasks);
            } catch (e) {
                console.error('ä¿å­˜ä»»åŠ¡æ•°æ®å¤±è´¥:', e);
                // é™çº§åˆ°localStorage
                try {
                    localStorage.setItem('checkinTasks', JSON.stringify(appData.tasks));
                } catch (error) {
                    console.error('localStorageä¿å­˜ä¹Ÿå¤±è´¥:', error);
                }
            }
        }

        // ä»æœ¬åœ°åŠ è½½æ•°æ®
        async function loadLocalData() {
            try {
                // ä»IndexedDBåŠ è½½ä»»åŠ¡
                appData.tasks = await audioStorage.getTasks();
                
                // ä»IndexedDBåŠ è½½ä»Šæ—¥å½•éŸ³
                appData.recordings = await audioStorage.getTodayRecordings();
                
                // å¦‚æœæ²¡æœ‰ä»»åŠ¡ï¼Œä½¿ç”¨é»˜è®¤ä»»åŠ¡
                if (appData.tasks.length === 0) {
                    appData.tasks = getDefaultTasks();
                    await audioStorage.saveTasks(appData.tasks);
                }
                
                // ä»localStorageåŠ è½½å…¶ä»–æ•°æ®
                const savedFeedbacks = localStorage.getItem('checkinFeedbacks');
                if (savedFeedbacks) {
                    appData.feedbacks = JSON.parse(savedFeedbacks);
                } else {
                    appData.feedbacks = [];
                }
                
            } catch (error) {
                console.error('åŠ è½½æ•°æ®å¤±è´¥:', error);
                // é™çº§åˆ°é»˜è®¤æ•°æ®
                appData.tasks = getDefaultTasks();
                appData.recordings = [];
                appData.feedbacks = [];
                
                // å°è¯•ä¿å­˜åˆ°localStorage
                try {
                    localStorage.setItem('checkinTasks', JSON.stringify(appData.tasks));
                } catch (e) {
                    console.error('localStorageä¿å­˜å¤±è´¥:', e);
                }
            }
        }

        // ä¿å­˜æ•°æ®åˆ°æœ¬åœ°
        async function saveLocalData() {
            await saveTasks();
            localStorage.setItem('checkinFeedbacks', JSON.stringify(appData.feedbacks));
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.getAttribute('data-tab');
                    switchTab(tabId);
                });
            });

            addTaskBtn.addEventListener('click', showTaskForm);
            saveTaskBtn.addEventListener('click', saveTask);
            cancelTaskBtn.addEventListener('click', hideTaskForm);
            updateTaskBtn.addEventListener('click', updateTask);
            cancelEditTaskBtn.addEventListener('click', hideEditTaskForm);

            prevMonthBtn.addEventListener('click', () => navigateCalendar(-1));
            nextMonthBtn.addEventListener('click', () => navigateCalendar(1));
            todayBtn.addEventListener('click', goToToday);

            recordBtn.addEventListener('click', startRecording);
            pauseBtn.addEventListener('click', togglePause);
            stopBtn.addEventListener('click', stopRecording);
            playBtn.addEventListener('click', playRecording);
            submitRecordingBtn.addEventListener('click', submitRecording);
            resetRecorderBtn.addEventListener('click', resetRecorder);
        }
        
        // è®¾ç½®ä¸Šä¼ ç›¸å…³äº‹ä»¶ç›‘å¬å™¨
        function setupUploadEventListeners() {
            recordModeBtn.addEventListener('click', () => switchRecorderMode('record'));
            uploadModeBtn.addEventListener('click', () => switchRecorderMode('upload'));
            
            audioFileInput.addEventListener('change', handleFileUpload);
            submitUploadBtn.addEventListener('click', submitUploadedAudio);
            resetUploadBtn.addEventListener('click', resetUpload);
        }

        // è®¾ç½®æ•°æ®ç®¡ç†äº‹ä»¶ç›‘å¬å™¨
        function setupDataManagementEventListeners() {
            showDataModalBtn.addEventListener('click', showDataManagementModal);
            closeDataModalBtn.addEventListener('click', hideDataManagementModal);
            exportDataBtn.addEventListener('click', exportData);
            importDataFile.addEventListener('change', handleImportFileSelect);
            importDataBtn.addEventListener('click', importData);
            clearDataBtn.addEventListener('click', clearAllData);
        }

        // è®¾ç½®ä»»åŠ¡è¯¦æƒ…äº‹ä»¶ç›‘å¬å™¨
        function setupTaskDetailsEventListeners() {
            closeTaskDetailsBtn.addEventListener('click', hideTaskDetails);
        }

        // æ›´æ–°æ’­æ”¾çŠ¶æ€æ˜¾ç¤º
        function updatePlaybackStatus(message, statusClass) {
            recordingStatusEl.textContent = message;
            recordingStatusEl.className = 'recording-status ' + statusClass;
            recordingStatusEl.classList.remove('hidden');
        }

        // åˆ‡æ¢æ ‡ç­¾é¡µ
        function switchTab(tabId) {
            tabs.forEach(tab => {
                if (tab.getAttribute('data-tab') === tabId) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            tabContents.forEach(content => {
                if (content.id === `${tabId}-tab`) {
                    content.classList.add('active');
                } else {
                    content.classList.remove('active');
                }
            });

            if (tabId === 'today') {
                renderTodayTasks();
            } else if (tabId === 'tasks') {
                renderAllTasks();
            } else if (tabId === 'calendar') {
                renderCalendar();
            } else if (tabId === 'recorder') {
                renderRecordings();
            } else if (tabId === 'data') {
                renderDataStats();
            }
        }
        
        // åˆ‡æ¢å½•éŸ³æ¨¡å¼
        function switchRecorderMode(mode) {
            appData.currentMode = mode;
            
            if (mode === 'record') {
                recordModeBtn.classList.add('active');
                uploadModeBtn.classList.remove('active');
                recordContainer.classList.remove('hidden');
                uploadContainer.classList.add('hidden');
                
                if (appData.currentTask) {
                    updateRecorderTaskInfo();
                }
            } else {
                recordModeBtn.classList.remove('active');
                uploadModeBtn.classList.add('active');
                recordContainer.classList.add('hidden');
                uploadContainer.classList.remove('hidden');
                
                if (appData.currentTask) {
                    updateUploadTaskInfo();
                }
            }
        }

        // æ›´æ–°å½•éŸ³ç•Œé¢çš„ä»»åŠ¡ä¿¡æ¯
        function updateRecorderTaskInfo() {
            recorderTaskNameEl.textContent = `${appData.currentTask.subject} - ${appData.currentTask.name}`;
            const taskSchedule = getTaskCheckinSchedule(appData.currentTask);
            const checkpointDay = taskSchedule[appData.currentCheckpointIndex];
            
            if (appData.currentTask.scheduleType === 'daily') {
                recorderCheckpointEl.textContent = `ç¬¬${checkpointDay + 1}å¤©æ‰“å¡`;
            } else if (appData.currentTask.scheduleType === 'custom') {
                const startDate = new Date(appData.currentTask.createDate);
                const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                recorderCheckpointEl.textContent = `${checkinDate.toLocaleDateString()} æ‰“å¡`;
            } else {
                recorderCheckpointEl.textContent = `ç¬¬${checkpointDay}å¤©æ‰“å¡`;
            }
            
            if (appData.currentTask.description) {
                recorderTaskDescContentEl.textContent = appData.currentTask.description;
                recorderTaskDescriptionEl.classList.remove('hidden');
            } else {
                recorderTaskDescriptionEl.classList.add('hidden');
            }
        }

        // æ›´æ–°ä¸Šä¼ ç•Œé¢çš„ä»»åŠ¡ä¿¡æ¯
        function updateUploadTaskInfo() {
            uploadTaskNameEl.textContent = `${appData.currentTask.subject} - ${appData.currentTask.name}`;
            const taskSchedule = getTaskCheckinSchedule(appData.currentTask);
            const checkpointDay = taskSchedule[appData.currentCheckpointIndex];
            
            if (appData.currentTask.scheduleType === 'daily') {
                uploadCheckpointEl.textContent = `ç¬¬${checkpointDay + 1}å¤©æ‰“å¡`;
            } else if (appData.currentTask.scheduleType === 'custom') {
                const startDate = new Date(appData.currentTask.createDate);
                const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                uploadCheckpointEl.textContent = `${checkinDate.toLocaleDateString()} æ‰“å¡`;
            } else {
                uploadCheckpointEl.textContent = `ç¬¬${checkpointDay}å¤©æ‰“å¡`;
            }
            
            if (appData.currentTask.description) {
                uploadTaskDescContentEl.textContent = appData.currentTask.description;
                uploadTaskDescriptionEl.classList.remove('hidden');
            } else {
                uploadTaskDescriptionEl.classList.add('hidden');
            }
        }

        // æ˜¾ç¤ºä»»åŠ¡è¡¨å•
        function showTaskForm() {
            taskFormEl.classList.remove('hidden');
            hideEditTaskForm();
            document.getElementById('task-subject').value = 'è¯­æ–‡';
            document.getElementById('task-name').value = '';
            document.getElementById('task-desc').value = '';
            document.getElementById('task-date').valueAsDate = new Date();
            
            switchScheduleType('default');
            appData.customDates = [];
            renderCustomDatesList();
            
            taskFormEl.scrollIntoView({ behavior: 'smooth' });
        }

        // éšè—ä»»åŠ¡è¡¨å•
        function hideTaskForm() {
            taskFormEl.classList.add('hidden');
        }

        // æ˜¾ç¤ºç¼–è¾‘ä»»åŠ¡è¡¨å•
        function showEditTaskForm(taskId) {
            const task = appData.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            appData.editingTask = task;
            editTaskFormEl.classList.remove('hidden');
            hideTaskForm();
            
            document.getElementById('edit-task-subject').value = task.subject;
            document.getElementById('edit-task-name').value = task.name;
            document.getElementById('edit-task-desc').value = task.description || '';
            editTaskFormEl.scrollIntoView({ behavior: 'smooth' });
        }

        // éšè—ç¼–è¾‘ä»»åŠ¡è¡¨å•
        function hideEditTaskForm() {
            editTaskFormEl.classList.add('hidden');
            appData.editingTask = null;
        }

        // ä¿å­˜ä»»åŠ¡
        async function saveTask() {
            const subject = document.getElementById('task-subject').value;
            const name = document.getElementById('task-name').value.trim();
            const desc = document.getElementById('task-desc').value.trim();
            let date = document.getElementById('task-date').value;
            
            if (!name) {
                alert('è¯·è¾“å…¥ä»»åŠ¡åç§°');
                return;
            }
            
            if (!date) {
                date = new Date().toISOString().split('T')[0];
            }
            
            const newTask = {
                id: Date.now(),
                subject: subject,
                name: name,
                description: desc,
                createDate: date ? new Date(date).toISOString() : new Date().toISOString(),
                status: 'active',
                checkins: [],
                scheduleType: appData.currentScheduleType
            };
            
            // å¤„ç†ä¸åŒç±»å‹çš„æ‰“å¡è®¡åˆ’
            if (appData.currentScheduleType === 'daily') {
                const startDate = dailyStartDateInput.value;
                const endDate = dailyEndDateInput.value;
                const duration = dailyDurationInput.value;
                
                newTask.dailyStartDate = startDate || new Date().toISOString().split('T')[0];
                if (endDate) newTask.dailyEndDate = endDate;
                if (duration) newTask.dailyDuration = parseInt(duration);
                
            } else if (appData.currentScheduleType === 'custom') {
                if (appData.customDates.length === 0) {
                    alert('è¯·è‡³å°‘æ·»åŠ ä¸€ä¸ªè‡ªå®šä¹‰æ‰“å¡æ—¥æœŸ');
                    return;
                }
                newTask.customDates = [...appData.customDates];
            }
            
            appData.tasks.push(newTask);
            await saveTasks();
            hideTaskForm();
            
            appData.customDates = [];
            renderCustomDatesList();
            
            renderAllTasks();
            renderTodayTasks();
            renderCalendar();
            renderDataStats();
        }

        // æ›´æ–°ä»»åŠ¡
        async function updateTask() {
            if (!appData.editingTask) return;
            
            const subject = document.getElementById('edit-task-subject').value;
            const name = document.getElementById('edit-task-name').value.trim();
            const desc = document.getElementById('edit-task-desc').value.trim();
            
            if (!name) {
                alert('è¯·è¾“å…¥ä»»åŠ¡åç§°');
                return;
            }
            
            appData.editingTask.subject = subject;
            appData.editingTask.name = name;
            appData.editingTask.description = desc;
            
            await saveTasks();
            hideEditTaskForm();
            renderAllTasks();
            renderTodayTasks();
            renderCalendar();
            renderDataStats();
        }

        // è·å–ä»»åŠ¡çš„ä¸Šæ¬¡å½•éŸ³ç”¨æ—¶
        function getLastRecordingDuration(task) {
            if (task.checkins.length === 0) return null;
            
            const latestCheckin = task.checkins.reduce((latest, current) => 
                new Date(current.date) > new Date(latest.date) ? current : latest
            );
            
            const recording = appData.recordings.find(r => r.id === latestCheckin.recordingId);
            return recording ? recording.duration : null;
        }

        // è·å–æ¯æ—¥æ‰“å¡è®¡åˆ’
        function getDailyCheckinSchedule(task) {
            const startDate = new Date(task.dailyStartDate || task.createDate);
            startDate.setHours(0, 0, 0, 0);
            
            let endDate;
            if (task.dailyEndDate) {
                endDate = new Date(task.dailyEndDate);
                endDate.setHours(0, 0, 0, 0);
            } else if (task.dailyDuration) {
                endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + parseInt(task.dailyDuration));
            } else {
                // é»˜è®¤æŒç»­30å¤©
                endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + 30);
            }
            
            const schedule = [];
            const currentDate = new Date(startDate);
            
            while (currentDate <= endDate) {
                const daysSinceStart = Math.floor((currentDate - startDate) / (1000 * 60 * 60 * 24));
                schedule.push(daysSinceStart);
                currentDate.setDate(currentDate.getDate() + 1);
            }
            
            return schedule;
        }

        // è·å–ä»»åŠ¡çš„æ‰“å¡è®¡åˆ’
        function getTaskCheckinSchedule(task) {
            if (task.scheduleType === 'daily') {
                return getDailyCheckinSchedule(task);
            } else if (task.scheduleType === 'custom' && task.customDates) {
                const startDate = new Date(task.createDate);
                startDate.setHours(0, 0, 0, 0);
                
                return task.customDates.map(customDate => {
                    const date = new Date(customDate);
                    date.setHours(0, 0, 0, 0);
                    return Math.floor((date - startDate) / (1000 * 60 * 60 * 24));
                }).sort((a, b) => a - b);
            }
            
            return checkinSchedule;
        }

        // è·å–æ¯æ—¥æ‰“å¡ä»»åŠ¡ä¿¡æ¯
        function getDailyScheduleInfo(task) {
            const startDate = new Date(task.dailyStartDate || task.createDate);
            const endDate = task.dailyEndDate ? new Date(task.dailyEndDate) : 
                           task.dailyDuration ? new Date(startDate.getTime() + task.dailyDuration * 24 * 60 * 60 * 1000) : null;
            
            let info = `ä» ${startDate.toLocaleDateString()} å¼€å§‹`;
            if (endDate) {
                info += ` åˆ° ${endDate.toLocaleDateString()} ç»“æŸ`;
            } else if (task.dailyDuration) {
                info += `ï¼ŒæŒç»­ ${task.dailyDuration} å¤©`;
            } else {
                info += 'ï¼ŒæŒç»­è¿›è¡Œ';
            }
            
            return info;
        }

        // æ¸²æŸ“ä»Šæ—¥ä»»åŠ¡
        function renderTodayTasks() {
            todayTasksEl.innerHTML = '';
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            let tasksForToday = [];
            let totalTasks = 0;
            let uncompletedTasks = 0;
            
            appData.tasks.forEach(task => {
                if (task.status !== 'active') return;
                
                const taskSchedule = getTaskCheckinSchedule(task);
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((today - taskDate) / (1000 * 60 * 60 * 24));
                
                const checkpointIndex = taskSchedule.findIndex(day => day === daysSinceStart);
                
                if (checkpointIndex !== -1) {
                    const hasCheckedIn = task.checkins.some(checkin => 
                        checkin.checkpointIndex === checkpointIndex
                    );
                    
                    totalTasks++;
                    if (!hasCheckedIn) uncompletedTasks++;
                    
                    tasksForToday.push({
                        task,
                        checkpointIndex,
                        daysSinceStart,
                        isOverdue: false,
                        hasCheckedIn,
                        hasPendingRecording: false
                    });
                }
                
                for (let i = 0; i < taskSchedule.length; i++) {
                    const checkpointDay = taskSchedule[i];
                    if (checkpointDay < daysSinceStart && 
                        !task.checkins.some(checkin => checkin.checkpointIndex === i)) {
                        
                        totalTasks++;
                        uncompletedTasks++;
                        
                        tasksForToday.push({
                            task,
                            checkpointIndex: i,
                            daysSinceStart,
                            isOverdue: true,
                            hasCheckedIn: false,
                            hasPendingRecording: false
                        });
                    }
                }
            });
            
            todayTasksCountEl.textContent = `${uncompletedTasks}/${totalTasks} ä¸ªä»»åŠ¡`;
            
            tasksForToday.sort((a, b) => {
                const subjectOrder = { 'è¯­æ–‡': 1, 'æ•°å­¦': 2, 'è‹±è¯­': 3, 'ç§‘å­¦': 4, 'å…¶ä»–': 5 };
                const subjectA = subjectOrder[a.task.subject] || 6;
                const subjectB = subjectOrder[b.task.subject] || 6;
                
                if (subjectA !== subjectB) {
                    return subjectA - subjectB;
                }
                
                return new Date(b.task.createDate) - new Date(a.task.createDate);
            });
            
            if (tasksForToday.length === 0) {
                todayTasksEl.innerHTML = `
                    <div class="empty-state">
                        <i>ğŸ“…</i>
                        <p>ä»Šå¤©æ²¡æœ‰æ‰“å¡ä»»åŠ¡ï¼Œæ”¾æ¾ä¸€ä¸‹å§ï¼</p>
                    </div>
                `;
                return;
            }
            
            tasksForToday.forEach(item => {
                renderTodayTaskItem(item.task, todayTasksEl, item.checkpointIndex, item.daysSinceStart, 
                              item.isOverdue, item.hasCheckedIn, item.hasPendingRecording);
            });
        }

        // æ¸²æŸ“ä»Šæ—¥ä»»åŠ¡é¡¹
        function renderTodayTaskItem(task, container, checkpointIndex, daysSinceStart, isOverdue = false, hasCheckedIn = false, hasPendingRecording = false) {
            const taskEl = document.createElement('div');
            
            let taskClass = 'task-item';
            if (isOverdue) {
                taskClass += ' overdue';
            } else if (hasCheckedIn) {
                taskClass += ' completed';
            }
            
            taskEl.className = taskClass;
            
            const taskSchedule = getTaskCheckinSchedule(task);
            const checkpointDay = taskSchedule[checkpointIndex];
            
            let statusText = '';
            
            if (isOverdue) {
                statusText = `é€¾æœŸ${daysSinceStart - checkpointDay}å¤©`;
            } else {
                if (task.scheduleType === 'daily') {
                    statusText = `ç¬¬${daysSinceStart + 1}å¤©`;
                } else if (task.scheduleType === 'custom') {
                    const startDate = new Date(task.createDate);
                    const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                    statusText = checkinDate.toLocaleDateString();
                } else {
                    statusText = checkpointDay === 0 ? 'æ–°ä»»åŠ¡' : `ç¬¬${checkpointDay}å¤©`;
                }
            }
            
            const completedCheckins = task.checkins.length;
            const totalCheckins = taskSchedule.length;
            const progressPercent = (completedCheckins / totalCheckins) * 100;
            
            const lastRecordingDuration = getLastRecordingDuration(task);
            const lastRecordingText = lastRecordingDuration ? 
                `ä¸Šæ¬¡å½•éŸ³ç”¨æ—¶: ${formatTime(lastRecordingDuration)}` : '';
            
            const compactCheckinInfo = generateCompactCheckinInfo(task);
            
            const subjectClass = `subject-${getSubjectClass(task.subject)}`;
            
            const hasPlayableRecording = completedCheckins > 0;
            
            // æ·»åŠ æ¯æ—¥æ‰“å¡æ ‡è¯†
            const dailyBadge = task.scheduleType === 'daily' ? '<span class="daily-task-badge">æ¯æ—¥</span>' : '';
            
            taskEl.innerHTML = `
                <div class="task-header">
                    <div class="task-name ${subjectClass}">${task.subject} - ${task.name}${dailyBadge}</div>
                    <div class="task-status ${hasCheckedIn ? 'status-completed' : (isOverdue ? 'status-overdue' : 'status-today')}">
                        ${statusText} ${hasCheckedIn ? 'âœ“ ä»Šæ—¥å·²æ‰“å¡' : 'æœªå®Œæˆ'}
                    </div>
                </div>
                ${task.description ? `<p>${task.description}</p>` : ''}
                ${task.scheduleType === 'daily' ? `
                    <div class="daily-schedule-info">
                        <div class="daily-schedule-dates">
                            ${getDailyScheduleInfo(task)}
                        </div>
                    </div>
                ` : ''}
                <div class="task-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    <div class="progress-text">
                        å·²å®Œæˆ ${completedCheckins} æ¬¡æ‰“å¡
                        ${lastRecordingText ? `<div class="last-recording-time">${lastRecordingText}</div>` : ''}
                        ${task.scheduleType === 'custom' ? '<div>ğŸ“… è‡ªå®šä¹‰æ—¥æœŸè®¡åˆ’</div>' : ''}
                    </div>
                    ${compactCheckinInfo}
                </div>
                <div class="task-actions">
                    ${!hasCheckedIn ? 
                        `<button class="btn btn-primary" onclick="startCheckin(${task.id}, ${checkpointIndex})">
                            ç«‹å³æ‰“å¡
                        </button>` : ''}
                    <button class="btn btn-secondary" onclick="showEditTaskForm(${task.id})">ç¼–è¾‘</button>
                    <button class="btn btn-secondary" onclick="viewTaskDetails(${task.id})">è¯¦æƒ…</button>
                    <button class="btn btn-danger" onclick="deleteTask(${task.id})">åˆ é™¤</button>
                    ${hasPlayableRecording ? `<button class="btn btn-secondary" onclick="playLatestRecording(${task.id})" id="play-latest-${task.id}">å›æ”¾å½•éŸ³</button>` : ''}
                </div>
            `;
            
            container.appendChild(taskEl);
        }

        // æ¸²æŸ“æ‰€æœ‰ä»»åŠ¡
        function renderAllTasks() {
            allTasksEl.innerHTML = '';
            
            if (appData.tasks.length === 0) {
                allTasksEl.innerHTML = `
                    <div class="empty-state">
                        <i>ğŸ“</i>
                        <p>è¿˜æ²¡æœ‰ä»»ä½•ä»»åŠ¡ï¼Œç‚¹å‡»"æ–°å»ºä»»åŠ¡"å¼€å§‹å§ï¼</p>
                    </div>
                `;
                return;
            }
            
            const sortedTasks = [...appData.tasks].sort((a, b) => {
                const subjectOrder = { 'è¯­æ–‡': 1, 'æ•°å­¦': 2, 'è‹±è¯­': 3, 'ç§‘å­¦': 4, 'å…¶ä»–': 5 };
                const subjectA = subjectOrder[a.subject] || 6;
                const subjectB = subjectOrder[b.subject] || 6;
                
                if (subjectA !== subjectB) {
                    return subjectA - subjectB;
                }
                
                return new Date(b.createDate) - new Date(a.createDate);
            });
            
            sortedTasks.forEach(task => {
                const taskEl = document.createElement('div');
                taskEl.className = 'task-item';
                
                const taskSchedule = getTaskCheckinSchedule(task);
                const completedCheckins = task.checkins.length;
                const totalCheckins = taskSchedule.length;
                const progressPercent = (completedCheckins / totalCheckins) * 100;
                
                const lastRecordingDuration = getLastRecordingDuration(task);
                const lastRecordingText = lastRecordingDuration ? 
                    `ä¸Šæ¬¡å½•éŸ³ç”¨æ—¶: ${formatTime(lastRecordingDuration)}` : '';
                
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((today - taskDate) / (1000 * 60 * 60 * 24));
                const checkpointIndex = taskSchedule.findIndex(day => day === daysSinceStart);
                const shouldCheckinToday = checkpointIndex !== -1;
                const hasCheckedInToday = shouldCheckinToday ? 
                    task.checkins.some(checkin => checkin.checkpointIndex === checkpointIndex) : false;
                
                let hasOverdue = false;
                for (let i = 0; i < taskSchedule.length; i++) {
                    const checkpointDay = taskSchedule[i];
                    if (checkpointDay < daysSinceStart && 
                        !task.checkins.some(checkin => checkin.checkpointIndex === i)) {
                        hasOverdue = true;
                        break;
                    }
                }
                
                const canCheckinToday = shouldCheckinToday && !hasCheckedInToday;
                const hasOverdueCheckin = hasOverdue;
                const checkinBtnEnabled = canCheckinToday || hasOverdueCheckin;
                
                let statusClass = 'status-future';
                let statusText = '';
                
                if (hasOverdue) {
                    statusClass = 'status-overdue';
                    statusText = 'æœ‰é€¾æœŸ';
                } else if (shouldCheckinToday) {
                    statusClass = hasCheckedInToday ? 'status-completed' : 'status-pending';
                    statusText = hasCheckedInToday ? 'ä»Šæ—¥å·²æ‰“å¡' : 'ä»Šæ—¥æœªæ‰“å¡';
                }
                
                const compactCheckinInfo = generateCompactCheckinInfo(task);
                
                const subjectClass = `subject-${getSubjectClass(task.subject)}`;
                
                const hasPlayableRecording = completedCheckins > 0;
                
                // æ·»åŠ æ¯æ—¥æ‰“å¡æ ‡è¯†
                const dailyBadge = task.scheduleType === 'daily' ? '<span class="daily-task-badge">æ¯æ—¥</span>' : '';
                
                taskEl.innerHTML = `
                    <div class="task-header">
                        <div class="task-name ${subjectClass}">${task.subject} - ${task.name}${dailyBadge}</div>
                        <div class="task-status ${statusClass}">
                            ${completedCheckins}/${totalCheckins}
                            ${statusText}
                        </div>
                    </div>
                    ${task.description ? `<p>${task.description}</p>` : ''}
                    ${task.scheduleType === 'daily' ? `
                        <div class="daily-schedule-info">
                            <div class="daily-schedule-dates">
                                ${getDailyScheduleInfo(task)}
                            </div>
                        </div>
                    ` : ''}
                    <div class="task-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${progressPercent}%"></div>
                        </div>
                        <div class="progress-text">
                            å·²å®Œæˆ ${completedCheckins} æ¬¡æ‰“å¡ï¼Œè¿˜éœ€ ${totalCheckins - completedCheckins} æ¬¡
                            ${lastRecordingText ? `<div class="last-recording-time">${lastRecordingText}</div>` : ''}
                            ${task.scheduleType === 'custom' ? '<div>ğŸ“… è‡ªå®šä¹‰æ—¥æœŸè®¡åˆ’</div>' : ''}
                        </div>
                        ${compactCheckinInfo}
                    </div>
                    <div class="task-actions">
                        <button class="btn ${checkinBtnEnabled ? 'btn-primary' : 'btn-disabled'}" onclick="handleCheckinClick(${task.id}, ${!checkinBtnEnabled})">
                            æ‰“å¡
                        </button>
                        <button class="btn btn-secondary" onclick="showEditTaskForm(${task.id})">ç¼–è¾‘</button>
                        <button class="btn btn-secondary" onclick="viewTaskDetails(${task.id})">è¯¦æƒ…</button>
                        <button class="btn btn-danger" onclick="deleteTask(${task.id})">åˆ é™¤</button>
                        ${hasPlayableRecording ? `<button class="btn btn-secondary" onclick="playLatestRecording(${task.id})" id="play-latest-${task.id}">å›æ”¾å½•éŸ³</button>` : ''}
                    </div>
                `;
                
                allTasksEl.appendChild(taskEl);
            });
        }

        // è·å–ç§‘ç›®å¯¹åº”çš„CSSç±»å
        function getSubjectClass(subject) {
            const subjectMap = {
                'è¯­æ–‡': 'chinese',
                'æ•°å­¦': 'math',
                'è‹±è¯­': 'english',
                'ç§‘å­¦': 'science',
                'å…¶ä»–': 'other'
            };
            return subjectMap[subject] || 'other';
        }

        // ç”Ÿæˆç´§å‡‘çš„æ‰“å¡è®°å½•ä¿¡æ¯
        function generateCompactCheckinInfo(task) {
            if (task.checkins.length === 0) {
                return '';
            }
            
            const taskSchedule = getTaskCheckinSchedule(task);
            const recentCheckins = [...task.checkins]
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .slice(0, 3);
            
            const checkinItems = recentCheckins.map(checkin => {
                const checkpointDay = taskSchedule[checkin.checkpointIndex];
                
                if (task.scheduleType === 'daily') {
                    const date = new Date(checkin.date);
                    const formattedDate = `${date.getMonth()+1}/${date.getDate()}`;
                    return `<span class="compact-checkin-item">ç¬¬${checkpointDay + 1}å¤© ${formattedDate}</span>`;
                } else if (task.scheduleType === 'custom') {
                    const startDate = new Date(task.createDate);
                    const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                    const formattedDate = `${checkinDate.getMonth()+1}/${checkinDate.getDate()}`;
                    return `<span class="compact-checkin-item">${formattedDate}</span>`;
                } else {
                    const date = new Date(checkin.date);
                    const formattedDate = `${date.getMonth()+1}/${date.getDate()}`;
                    return `<span class="compact-checkin-item">ç¬¬${checkpointDay}å¤© ${formattedDate}</span>`;
                }
            }).join('');
            
            return `<div class="compact-checkin-info">æœ€è¿‘æ‰“å¡: ${checkinItems}</div>`;
        }

        // å¤„ç†æ‰“å¡æŒ‰é’®ç‚¹å‡»
        function handleCheckinClick(taskId, isDisabled) {
            if (isDisabled) {
                alert('ä»Šæ—¥å·²ç»æ‰“å¡æˆåŠŸï¼');
                return;
            }
            startCheckin(taskId);
        }

        // æ’­æ”¾æœ€æ–°å½•éŸ³
        async function playLatestRecording(taskId) {
            try {
                const recordings = await audioStorage.getRecordingsByTask(taskId);
                if (recordings.length === 0) {
                    alert('è¯¥ä»»åŠ¡æ²¡æœ‰å½•éŸ³è®°å½•');
                    return;
                }
                
                // æŒ‰æ—¥æœŸæ’åºï¼Œè·å–æœ€æ–°å½•éŸ³
                const latestRecording = recordings.sort((a, b) => 
                    new Date(b.date) - new Date(a.date)
                )[0];
                
                await playSavedRecording(latestRecording.id);
                
            } catch (error) {
                console.error('æ’­æ”¾æœ€æ–°å½•éŸ³å¤±è´¥:', error);
                alert('åŠ è½½å½•éŸ³å¤±è´¥');
            }
        }

        // æ’­æ”¾ä¿å­˜çš„å½•éŸ³
        async function playSavedRecording(recordingId) {
            try {
                const recording = await audioStorage.getRecording(recordingId);
                if (!recording) {
                    alert('æœªæ‰¾åˆ°å½•éŸ³è®°å½•');
                    return;
                }
                
                if (!recording.audioUrl && recording.audioData) {
                    createAudioUrlFromData(recording);
                }
                
                if (recording.audioUrl) {
                    const playBtn = document.getElementById(`play-saved-${recordingId}`);
                    if (playBtn) {
                        playBtn.textContent = 'å½•éŸ³å›æ”¾ä¸­';
                        playBtn.disabled = true;
                    }
                    
                    switchTab('recorder');
                    
                    audioPlayer.src = recording.audioUrl;
                    audioPlayer.classList.remove('hidden');
                    
                    audioPlayer.play().then(() => {
                        console.log('å½•éŸ³å¼€å§‹æ’­æ”¾');
                    }).catch(error => {
                        console.error('æ’­æ”¾å¤±è´¥:', error);
                        alert('æ’­æ”¾å½•éŸ³å¤±è´¥: ' + error.message);
                        if (playBtn) {
                            playBtn.textContent = 'æ’­æ”¾';
                            playBtn.disabled = false;
                        }
                    });
                    
                    audioPlayer.onended = () => {
                        if (playBtn) {
                            playBtn.textContent = 'æ’­æ”¾';
                            playBtn.disabled = false;
                        }
                    };
                    
                } else {
                    alert('å½•éŸ³æ•°æ®ä¸å¯ç”¨ï¼Œå¯èƒ½å·²æŸå');
                }
            } catch (error) {
                console.error('æ’­æ”¾å½•éŸ³å¤±è´¥:', error);
                alert('åŠ è½½å½•éŸ³å¤±è´¥');
            }
        }

        // ä»Base64æ•°æ®åˆ›å»ºå¯æ’­æ”¾çš„URL
        function createAudioUrlFromData(recording) {
            if (recording.audioData && !recording.audioUrl) {
                try {
                    const parts = recording.audioData.split(',');
                    if (parts.length < 2) {
                        console.error('Base64æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
                        return;
                    }
                    
                    const mimeType = parts[0].match(/:(.*?);/)[1];
                    const base64Data = parts[1];
                    
                    const byteCharacters = atob(base64Data);
                    const byteArrays = [];
                    
                    for (let offset = 0; offset < byteCharacters.length; offset += 512) {
                        const slice = byteCharacters.slice(offset, offset + 512);
                        
                        const byteNumbers = new Array(slice.length);
                        for (let i = 0; i < slice.length; i++) {
                            byteNumbers[i] = slice.charCodeAt(i);
                        }
                        
                        const byteArray = new Uint8Array(byteNumbers);
                        byteArrays.push(byteArray);
                    }
                    
                    const blob = new Blob(byteArrays, { type: mimeType });
                    recording.audioUrl = URL.createObjectURL(blob);
                } catch (error) {
                    console.error('åˆ›å»ºéŸ³é¢‘URLå¤±è´¥:', error);
                }
            }
        }

        // åŠ è½½å½•éŸ³æ•°æ®æ—¶æ¢å¤æ‰€æœ‰å½•éŸ³çš„URL
        function restoreRecordingUrls() {
            appData.recordings.forEach(recording => {
                createAudioUrlFromData(recording);
            });
        }

        // å¼€å§‹æ‰“å¡
        function startCheckin(taskId, checkpointIndex = null) {
            const task = appData.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            appData.currentTask = task;
            
            if (checkpointIndex === null) {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((today - taskDate) / (1000 * 60 * 60 * 24));
                const taskSchedule = getTaskCheckinSchedule(task);
                checkpointIndex = taskSchedule.findIndex(day => day === daysSinceStart);
                
                if (checkpointIndex === -1) {
                    const overdueCheckpoints = [];
                    for (let i = 0; i < taskSchedule.length; i++) {
                        if (taskSchedule[i] < daysSinceStart && 
                            !task.checkins.some(checkin => checkin.checkpointIndex === i)) {
                            overdueCheckpoints.push({
                                index: i,
                                day: taskSchedule[i]
                            });
                        }
                    }
                    
                    overdueCheckpoints.sort((a, b) => a.day - b.day);
                    
                    if (overdueCheckpoints.length > 0) {
                        checkpointIndex = overdueCheckpoints[0].index;
                    }
                }
            }
            
            appData.currentCheckpointIndex = checkpointIndex;
            
            switchTab('recorder');
            
            updateRecorderTaskInfo();
            updateUploadTaskInfo();
            
            resetRecorder();
            resetUpload();
        }

        // å¼€å§‹å½•éŸ³
        async function startRecording() {
            if (!appData.currentTask) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªä»»åŠ¡ï¼');
                return;
            }
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                appData.mediaRecorder = new MediaRecorder(stream);
                appData.audioChunks = [];
                
                appData.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        appData.audioChunks.push(event.data);
                    }
                };
                
                appData.mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(appData.audioChunks, { type: 'audio/wav' });
                    
                    const reader = new FileReader();
                    reader.onload = async function() {
                        const base64Audio = reader.result;
                        
                        const recording = {
                            id: Date.now(),
                            taskId: appData.currentTask.id,
                            checkpointIndex: appData.currentCheckpointIndex,
                            date: new Date().toISOString(),
                            duration: appData.recordingTime,
                            audioData: base64Audio,
                            mimeType: 'audio/wav'
                        };
                        
                        createAudioUrlFromData(recording);
                        
                        // ä¿å­˜åˆ°IndexedDB
                        await audioStorage.saveRecording(recording);
                        
                        appData.currentRecording = recording;
                        
                        stream.getTracks().forEach(track => track.stop());
                        clearRecordingState();
                        
                        recordBtn.classList.remove('recording', 'hidden');
                        pauseBtn.classList.add('hidden');
                        stopBtn.classList.add('hidden');
                        playBtn.classList.remove('hidden');
                        submitRecordingBtn.disabled = false;
                        
                        audioPlayer.src = recording.audioUrl;
                        audioPlayer.classList.remove('hidden');
                        
                        console.log('å½•éŸ³ä¿å­˜å®Œæˆï¼ŒID:', recording.id);
                    };
                    reader.readAsDataURL(audioBlob);
                };
                
                appData.isRecording = true;
                appData.isPaused = false;
                appData.recordingTime = 0;
                
                recordBtn.classList.add('recording');
                pauseBtn.classList.remove('hidden');
                stopBtn.classList.remove('hidden');
                recordBtn.classList.add('hidden');
                
                updatePlaybackStatus('å½•éŸ³ä¸­...', 'status-recording');
                
                appData.mediaRecorder.start();
                
                appData.timerInterval = setInterval(() => {
                    appData.recordingTime += 10;
                    updateTimer();
                    updateWaveform();
                }, 10);
                
            } catch (error) {
                console.error('å½•éŸ³å¯åŠ¨å¤±è´¥:', error);
                alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
            }
        }

        // æš‚åœå½•éŸ³
        function togglePause() {
            if (!appData.mediaRecorder) return;
            
            if (appData.isPaused) {
                appData.mediaRecorder.resume();
                appData.isPaused = false;
                pauseBtn.innerHTML = 'âšâš';
                updatePlaybackStatus('å½•éŸ³ä¸­...', 'status-recording');
                
                appData.timerInterval = setInterval(() => {
                    appData.recordingTime += 10;
                    updateTimer();
                    updateWaveform();
                }, 10);
            } else {
                appData.mediaRecorder.pause();
                appData.isPaused = true;
                clearInterval(appData.timerInterval);
                pauseBtn.innerHTML = 'â–¶';
                updatePlaybackStatus('å½•éŸ³å·²æš‚åœ', 'status-playing');
                saveRecordingState();
            }
        }

        // åœæ­¢å½•éŸ³
        function stopRecording() {
            if (!appData.mediaRecorder || appData.mediaRecorder.state === 'inactive') return;
            
            appData.mediaRecorder.stop();
            appData.isRecording = false;
            appData.isPaused = false;
            
            clearInterval(appData.timerInterval);
            
            recordBtn.classList.remove('recording', 'hidden');
            pauseBtn.classList.add('hidden');
            stopBtn.classList.add('hidden');
            playBtn.classList.remove('hidden');
            submitRecordingBtn.disabled = false;
            
            recordingStatusEl.classList.add('hidden');
            clearRecordingState();
        }

        // æ’­æ”¾å½•éŸ³
        function playRecording() {
            if (!appData.currentRecording) {
                console.log('æ²¡æœ‰å½“å‰å½•éŸ³å¯æ’­æ”¾');
                return;
            }
            
            if (!appData.currentRecording.audioUrl && appData.currentRecording.audioData) {
                createAudioUrlFromData(appData.currentRecording);
            }
            
            if (appData.currentRecording.audioUrl) {
                audioPlayer.src = appData.currentRecording.audioUrl;
                audioPlayer.classList.remove('hidden');
                audioPlayer.play().catch(error => {
                    console.error('æ’­æ”¾å¤±è´¥:', error);
                    alert('æ’­æ”¾å½•éŸ³å¤±è´¥');
                });
            } else {
                alert('å½•éŸ³æ•°æ®ä¸å¯ç”¨ï¼Œå¯èƒ½å·²æŸå');
            }
        }

        // æäº¤å½•éŸ³
        async function submitRecording() {
            if (!appData.currentRecording) {
                alert('è¯·å…ˆå®Œæˆå½•éŸ³ï¼');
                return;
            }
            
            const task = appData.tasks.find(t => t.id === appData.currentRecording.taskId);
            if (!task) return;
            
            const taskSchedule = getTaskCheckinSchedule(task);
            const alreadyCheckedIn = task.checkins.some(
                checkin => checkin.checkpointIndex === appData.currentRecording.checkpointIndex
            );
            
            if (alreadyCheckedIn) {
                alert('è¿™ä¸ªæ‰“å¡ç‚¹å·²ç»å®Œæˆè¿‡äº†ï¼');
                return;
            }
            
            task.checkins.push({
                checkpointIndex: appData.currentRecording.checkpointIndex,
                date: appData.currentRecording.date,
                recordingId: appData.currentRecording.id
            });
            
            if (task.checkins.length === taskSchedule.length) {
                task.status = 'completed';
                alert(`æ­å–œï¼ä»»åŠ¡"${task.name}"å·²å®Œæˆï¼`);
            } else {
                alert('æ‰“å¡æˆåŠŸï¼');
            }
            
            await saveTasks();
            
            resetRecorder();
            renderRecordings();
            renderTodayTasks();
            renderAllTasks();
            renderCalendar();
            renderDataStats();
        }

        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('audio/')) {
                alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶ï¼');
                resetUpload();
                return;
            }
            
            if (file.size > 100 * 1024 * 1024) { // å¢åŠ åˆ°100MBé™åˆ¶
                alert('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡100MB');
                resetUpload();
                return;
            }
            
            fileNameEl.textContent = file.name;
            fileSizeEl.textContent = formatFileSize(file.size);
            fileDurationEl.textContent = 'è®¡ç®—ä¸­...';
            fileInfoEl.classList.remove('hidden');
            
            const tempAudio = new Audio();
            const tempUrl = URL.createObjectURL(file);
            tempAudio.src = tempUrl;
            
            tempAudio.addEventListener('loadedmetadata', () => {
                const duration = Math.floor(tempAudio.duration * 1000);
                fileDurationEl.textContent = formatTime(duration);
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    appData.uploadedAudio = {
                        file: file,
                        duration: duration,
                        audioData: e.target.result,
                        mimeType: file.type
                    };
                    
                    uploadedAudioPlayer.src = e.target.result;
                    uploadedAudioPlayer.classList.remove('hidden');
                    
                    submitUploadBtn.disabled = false;
                    
                    URL.revokeObjectURL(tempUrl);
                };
                reader.readAsDataURL(file);
            });
            
            tempAudio.addEventListener('error', () => {
                fileDurationEl.textContent = 'è®¡ç®—å¤±è´¥';
                alert('æ— æ³•è¯»å–éŸ³é¢‘æ–‡ä»¶ï¼Œè¯·é€‰æ‹©å…¶ä»–æ–‡ä»¶');
                resetUpload();
                URL.revokeObjectURL(tempUrl);
            });
        }

        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / 1048576).toFixed(1) + ' MB';
        }

        // æäº¤ä¸Šä¼ çš„éŸ³é¢‘
        async function submitUploadedAudio() {
            if (!appData.uploadedAudio || !appData.currentTask) return;
            
            const recording = {
                id: Date.now(),
                taskId: appData.currentTask.id,
                checkpointIndex: appData.currentCheckpointIndex,
                date: new Date().toISOString(),
                duration: appData.uploadedAudio.duration,
                audioData: appData.uploadedAudio.audioData,
                mimeType: appData.uploadedAudio.mimeType,
                source: 'upload'
            };
            
            createAudioUrlFromData(recording);
            
            // ä¿å­˜åˆ°IndexedDB
            await audioStorage.saveRecording(recording);
            
            const task = appData.tasks.find(t => t.id === recording.taskId);
            if (!task) return;
            
            const taskSchedule = getTaskCheckinSchedule(task);
            const alreadyCheckedIn = task.checkins.some(
                checkin => checkin.checkpointIndex === recording.checkpointIndex
            );
            
            if (alreadyCheckedIn) {
                alert('è¿™ä¸ªæ‰“å¡ç‚¹å·²ç»å®Œæˆè¿‡äº†ï¼');
                return;
            }
            
            task.checkins.push({
                checkpointIndex: recording.checkpointIndex,
                date: recording.date,
                recordingId: recording.id
            });
            
            if (task.checkins.length === taskSchedule.length) {
                task.status = 'completed';
                alert(`æ­å–œï¼ä»»åŠ¡"${task.name}"å·²å®Œæˆï¼`);
            } else {
                alert('æ‰“å¡æˆåŠŸï¼');
            }
            
            await saveTasks();
            
            resetUpload();
            renderRecordings();
            renderTodayTasks();
            renderAllTasks();
            renderCalendar();
            renderDataStats();
        }

        // é‡ç½®ä¸Šä¼ ç•Œé¢
        function resetUpload() {
            audioFileInput.value = '';
            fileInfoEl.classList.add('hidden');
            uploadedAudioPlayer.classList.add('hidden');
            uploadedAudioPlayer.src = '';
            submitUploadBtn.disabled = true;
            appData.uploadedAudio = null;
        }

        // æ›´æ–°è®¡æ—¶å™¨
        function updateTimer() {
            timerEl.textContent = formatTime(appData.recordingTime);
        }

        // æ ¼å¼åŒ–æ—¶é—´
        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            const ms = Math.floor((milliseconds % 1000) / 10);
            
            if (hours > 0) {
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }

        // æ›´æ–°æ³¢å½¢å›¾
        function updateWaveform() {
            if (Math.random() < 0.3) {
                const bar = document.createElement('div');
                bar.className = 'waveform-bar';
                bar.style.height = `${10 + Math.random() * 80}px`;
                bar.style.left = `${Math.random() * 95}%`;
                waveformEl.appendChild(bar);
                
                if (waveformEl.children.length > 50) {
                    waveformEl.removeChild(waveformEl.firstChild);
                }
            }
        }

        // æ¸…ç©ºæ³¢å½¢å›¾
        function clearWaveform() {
            waveformEl.innerHTML = '';
        }

        // é‡ç½®å½•éŸ³å™¨
        function resetRecorder() {
            appData.isRecording = false;
            appData.isPaused = false;
            appData.recordingTime = 0;
            
            clearInterval(appData.timerInterval);
            
            recordBtn.classList.remove('recording', 'hidden');
            pauseBtn.classList.add('hidden');
            stopBtn.classList.add('hidden');
            playBtn.classList.add('hidden');
            submitRecordingBtn.disabled = true;
            
            audioPlayer.classList.add('hidden');
            audioPlayer.src = '';
            recordingStatusEl.classList.add('hidden');
            
            updateTimer();
            clearWaveform();
            clearRecordingState();
        }

        // æŸ¥çœ‹ä»»åŠ¡è¯¦æƒ…
        function viewTaskDetails(taskId) {
            const task = appData.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            appData.currentTask = task;
            
            const taskSchedule = getTaskCheckinSchedule(task);
            const checkinDetails = taskSchedule.map((day, index) => {
                const checkin = task.checkins.find(c => c.checkpointIndex === index);
                
                let status = checkin ? 'å®Œæˆ' : 'æœªå®Œæˆ';
                let statusIcon = checkin ? 'âœ…' : 'âŒ';
                let statusClass = checkin ? 'status-completed-icon' : 'status-missed-icon';
                
                let dayDisplay;
                let dateDisplay = '';
                if (task.scheduleType === 'daily') {
                    dayDisplay = `ç¬¬${day + 1}å¤©`;
                    const startDate = new Date(task.dailyStartDate || task.createDate);
                    const checkinDate = new Date(startDate.getTime() + day * 24 * 60 * 60 * 1000);
                    const weekdays = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
                    const weekday = weekdays[checkinDate.getDay()];
                    dateDisplay = ` (${checkinDate.toLocaleDateString()} å‘¨${weekday})`;
                } else if (task.scheduleType === 'custom') {
                    const startDate = new Date(task.createDate);
                    const checkinDate = new Date(startDate.getTime() + day * 24 * 60 * 60 * 1000);
                    dayDisplay = checkinDate.toLocaleDateString();
                    const weekdays = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
                    const weekday = weekdays[checkinDate.getDay()];
                    dateDisplay = ` (å‘¨${weekday})`;
                } else {
                    dayDisplay = `ç¬¬${day.toString().padStart(3, ' ')}å¤©`;
                    const startDate = new Date(task.createDate);
                    const checkinDate = new Date(startDate.getTime() + day * 24 * 60 * 60 * 1000);
                    const weekdays = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
                    const weekday = weekdays[checkinDate.getDay()];
                    dateDisplay = ` (${checkinDate.toLocaleDateString()} å‘¨${weekday})`;
                }
                
                return `
                    <div class="checkin-item">
                        <div class="checkin-day">${dayDisplay}${dateDisplay}:</div>
                        <div class="checkin-status">
                            <span class="status-icon ${statusClass}">${statusIcon}</span>
                            <span>${status}</span>
                        </div>
                    </div>
                `;
            }).join('');
            
            taskDetailsTitle.textContent = `${task.subject} - ${task.name}`;
            taskDetailsContent.innerHTML = `
                <div class="form-group">
                    <label>ä»»åŠ¡æè¿°</label>
                    <p>${task.description || 'æ— æè¿°'}</p>
                </div>
                <div class="form-group">
                    <label>åˆ›å»ºæ—¥æœŸ</label>
                    <p>${new Date(task.createDate).toLocaleDateString()}</p>
                </div>
                <div class="form-group">
                    <label>æ‰“å¡è®¡åˆ’ç±»å‹</label>
                    <p>${task.scheduleType === 'daily' ? 'æ¯æ—¥æ‰“å¡' : (task.scheduleType === 'custom' ? 'è‡ªå®šä¹‰æ—¥æœŸ' : 'é»˜è®¤è®¡åˆ’')}</p>
                </div>
                ${task.scheduleType === 'daily' ? `
                    <div class="form-group">
                        <label>æ¯æ—¥æ‰“å¡ä¿¡æ¯</label>
                        <p>${getDailyScheduleInfo(task)}</p>
                    </div>
                ` : ''}
                <div class="checkin-progress">
                    <h4>æ‰“å¡è¿›åº¦</h4>
                    ${checkinDetails}
                </div>
            `;
            
            taskDetailsModal.classList.remove('hidden');
        }

        // éšè—ä»»åŠ¡è¯¦æƒ…
        function hideTaskDetails() {
            taskDetailsModal.classList.add('hidden');
            appData.currentTask = null;
        }

        // åˆ é™¤ä»»åŠ¡
        async function deleteTask(taskId) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä»»åŠ¡å—ï¼Ÿæ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤ä»»åŠ¡åŠå…¶ç›¸å…³æ•°æ®ï¼Œä¸å¯æ¢å¤ï¼')) {
                appData.tasks = appData.tasks.filter(t => t.id !== taskId);
                
                // åˆ é™¤ç›¸å…³å½•éŸ³
                try {
                    const taskRecordings = await audioStorage.getRecordingsByTask(taskId);
                    for (const recording of taskRecordings) {
                        await audioStorage.deleteRecording(recording.id);
                    }
                } catch (error) {
                    console.error('åˆ é™¤ä»»åŠ¡å½•éŸ³å¤±è´¥:', error);
                }
                
                appData.feedbacks = appData.feedbacks.filter(f => f.taskId !== taskId);
                
                await saveTasks();
                
                renderAllTasks();
                renderTodayTasks();
                renderCalendar();
                renderDataStats();
                renderRecordings();
            }
        }

        // æ•°æ®ç®¡ç†åŠŸèƒ½
        function showDataManagementModal() {
            dataManagementModal.classList.remove('hidden');
            updateDataStats();
        }

        function hideDataManagementModal() {
            dataManagementModal.classList.add('hidden');
        }

        function updateDataStats() {
            const totalTasks = appData.tasks.length;
            const completedTasks = appData.tasks.filter(task => {
                const taskSchedule = getTaskCheckinSchedule(task);
                return task.checkins.length === taskSchedule.length;
            }).length;
            
            // åªç»Ÿè®¡ä»Šå¤©çš„å½•éŸ³æ•°é‡
            const todayRecordings = appData.recordings.length;
            
            const dataSize = calculateDataSize();

            document.getElementById('stat-total-tasks').textContent = totalTasks;
            document.getElementById('stat-completed-tasks').textContent = completedTasks;
            document.getElementById('stat-total-recordings').textContent = todayRecordings;
            document.getElementById('stat-data-size').textContent = dataSize.totalSize;
        }

        function renderDataStats() {
            const totalTasks = appData.tasks.length;
            
            const completedTasks = appData.tasks.filter(task => {
                const taskSchedule = getTaskCheckinSchedule(task);
                return task.checkins.length === taskSchedule.length;
            }).length;
            
            // åªç»Ÿè®¡ä»Šå¤©çš„å½•éŸ³æ•°é‡
            const todayRecordings = appData.recordings.length;
            
            const totalDuration = appData.recordings.reduce((total, recording) => total + recording.duration, 0);
            const totalMinutes = Math.floor(totalDuration / 60000);
            
            const dataSize = calculateDataSize();

            document.getElementById('stats-total-tasks').textContent = totalTasks;
            document.getElementById('stats-completed-tasks').textContent = completedTasks;
            document.getElementById('stats-total-recordings').textContent = todayRecordings;
            document.getElementById('stats-total-duration').textContent = `${totalMinutes}åˆ†é’Ÿ`;
            document.getElementById('stats-data-size').textContent = dataSize.totalSize;
            
            showStorageWarning();
        }

        // è®¡ç®—æ•°æ®å¤§å°
        function calculateDataSize() {
            const tasksSize = JSON.stringify(appData.tasks).length;
            const recordingsSize = JSON.stringify(appData.recordings).length;
            const feedbacksSize = JSON.stringify(appData.feedbacks).length;
            const totalSizeBytes = tasksSize + recordingsSize + feedbacksSize;
            const totalSizeMB = (totalSizeBytes / (1024 * 1024)).toFixed(2);
            
            return {
                tasksSize: (tasksSize / 1024).toFixed(2) + ' KB',
                recordingsSize: (recordingsSize / 1024).toFixed(2) + ' KB',
                feedbacksSize: (feedbacksSize / 1024).toFixed(2) + ' KB',
                totalSize: totalSizeMB + ' MB',
                totalSizeBytes: totalSizeBytes
            };
        }

        // æ˜¾ç¤ºå­˜å‚¨è­¦å‘Š
        function showStorageWarning() {
            const dataSize = calculateDataSize();
            const totalSizeMB = parseFloat(dataSize.totalSize);
            
            storageSizeDisplayEl.textContent = dataSize.totalSize;
            storageWarningEl.classList.remove('hidden', 'low', 'medium', 'high');
            
            if (totalSizeMB > 50) { // å¢åŠ åˆ°50MBè­¦å‘Š
                storageWarningEl.classList.add('high');
                storageSizeDisplayEl.classList.add('high');
                storageMessageEl.textContent = 'âš ï¸ æ•°æ®å­˜å‚¨é‡è¾ƒå¤§ï¼ˆè¶…è¿‡50MBï¼‰ï¼Œå»ºè®®åŠæ—¶æ¸…ç†æˆ–å¯¼å‡ºå¤‡ä»½æ•°æ®';
                storageWarningEl.classList.remove('hidden');
            } else if (totalSizeMB > 20) {
                storageWarningEl.classList.add('medium');
                storageSizeDisplayEl.classList.add('medium');
                storageMessageEl.textContent = 'æ•°æ®å­˜å‚¨é‡é€‚ä¸­ï¼Œå»ºè®®å®šæœŸå¯¼å‡ºå¤‡ä»½';
                storageWarningEl.classList.remove('hidden');
            } else {
                storageWarningEl.classList.add('low');
                storageSizeDisplayEl.classList.add('low');
                storageMessageEl.textContent = 'æ•°æ®å­˜å‚¨é‡æ­£å¸¸';
                storageWarningEl.classList.remove('hidden');
            }
        }

        function exportData() {
            const exportData = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                tasks: appData.tasks,
                recordings: appData.recordings,
                feedbacks: appData.feedbacks
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `å¤ä¹ æ‰“å¡è®¡åˆ’å¤‡ä»½_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            alert('æ•°æ®å¯¼å‡ºæˆåŠŸï¼');
        }

        function handleImportFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.json')) {
                alert('è¯·é€‰æ‹©JSONæ ¼å¼çš„æ–‡ä»¶ï¼');
                resetImportFile();
                return;
            }
            
            importFileName.textContent = file.name;
            importFileSize.textContent = formatFileSize(file.size);
            importFileInfo.classList.remove('hidden');
            importDataBtn.disabled = false;
        }

        async function importData() {
            const file = importDataFile.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!importedData.tasks || !importedData.recordings) {
                        throw new Error('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘å¿…è¦çš„æ•°æ®å­—æ®µ');
                    }
                    
                    if (!confirm('å¯¼å…¥æ•°æ®å°†è¦†ç›–å½“å‰æ‰€æœ‰æ•°æ®ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ')) {
                        return;
                    }
                    
                    appData.tasks = importedData.tasks;
                    appData.recordings = importedData.recordings;
                    appData.feedbacks = importedData.feedbacks || [];
                    
                    // ä¿å­˜åˆ°IndexedDB
                    await audioStorage.saveTasks(appData.tasks);
                    for (const recording of appData.recordings) {
                        await audioStorage.saveRecording(recording);
                    }
                    
                    restoreRecordingUrls();
                    
                    localStorage.setItem('checkinFeedbacks', JSON.stringify(appData.feedbacks));
                    
                    appData.currentTask = null;
                    appData.currentRecording = null;
                    appData.selectedCalendarDate = null;
                    appData.editingTask = null;
                    appData.currentCheckpointIndex = null;
                    
                    renderTodayTasks();
                    renderAllTasks();
                    renderCalendar();
                    renderRecordings();
                    renderDataStats();
                    
                    hideDataManagementModal();
                    resetImportFile();
                    
                    alert('æ•°æ®å¯¼å…¥æˆåŠŸï¼');
                    
                } catch (error) {
                    console.error('æ•°æ®å¯¼å…¥å¤±è´¥:', error);
                    alert('æ•°æ®å¯¼å…¥å¤±è´¥ï¼š' + error.message);
                }
            };
            reader.onerror = function() {
                alert('æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•');
            };
            reader.readAsText(file);
        }

        function resetImportFile() {
            importDataFile.value = '';
            importFileInfo.classList.add('hidden');
            importDataBtn.disabled = true;
        }

        async function clearAllData() {
            if (!confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼')) {
                return;
            }
            
            if (!confirm('å†æ¬¡ç¡®è®¤ï¼šè¿™å°†åˆ é™¤æ‰€æœ‰ä»»åŠ¡ã€å½•éŸ³è®°å½•å’Œç‚¹è¯„ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ')) {
                return;
            }
            
            appData.tasks = [];
            appData.recordings = [];
            appData.feedbacks = [];
            
            // æ¸…ç©ºIndexedDB
            try {
                const db = await audioStorage.open();
                const transaction = db.transaction(['tasks', 'recordings'], 'readwrite');
                transaction.objectStore('tasks').clear();
                transaction.objectStore('recordings').clear();
            } catch (error) {
                console.error('æ¸…ç©ºIndexedDBå¤±è´¥:', error);
            }
            
            localStorage.removeItem('checkinFeedbacks');
            localStorage.removeItem('recordingState');
            localStorage.removeItem('lastCleanupDate');
            
            appData.currentTask = null;
            appData.currentRecording = null;
            appData.selectedCalendarDate = null;
            appData.editingTask = null;
            appData.currentCheckpointIndex = null;
            
            renderTodayTasks();
            renderAllTasks();
            renderCalendar();
            renderRecordings();
            renderDataStats();
            
            alert('æ‰€æœ‰æ•°æ®å·²æ¸…é™¤ï¼');
        }

        // æ¸²æŸ“å½•éŸ³è®°å½•
        async function renderRecordings() {
            recordingsListEl.innerHTML = '';
            
            try {
                // è·å–ä»Šæ—¥å½•éŸ³
                const todayRecordings = await audioStorage.getTodayRecordings();
                
                if (todayRecordings.length === 0) {
                    recordingsListEl.innerHTML = `
                        <div class="empty-state">
                            <i>ğŸ¤</i>
                            <p>ä»Šå¤©è¿˜æ²¡æœ‰ä»»ä½•æ‰“å¡è®°å½•</p>
                        </div>
                    `;
                    return;
                }
                
                // æŒ‰æ—¶é—´å€’åºæ’åˆ—
                todayRecordings.sort((a, b) => new Date(b.date) - new Date(a.date));
                
                for (const recording of todayRecordings) {
                    const recordingEl = document.createElement('div');
                    recordingEl.className = 'recording-item';
                    
                    const task = appData.tasks.find(t => t.id === recording.taskId);
                    const taskName = task ? `${task.subject} - ${task.name}` : 'æœªçŸ¥ä»»åŠ¡';
                    const taskSchedule = getTaskCheckinSchedule(task);
                    const checkpointDay = taskSchedule[recording.checkpointIndex];
                    
                    let dayDisplay;
                    if (task.scheduleType === 'daily') {
                        dayDisplay = `ç¬¬${checkpointDay + 1}å¤©`;
                    } else if (task.scheduleType === 'custom') {
                        const startDate = new Date(task.createDate);
                        const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                        dayDisplay = checkinDate.toLocaleDateString();
                    } else {
                        dayDisplay = `ç¬¬${checkpointDay}å¤©`;
                    }
                    
                    const date = new Date(recording.date).toLocaleString();
                    const fileSize = recording.audioData ? 
                        formatFileSize(new Blob([recording.audioData]).size) : 'æœªçŸ¥å¤§å°';
                    
                    recordingEl.innerHTML = `
                        <div class="recording-info">
                            <div class="recording-name">${taskName} - ${dayDisplay}</div>
                            <div class="recording-duration">
                                ${date} | æ—¶é•¿: ${formatTime(recording.duration)} | å¤§å°: ${fileSize}
                            </div>
                        </div>
                        <div class="task-actions">
                            <button class="btn btn-secondary" onclick="playSavedRecording(${recording.id})" id="play-saved-${recording.id}">æ’­æ”¾</button>
                        </div>
                    `;
                    
                    recordingsListEl.appendChild(recordingEl);
                }
                
            } catch (error) {
                console.error('æ¸²æŸ“å½•éŸ³è®°å½•å¤±è´¥:', error);
                recordingsListEl.innerHTML = `
                    <div class="empty-state">
                        <i>âŒ</i>
                        <p>åŠ è½½å½•éŸ³è®°å½•å¤±è´¥</p>
                    </div>
                `;
            }
        }

        // æ¸²æŸ“æ—¥å†
        function renderCalendar() {
            calendarEl.innerHTML = '';
            
            const weekdays = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
            weekdays.forEach(day => {
                const dayEl = document.createElement('div');
                dayEl.className = 'calendar-weekday';
                dayEl.textContent = day;
                calendarEl.appendChild(dayEl);
            });
            
            const year = appData.currentCalendarDate.getFullYear();
            const month = appData.currentCalendarDate.getMonth();
            calendarTitleEl.textContent = `${year}å¹´${month + 1}æœˆ`;
            
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            
            const firstDayIndex = firstDay.getDay();
            const prevMonthLastDay = new Date(year, month, 0).getDate();
            
            for (let i = firstDayIndex - 1; i >= 0; i--) {
                const dayEl = document.createElement('div');
                dayEl.className = 'calendar-day other-month';
                dayEl.innerHTML = `<div class="day-number">${prevMonthLastDay - i}</div>`;
                calendarEl.appendChild(dayEl);
            }
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            for (let day = 1; day <= lastDay.getDate(); day++) {
                const dayEl = document.createElement('div');
                dayEl.className = 'calendar-day';
                
                const date = new Date(year, month, day);
                if (date.getTime() === today.getTime()) {
                    dayEl.classList.add('today');
                }
                
                if (appData.selectedCalendarDate && 
                    appData.selectedCalendarDate.getDate() === day &&
                    appData.selectedCalendarDate.getMonth() === month &&
                    appData.selectedCalendarDate.getFullYear() === year) {
                    dayEl.classList.add('selected');
                }
                
                // è·å–è¯¥æ—¥æœŸçš„ä»»åŠ¡æ•°é‡
                const tasksOnDate = getTasksOnDate(date);
                const totalTasks = tasksOnDate.overdue + tasksOnDate.today + tasksOnDate.future + tasksOnDate.completed;
                
                let indicators = '';
                if (tasksOnDate.overdue > 0) {
                    indicators += '<div class="task-indicator indicator-overdue"></div>';
                }
                if (tasksOnDate.today > 0) {
                    indicators += '<div class="task-indicator indicator-today"></div>';
                }
                if (tasksOnDate.future > 0) {
                    indicators += '<div class="task-indicator indicator-future"></div>';
                }
                if (tasksOnDate.completed > 0) {
                    indicators += '<div class="task-indicator indicator-completed"></div>';
                }
                
                // æ·»åŠ ä»»åŠ¡æ•°é‡æŒ‡ç¤ºå™¨
                let taskCountIndicator = '';
                if (totalTasks > 0) {
                    taskCountIndicator = `<div class="task-count-indicator">${totalTasks}</div>`;
                }
                
                dayEl.innerHTML = `
                    <div class="day-number">${day}</div>
                    ${indicators}
                    ${taskCountIndicator}
                `;
                
                dayEl.addEventListener('click', () => showDateTasks(date));
                calendarEl.appendChild(dayEl);
            }
            
            const totalCells = 42;
            const filledCells = firstDayIndex + lastDay.getDate();
            const remainingCells = totalCells - filledCells;
            
            for (let day = 1; day <= remainingCells; day++) {
                const dayEl = document.createElement('div');
                dayEl.className = 'calendar-day other-month';
                dayEl.innerHTML = `<div class="day-number">${day}</div>`;
                calendarEl.appendChild(dayEl);
            }
        }

        // æ—¥å†å¯¼èˆª
        function navigateCalendar(direction) {
            const currentDate = appData.currentCalendarDate;
            const newDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + direction, 1);
            appData.currentCalendarDate = newDate;
            renderCalendar();
        }

        // å›åˆ°ä»Šå¤©
        function goToToday() {
            appData.currentCalendarDate = new Date();
            appData.selectedCalendarDate = new Date();
            renderCalendar();
            showDateTasks(new Date());
        }

        // è·å–æŒ‡å®šæ—¥æœŸçš„ä»»åŠ¡
        function getTasksOnDate(date) {
            const result = {
                overdue: 0,
                today: 0,
                future: 0,
                completed: 0
            };
            
            appData.tasks.forEach(task => {
                if (task.status !== 'active') return;
                
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const targetDate = new Date(date);
                targetDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((targetDate - taskDate) / (1000 * 60 * 60 * 24));
                const taskSchedule = getTaskCheckinSchedule(task);
                
                const isCheckpointDay = taskSchedule.includes(daysSinceStart);
                if (isCheckpointDay) {
                    const checkpointIndex = taskSchedule.indexOf(daysSinceStart);
                    const hasCheckedIn = task.checkins.some(checkin => checkin.checkpointIndex === checkpointIndex);
                    
                    if (hasCheckedIn) {
                        result.completed++;
                    } else {
                        if (daysSinceStart < 0) {
                            result.future++;
                        } else if (daysSinceStart === 0) {
                            result.today++;
                        } else {
                            result.overdue++;
                        }
                    }
                }
            });
            
            return result;
        }

        // æ˜¾ç¤ºæŒ‡å®šæ—¥æœŸçš„ä»»åŠ¡
        function showDateTasks(date) {
            appData.selectedCalendarDate = date;
            renderCalendar();
            
            selectedDateTasksEl.innerHTML = '';
            
            const dateStr = date.toLocaleDateString();
            selectedDateTasksEl.innerHTML = `<h3>${dateStr} çš„ä»»åŠ¡</h3>`;
            
            let hasTasks = false;
            
            appData.tasks.forEach(task => {
                if (task.status !== 'active') return;
                
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const targetDate = new Date(date);
                targetDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((targetDate - taskDate) / (1000 * 60 * 60 * 24));
                const taskSchedule = getTaskCheckinSchedule(task);
                
                const checkpointIndex = taskSchedule.findIndex(day => day === daysSinceStart);
                
                if (checkpointIndex !== -1) {
                    hasTasks = true;
                    const checkpointDay = taskSchedule[checkpointIndex];
                    const isOverdue = daysSinceStart > checkpointDay;
                    const hasCheckedIn = task.checkins.some(checkin => checkin.checkpointIndex === checkpointIndex);
                    
                    const taskEl = document.createElement('div');
                    
                    let taskClass = 'task-item';
                    if (isOverdue) {
                        taskClass += ' overdue';
                    } else if (hasCheckedIn) {
                        taskClass += ' completed';
                    }
                    
                    taskEl.className = taskClass;
                    
                    let dayDisplay;
                    if (task.scheduleType === 'daily') {
                        dayDisplay = `ç¬¬${daysSinceStart + 1}å¤©`;
                    } else if (task.scheduleType === 'custom') {
                        const startDate = new Date(task.createDate);
                        const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                        dayDisplay = checkinDate.toLocaleDateString();
                    } else {
                        dayDisplay = `ç¬¬${checkpointDay}å¤©`;
                    }
                    
                    taskEl.innerHTML = `
                        <div class="task-header">
                            <div class="task-name">${task.subject} - ${task.name}</div>
                            <div class="task-status ${hasCheckedIn ? 'status-completed' : (isOverdue ? 'status-overdue' : 'status-today')}">
                                ${isOverdue ? `é€¾æœŸ${daysSinceStart - checkpointDay}å¤©` : dayDisplay} ${hasCheckedIn ? 'âœ“' : ''}
                            </div>
                        </div>
                        <p>${task.description || ''}</p>
                        <div class="task-actions">
                            ${!hasCheckedIn ? 
                                `<button class="btn btn-primary" onclick="startCheckin(${task.id}, ${checkpointIndex})">
                                    æ‰“å¡
                                </button>` : ''}
                        </div>
                    `;
                    
                    selectedDateTasksEl.appendChild(taskEl);
                }
            });
            
            if (!hasTasks) {
                selectedDateTasksEl.innerHTML += `
                    <div class="empty-state">
                        <i>ğŸ“…</i>
                        <p>è¿™ä¸€å¤©æ²¡æœ‰æ‰“å¡ä»»åŠ¡</p>
                    </div>
                `;
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        window.onload = initApp;
    </script>
</body>
</html>