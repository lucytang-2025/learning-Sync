<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤ä¹ æ‰“å¡è®¡åˆ’</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .app-description {
            font-size: 14px;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            background: #f1f5f9;
            border-bottom: 1px solid #e2e8f0;
        }

        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .tab.active {
            background: white;
            color: #4facfe;
            border-bottom: 3px solid #4facfe;
        }

        .tab-content {
            display: none;
            padding: 20px;
            min-height: 500px;
        }

        .tab-content.active {
            display: block;
        }

        .task-list {
            margin-bottom: 20px;
        }

        .task-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border-left: 4px solid #4facfe;
            transition: transform 0.2s;
        }

        .task-item:hover {
            transform: translateY(-2px);
        }

        .task-item.overdue {
            border-left-color: #ff6b6b;
            background: #fff5f5;
        }

        .task-item.completed {
            border-left-color: #1dd1a1;
            background: #f0fff4;
        }

        .task-item.pending-review {
            border-left-color: #feca57;
            background: #fff9e6;
        }

        .task-item.needs-redo {
            border-left-color: #ff9f43;
            background: #fff9e6;
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .task-name {
            font-weight: 600;
            font-size: 18px;
        }

        .task-status {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            color: white;
        }

        .status-overdue {
            background: #ff6b6b;
        }

        .status-today {
            background: #4ecdc4;
        }

        .status-future {
            background: #45aaf2;
        }

        .status-completed {
            background: #1dd1a1;
        }

        .status-pending {
            background: #feca57;
        }

        .status-pending-review {
            background: #ff9ff3;
        }

        .status-rejected {
            background: #ff9f43;
        }

        .task-progress {
            margin: 10px 0;
        }

        .progress-bar {
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            border-radius: 4px;
            transition: width 0.5s;
        }

        .progress-text {
            font-size: 12px;
            color: #64748b;
            margin-top: 5px;
        }

        .task-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #4facfe;
            color: white;
        }

        .btn-primary:hover {
            background: #3a9bf7;
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #475569;
        }

        .btn-secondary:hover {
            background: #cbd5e1;
        }

        .btn-danger {
            background: #ff6b6b;
            color: white;
        }

        .btn-danger:hover {
            background: #ff5252;
        }

        .btn-warning {
            background: #ff9f43;
            color: white;
        }

        .btn-warning:hover {
            background: #ff8c2a;
        }

        .btn-disabled {
            background: #cbd5e1;
            color: #94a3b8;
            cursor: not-allowed;
        }

        .btn-disabled:hover {
            background: #cbd5e1;
        }

        .recorder-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }

        .recorder-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .recorder-display {
            text-align: center;
            margin: 20px 0;
        }

        .timer {
            font-size: 48px;
            font-weight: 700;
            color: #4facfe;
            margin: 20px 0;
        }

        .recorder-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .recorder-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .record-btn {
            background: #ff6b6b;
            color: white;
        }

        .record-btn.recording {
            animation: pulse 1.5s infinite;
        }

        .pause-btn {
            background: #feca57;
            color: white;
        }

        .stop-btn {
            background: #48dbfb;
            color: white;
        }

        .play-btn {
            background: #1dd1a1;
            color: white;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .waveform {
            height: 100px;
            background: #f8fafc;
            border-radius: 10px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 4px;
            background: #4facfe;
            border-radius: 2px 2px 0 0;
        }

        .recordings-list {
            margin-top: 20px;
        }

        .recording-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .recording-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .recording-name {
            font-weight: 600;
        }

        .recording-duration {
            font-size: 12px;
            color: #64748b;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px 0;
        }

        .calendar-nav {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .calendar-nav-btn {
            background: #4facfe;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .calendar-nav-btn:hover {
            background: #3a9bf7;
        }

        .calendar-title {
            font-size: 18px;
            font-weight: 600;
            color: #475569;
        }

        .calendar {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .calendar-weekday {
            text-align: center;
            font-weight: 600;
            padding: 10px 0;
            color: #475569;
            background: #f8fafc;
            border-radius: 5px;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            padding: 5px;
            position: relative;
            border: 2px solid transparent;
        }

        .calendar-day:hover {
            background: #f1f5f9;
        }

        .calendar-day.active {
            background: #4facfe;
            color: white;
        }

        .calendar-day.selected {
            background: #ff6b6b;
            color: white;
            border-color: #ff6b6b;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .calendar-day.today {
            border-color: #ff6b6b;
        }

        .calendar-day.other-month {
            color: #cbd5e1;
        }

        .day-number {
            font-size: 16px;
            font-weight: 600;
        }

        .task-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-top: 2px;
        }

        .indicator-overdue {
            background: #ff6b6b;
        }

        .indicator-today {
            background: #4ecdc4;
        }

        .indicator-future {
            background: #45aaf2;
        }

        .indicator-completed {
            background: #1dd1a1;
        }

        .indicator-pending-review {
            background: #ff9ff3;
        }

        .indicator-rejected {
            background: #ff9f43;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #475569;
        }

        input, textarea, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            font-size: 16px;
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #64748b;
        }

        .empty-state i {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .hidden {
            display: none;
        }

        .checkin-history {
            margin-top: 10px;
        }

        .history-item {
            padding: 8px 12px;
            border-left: 3px solid #4facfe;
            background: #f8fafc;
            margin-bottom: 8px;
            border-radius: 0 8px 8px 0;
            font-size: 12px;
        }

        .history-date {
            font-weight: 600;
            margin-bottom: 3px;
        }

        .history-status {
            font-size: 11px;
            color: #64748b;
        }

        .status-completed {
            color: #1dd1a1;
        }

        .status-pending {
            color: #feca57;
        }

        .status-missed {
            color: #ff6b6b;
        }

        .status-pending-review {
            color: #ff9ff3;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #64748b;
            font-size: 14px;
            border-top: 1px solid #e2e8f0;
        }

        .task-form-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .audio-player {
            width: 100%;
            margin: 10px 0;
        }

        .recording-status {
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: 600;
        }

        .status-recording {
            background: #fff5f5;
            color: #ff6b6b;
        }

        .status-playing {
            background: #f0fff4;
            color: #1dd1a1;
        }

        .last-recording-time {
            font-size: 12px;
            color: #64748b;
            margin-top: 5px;
        }

        .edit-task-form {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .compact-checkin-info {
            font-size: 12px;
            color: #64748b;
            margin-top: 5px;
        }

        .compact-checkin-item {
            display: inline-block;
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 5px;
            margin-bottom: 3px;
        }
        
        .upload-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .upload-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .upload-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-input-btn {
            display: block;
            padding: 12px 20px;
            background: #4facfe;
            color: white;
            border-radius: 6px;
            text-align: center;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .file-input-btn:hover {
            background: #3a9bf7;
        }
        
        .file-info {
            margin-top: 10px;
            padding: 10px;
            background: #f8fafc;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .recorder-mode-selector {
            display: flex;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #cbd5e1;
        }
        
        .recorder-mode {
            flex: 1;
            padding: 12px;
            text-align: center;
            background: #f8fafc;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .recorder-mode.active {
            background: #4facfe;
            color: white;
        }
        
        .uploaded-audio-player {
            width: 100%;
            margin: 15px 0;
        }

        .data-management-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .data-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .data-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border-left: 4px solid #4facfe;
        }

        .stat-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .stat-number {
            font-size: 24px;
            font-weight: 700;
            color: #4facfe;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: #64748b;
        }

        .instructions-list {
            padding-left: 20px;
            margin-top: 10px;
        }

        .instructions-list li {
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .modal-header h3 {
            margin: 0;
            color: #475569;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #64748b;
        }

        .close-btn:hover {
            color: #475569;
        }

        .modal-body {
            padding: 20px;
        }

        .data-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .data-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .data-section h4 {
            margin-bottom: 10px;
            color: #475569;
        }

        .data-section p {
            margin-bottom: 15px;
            color: #64748b;
            font-size: 14px;
        }

        .data-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f1f5f9;
        }

        .stat-label {
            color: #64748b;
            font-size: 14px;
        }

        .stat-value {
            font-weight: 600;
            color: #475569;
        }

        .hidden {
            display: none !important;
        }

        .subject-chinese {
            color: #4facfe;
        }

        .subject-math {
            color: #764ba2;
        }

        .subject-english {
            color: #ff6b6b;
        }

        .subject-science {
            color: #1dd1a1;
        }

        .subject-other {
            color: #feca57;
        }

        .task-details-modal {
            max-width: 600px;
        }

        .checkin-progress {
            margin-top: 15px;
        }

        .checkin-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f1f5f9;
        }

        .checkin-day {
            font-weight: 600;
            width: 120px;
        }

        .checkin-status {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-icon {
            font-size: 16px;
        }

        .status-completed-icon {
            color: #1dd1a1;
        }

        .status-pending-icon {
            color: #feca57;
        }

        .status-missed-icon {
            color: #ff6b6b;
        }

        .today-tasks-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
        }

        .tasks-count {
            background: #4facfe;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .rejection-reason {
            font-size: 12px;
            color: #ff6b6b;
            margin-top: 5px;
            padding: 5px;
            background: #fff5f5;
            border-radius: 4px;
            border-left: 3px solid #ff6b6b;
        }

        .redo-notice {
            background: #fff9e6;
            border: 1px solid #ff9f43;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 14px;
            width: 100%;
        }

        .redo-notice h4 {
            color: #ff9f43;
            margin-bottom: 5px;
        }

        .storage-warning {
            background: #fff5f5;
            border: 2px solid #ff6b6b;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .storage-warning.high {
            background: #fff5f5;
            border-color: #ff6b6b;
            animation: pulse-warning 2s infinite;
        }

        .storage-warning.medium {
            background: #fff9e6;
            border-color: #feca57;
        }

        .storage-warning.low {
            background: #f0fff4;
            border-color: #1dd1a1;
        }

        @keyframes pulse-warning {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .storage-size {
            font-weight: 700;
            font-size: 18px;
            margin: 5px 0;
        }

        .storage-size.high {
            color: #ff6b6b;
        }

        .storage-size.medium {
            color: #feca57;
        }

        .storage-size.low {
            color: #1dd1a1;
        }

        .rejection-history {
            margin-top: 10px;
            padding: 10px;
            background: #f8fafc;
            border-radius: 6px;
        }

        .rejection-history-item {
            padding: 8px;
            margin-bottom: 5px;
            background: white;
            border-radius: 4px;
            border-left: 3px solid #ff9f43;
        }

        .rejection-date {
            font-size: 11px;
            color: #64748b;
        }

        .rejection-reason-text {
            font-size: 12px;
            color: #475569;
        }

        /* æ–°å¢æ ·å¼ - è‡ªå®šä¹‰æ—¥æœŸæ‰“å¡ */
        .schedule-type-selector {
            display: flex;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #cbd5e1;
        }
        
        .schedule-type {
            flex: 1;
            padding: 12px;
            text-align: center;
            background: #f8fafc;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .schedule-type.active {
            background: #4facfe;
            color: white;
        }
        
        .custom-schedule-container {
            margin-top: 15px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .custom-date-input {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .custom-date-input label {
            width: 120px;
            margin-bottom: 0;
            margin-right: 10px;
        }
        
        .custom-date-input input {
            flex: 1;
        }
        
        .add-date-btn {
            background: #4facfe;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
        }
        
        .custom-dates-list {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .custom-date-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            margin-bottom: 8px;
            border-left: 3px solid #4facfe;
        }
        
        .remove-date-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        /* æ–°å¢æ ·å¼ - ä»»åŠ¡æè¿°æ˜¾ç¤º */
        .task-description-display {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #4facfe;
            white-space: pre-line; /* ä¿ç•™æ¢è¡Œç¬¦ */
        }

        .task-description-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #475569;
        }

        .task-description-content {
            color: #64748b;
            line-height: 1.5;
            white-space: pre-line; /* ä¿ç•™æ¢è¡Œç¬¦ */
        }

        /* æ—¥å†ä»»åŠ¡æ•°é‡æŒ‡ç¤ºå™¨ */
        .task-count-indicator {
            position: absolute;
            top: 2px;
            right: 2px;
            background: #ff6b6b;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .calendar-day {
            position: relative;
        }

        /* æ–°å¢æ ·å¼ - æ¯æ—¥æ‰“å¡è®¾ç½® */
        .daily-schedule-container {
            margin-top: 15px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .date-range-input {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }

        .date-range-input input {
            flex: 1;
        }

        .weekday-selector {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin: 10px 0;
        }

        .weekday-option {
            padding: 8px;
            text-align: center;
            background: white;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .weekday-option.selected {
            background: #4facfe;
            color: white;
            border-color: #4facfe;
        }

        .daily-schedule-preview {
            margin-top: 15px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border-left: 3px solid #1dd1a1;
        }

        .preview-dates {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .preview-date-item {
            padding: 5px 8px;
            margin-bottom: 3px;
            background: #f8fafc;
            border-radius: 4px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>å¤ä¹ æ‰“å¡è®¡åˆ’</h1>
            <p class="app-description">æ—¥ç§¯æœˆç´¯ã€æŒä¹‹ä»¥æ’ï¼Œå†²åˆº100åˆ†</p>
        </header>

        <div class="tabs">
            <div class="tab active" data-tab="today">ä»Šæ—¥ä»»åŠ¡</div>
            <div class="tab" data-tab="tasks">ä»»åŠ¡ç®¡ç†</div>
            <div class="tab" data-tab="calendar">æ—¥å†è§†å›¾</div>
            <div class="tab" data-tab="recorder">å½•éŸ³æ‰“å¡</div>
            <div class="tab" data-tab="data">æ•°æ®ç®¡ç†</div>
        </div>

        <div class="tab-content active" id="today-tab">
            <div class="today-tasks-header">
                <h2>ä»Šæ—¥ä»»åŠ¡</h2>
                <div class="tasks-count" id="today-tasks-count">0/0 ä¸ªä»»åŠ¡</div>
            </div>
            <div class="task-list" id="today-tasks">
                <!-- ä»Šæ—¥ä»»åŠ¡å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <div class="tab-content" id="tasks-tab">
            <h2>ä»»åŠ¡ç®¡ç†</h2>
            
            <div id="task-form" class="task-form-container hidden">
                <h3>æ–°å»ºä»»åŠ¡</h3>
                <div class="form-group">
                    <label for="task-subject">ç§‘ç›®</label>
                    <select id="task-subject">
                        <option value="è¯­æ–‡">è¯­æ–‡</option>
                        <option value="æ•°å­¦">æ•°å­¦</option>
                        <option value="è‹±è¯­">è‹±è¯­</option>
                        <option value="ç§‘å­¦">ç§‘å­¦</option>
                        <option value="å…¶ä»–">å…¶ä»–</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="task-name">ä»»åŠ¡åç§°</label>
                    <input type="text" id="task-name" placeholder="è¾“å…¥ä»»åŠ¡åç§°">
                </div>
                <div class="form-group">
                    <label for="task-desc">ä»»åŠ¡æè¿°</label>
                    <textarea id="task-desc" placeholder="è¾“å…¥ä»»åŠ¡æè¿°ï¼ˆå¯é€‰ï¼‰"></textarea>
                </div>
                <div class="form-group">
                    <label for="task-date">å¼€å§‹æ—¥æœŸ</label>
                    <input type="date" id="task-date">
                </div>
                
                <!-- æ‰“å¡è®¡åˆ’ç±»å‹é€‰æ‹© -->
                <div class="form-group">
                    <label>æ‰“å¡è®¡åˆ’ç±»å‹</label>
                    <div class="schedule-type-selector">
                        <div class="schedule-type active" data-type="default">é»˜è®¤è®¡åˆ’</div>
                        <div class="schedule-type" data-type="daily">æ¯æ—¥æ‰“å¡</div>
                        <div class="schedule-type" data-type="custom">è‡ªå®šä¹‰æ—¥æœŸ</div>
                    </div>
                </div>
                
                <!-- é»˜è®¤è®¡åˆ’è¯´æ˜ -->
                <div id="default-schedule-info" class="custom-schedule-container">
                    <p><strong>é»˜è®¤è®¡åˆ’:</strong> æŒ‰ç…§è‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿è®¾ç½®æ‰“å¡ç‚¹ï¼šç¬¬1, 2, 3, 5, 8, 15, 30, 90, 180å¤©</p>
                </div>
                
                <!-- æ¯æ—¥æ‰“å¡è®¾ç½® -->
                <div id="daily-schedule-container" class="daily-schedule-container hidden">
                    <p><strong>æ¯æ—¥æ‰“å¡è®¡åˆ’:</strong> è®¾ç½®ä¸€ä¸ªæ—¶é—´æ®µå†…çš„æ¯æ—¥æ‰“å¡</p>
                    
                    <div class="date-range-input">
                        <div style="flex: 1;">
                            <label for="daily-start-date">å¼€å§‹æ—¥æœŸ</label>
                            <input type="date" id="daily-start-date">
                        </div>
                        <div style="flex: 1;">
                            <label for="daily-end-date">ç»“æŸæ—¥æœŸ</label>
                            <input type="date" id="daily-end-date">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>é€‰æ‹©æ˜ŸæœŸå‡ æ‰“å¡</label>
                        <div class="weekday-selector">
                            <div class="weekday-option selected" data-day="0">æ—¥</div>
                            <div class="weekday-option selected" data-day="1">ä¸€</div>
                            <div class="weekday-option selected" data-day="2">äºŒ</div>
                            <div class="weekday-option selected" data-day="3">ä¸‰</div>
                            <div class="weekday-option selected" data-day="4">å››</div>
                            <div class="weekday-option selected" data-day="5">äº”</div>
                            <div class="weekday-option selected" data-day="6">å…­</div>
                        </div>
                    </div>
                    
                    <div class="daily-schedule-preview">
                        <strong>æ‰“å¡æ—¥æœŸé¢„è§ˆ:</strong>
                        <div class="preview-dates" id="daily-preview-dates">
                            <!-- é¢„è§ˆæ—¥æœŸå°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                        </div>
                    </div>
                </div>
                
                <!-- è‡ªå®šä¹‰æ—¥æœŸè®¾ç½® -->
                <div id="custom-schedule-container" class="custom-schedule-container hidden">
                    <p><strong>è‡ªå®šä¹‰æ‰“å¡æ—¥æœŸ:</strong> è¯·æ·»åŠ å…·ä½“çš„æ‰“å¡æ—¥æœŸ</p>
                    
                    <div class="custom-date-input">
                        <label for="custom-date">æ‰“å¡æ—¥æœŸ</label>
                        <input type="date" id="custom-date">
                    </div>
                    
                    <button class="add-date-btn" id="add-custom-date">æ·»åŠ æ—¥æœŸ</button>
                    
                    <div class="custom-dates-list" id="custom-dates-list">
                        <!-- è‡ªå®šä¹‰æ—¥æœŸåˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
                
                <div class="task-actions">
                    <button class="btn btn-primary" id="save-task">ä¿å­˜ä»»åŠ¡</button>
                    <button class="btn btn-secondary" id="cancel-task">å–æ¶ˆ</button>
                </div>
            </div>

            <div id="edit-task-form" class="edit-task-form hidden">
                <h3>ç¼–è¾‘ä»»åŠ¡</h3>
                <div class="form-group">
                    <label for="edit-task-subject">ç§‘ç›®</label>
                    <select id="edit-task-subject">
                        <option value="è¯­æ–‡">è¯­æ–‡</option>
                        <option value="æ•°å­¦">æ•°å­¦</option>
                        <option value="è‹±è¯­">è‹±è¯­</option>
                        <option value="ç§‘å­¦">ç§‘å­¦</option>
                        <option value="å…¶ä»–">å…¶ä»–</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="edit-task-name">ä»»åŠ¡åç§°</label>
                    <input type="text" id="edit-task-name" placeholder="è¾“å…¥ä»»åŠ¡åç§°">
                </div>
                <div class="form-group">
                    <label for="edit-task-desc">ä»»åŠ¡æè¿°</label>
                    <textarea id="edit-task-desc" placeholder="è¾“å…¥ä»»åŠ¡æè¿°ï¼ˆå¯é€‰ï¼‰"></textarea>
                </div>
                <div class="task-actions">
                    <button class="btn btn-primary" id="update-task">æ›´æ–°ä»»åŠ¡</button>
                    <button class="btn btn-secondary" id="cancel-edit-task">å–æ¶ˆ</button>
                </div>
            </div>
            
            <button class="btn btn-primary" id="add-task-btn">æ–°å»ºä»»åŠ¡</button>
            
            <div class="task-list" id="all-tasks">
                <!-- æ‰€æœ‰ä»»åŠ¡å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <div class="tab-content" id="calendar-tab">
            <h2>æ—¥å†è§†å›¾</h2>
            <div class="calendar-header">
                <div class="calendar-nav">
                    <button class="calendar-nav-btn" id="prev-month">â†</button>
                    <button class="calendar-nav-btn" id="next-month">â†’</button>
                </div>
                <div class="calendar-title" id="calendar-title"></div>
                <button class="btn btn-secondary" id="today-btn">ä»Šå¤©</button>
            </div>
            <div class="calendar" id="calendar">
                <!-- æ—¥å†å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
            <div class="checkin-history" id="selected-date-tasks">
                <!-- é€‰ä¸­æ—¥æœŸçš„ä»»åŠ¡å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <div class="tab-content" id="recorder-tab">
            <h2>å½•éŸ³æ‰“å¡</h2>
            
            <div class="recorder-mode-selector">
                <div class="recorder-mode active" data-mode="record">å®æ—¶å½•éŸ³</div>
                <div class="recorder-mode" data-mode="upload">ä¸Šä¼ å½•éŸ³</div>
            </div>
            
            <div class="recorder-container" id="record-container">
                <div class="recorder-header">
                    <h3 id="recorder-task-name">é€‰æ‹©ä»»åŠ¡è¿›è¡Œæ‰“å¡</h3>
                    <p id="recorder-checkpoint">è¯·å…ˆä»ä»Šæ—¥ä»»åŠ¡ä¸­é€‰æ‹©ä¸€ä¸ªä»»åŠ¡</p>
                </div>
                
                <!-- æ–°å¢ï¼šä»»åŠ¡æè¿°æ˜¾ç¤ºåŒºåŸŸ -->
                <div id="recorder-task-description" class="task-description-display hidden">
                    <div class="task-description-title">ä»»åŠ¡æè¿°</div>
                    <div class="task-description-content" id="recorder-task-desc-content"></div>
                </div>
                
                <div class="recording-status hidden" id="recording-status"></div>
                
                <div class="recorder-display">
                    <div class="timer" id="timer">00:00:00</div>
                    <div class="waveform" id="waveform">
                        <!-- æ³¢å½¢å›¾å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
                
                <div class="recorder-controls">
                    <button class="recorder-btn record-btn" id="record-btn" title="å¼€å§‹å½•éŸ³">
                        â—
                    </button>
                    <button class="recorder-btn pause-btn hidden" id="pause-btn" title="æš‚åœ">
                        âšâš
                    </button>
                    <button class="recorder-btn stop-btn hidden" id="stop-btn" title="åœæ­¢">
                        â– 
                    </button>
                    <button class="recorder-btn play-btn hidden" id="play-btn" title="æ’­æ”¾">
                        â–¶
                    </button>
                </div>

                <audio id="audio-player" class="audio-player hidden" controls></audio>
                
                <div class="task-actions">
                    <button class="btn btn-primary" id="submit-recording" disabled>æäº¤æ‰“å¡</button>
                    <button class="btn btn-secondary" id="reset-recorder">é‡ç½®</button>
                </div>
            </div>
            
            <div class="upload-container hidden" id="upload-container">
                <div class="upload-header">
                    <h3 id="upload-task-name">é€‰æ‹©ä»»åŠ¡è¿›è¡Œæ‰“å¡</h3>
                    <p id="upload-checkpoint">è¯·å…ˆä»ä»Šæ—¥ä»»åŠ¡ä¸­é€‰æ‹©ä¸€ä¸ªä»»åŠ¡</p>
                </div>
                
                <!-- æ–°å¢ï¼šä»»åŠ¡æè¿°æ˜¾ç¤ºåŒºåŸŸ -->
                <div id="upload-task-description" class="task-description-display hidden">
                    <div class="task-description-title">ä»»åŠ¡æè¿°</div>
                    <div class="task-description-content" id="upload-task-desc-content"></div>
                </div>
                
                <div class="upload-controls">
                    <div class="file-input-wrapper">
                        <div class="file-input-btn">é€‰æ‹©å½•éŸ³æ–‡ä»¶</div>
                        <input type="file" id="audio-file" accept="audio/*">
                    </div>
                    
                    <div class="file-info hidden" id="file-info">
                        <div>æ–‡ä»¶å: <span id="file-name"></span></div>
                        <div>æ–‡ä»¶å¤§å°: <span id="file-size"></span></div>
                        <div>æ—¶é•¿: <span id="file-duration">è®¡ç®—ä¸­...</span></div>
                    </div>
                    
                    <audio id="uploaded-audio-player" class="uploaded-audio-player hidden" controls></audio>
                </div>
                
                <div class="task-actions">
                    <button class="btn btn-primary" id="submit-upload" disabled>æäº¤æ‰“å¡</button>
                    <button class="btn btn-secondary" id="reset-upload">é‡ç½®</button>
                </div>
            </div>
            
            <div class="recordings-list" id="recordings-list">
                <h3>æ‰“å¡è®°å½•</h3>
                <!-- å½•éŸ³è®°å½•å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <div class="tab-content" id="data-tab">
            <h2>æ•°æ®ç®¡ç†</h2>
            
            <div class="data-management-container">
                <div class="data-card">
                    <h3>æ•°æ®å¤‡ä»½ä¸æ¢å¤</h3>
                    <p>æ‚¨å¯ä»¥å°†æ•°æ®å¯¼å‡ºä¸ºJSONæ–‡ä»¶è¿›è¡Œå¤‡ä»½ï¼Œæˆ–ä»å¤‡ä»½æ–‡ä»¶æ¢å¤æ•°æ®ã€‚</p>
                    
                    <div class="data-actions">
                        <button class="btn btn-primary" id="show-data-modal">ç®¡ç†æ•°æ®</button>
                        <button class="btn btn-secondary" id="clear-data-btn">æ¸…é™¤æ‰€æœ‰æ•°æ®</button>
                    </div>
                </div>
                
                <div class="data-card">
                    <h3>æ•°æ®ç»Ÿè®¡</h3>
                    <div id="storage-warning" class="storage-warning hidden">
                        <h4>âš ï¸ å­˜å‚¨ç©ºé—´è­¦å‘Š</h4>
                        <div class="storage-size" id="storage-size-display">0 MB</div>
                        <p id="storage-message">å½“å‰æ•°æ®å­˜å‚¨é‡è¾ƒå¤§ï¼Œå»ºè®®åŠæ—¶æ¸…ç†æˆ–å¯¼å‡ºå¤‡ä»½</p>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-icon">ğŸ“</div>
                            <div class="stat-number" id="stats-total-tasks">0</div>
                            <div class="stat-label">æ€»ä»»åŠ¡æ•°</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">âœ…</div>
                            <div class="stat-number" id="stats-completed-tasks">0</div>
                            <div class="stat-label">å·²å®Œæˆ</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">ğŸ¤</div>
                            <div class="stat-number" id="stats-total-recordings">0</div>
                            <div class="stat-label">ä»Šæ—¥å½•éŸ³</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">â±ï¸</div>
                            <div class="stat-number" id="stats-total-duration">0</div>
                            <div class="stat-label">æ€»å½•éŸ³æ—¶é•¿</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">ğŸ“Š</div>
                            <div class="stat-number" id="stats-data-size">0 MB</div>
                            <div class="stat-label">æ•°æ®å¤§å°</div>
                        </div>
                    </div>
                </div>
                
                <div class="data-card">
                    <h3>ä½¿ç”¨è¯´æ˜</h3>
                    <ol class="instructions-list">
                        <li>ä½¿ç”¨"å¯¼å‡ºæ•°æ®"åŠŸèƒ½å°†æ•°æ®ä¿å­˜ä¸ºJSONæ–‡ä»¶ä½œä¸ºå¤‡ä»½</li>
                        <li>åœ¨å…¶ä»–è®¾å¤‡ä¸Šä½¿ç”¨"å¯¼å…¥æ•°æ®"åŠŸèƒ½æ¢å¤å¤‡ä»½</li>
                        <li>æ³¨æ„ï¼šå¯¼å…¥æ•°æ®å°†è¦†ç›–å½“å‰è®¾å¤‡ä¸Šçš„æ‰€æœ‰æ•°æ®</li>
                        <li>æ¯ä¸ªä»»åŠ¡åªä¿ç•™æœ€æ–°ä¸€æ¬¡æ‰“å¡å½•éŸ³</li>
                        <li>åˆ é™¤çš„ä»»åŠ¡ä¼šæ°¸ä¹…åˆ é™¤ï¼Œä¸å ç”¨å­˜å‚¨ç©ºé—´</li>
                        <li>å½•éŸ³ä¼šåœ¨ç¬¬äºŒå¤©è‡ªåŠ¨æ¸…é›¶ï¼Œåªä¿ç•™ä»Šæ—¥å½•éŸ³</li>
                    </ol>
                </div>
            </div>
        </div>

        <footer>
            <p>å¤ä¹ æ‰“å¡è®¡åˆ’ &copy; 2023 - ç¬¬180å¤©æ‰“å¡å®Œæˆåä»»åŠ¡å®Œæˆ</p>
        </footer>
    </div>

    <!-- æ•°æ®ç®¡ç†æ¨¡æ€æ¡† -->
    <div id="data-management-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>æ•°æ®ç®¡ç†</h3>
                <button class="close-btn" id="close-data-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="data-section">
                    <h4>å¯¼å‡ºæ•°æ®</h4>
                    <p>å°†æ‚¨çš„ä»»åŠ¡å’Œæ‰“å¡è®°å½•å¯¼å‡ºä¸ºJSONæ–‡ä»¶ï¼Œç”¨äºå¤‡ä»½ã€‚</p>
                    <button class="btn btn-primary" id="export-data-btn">å¯¼å‡ºæ•°æ®</button>
                </div>
                
                <div class="data-section">
                    <h4>å¯¼å…¥æ•°æ®</h4>
                    <p>ä»JSONæ–‡ä»¶å¯¼å…¥ä»»åŠ¡å’Œæ‰“å¡è®°å½•ï¼Œå°†è¦†ç›–å½“å‰è®¾å¤‡ä¸Šçš„æ‰€æœ‰æ•°æ®ã€‚</p>
                    <div class="file-input-wrapper">
                        <div class="file-input-btn">é€‰æ‹©æ•°æ®æ–‡ä»¶</div>
                        <input type="file" id="import-data-file" accept=".json">
                    </div>
                    <div class="file-info hidden" id="import-file-info">
                        <div>æ–‡ä»¶å: <span id="import-file-name"></span></div>
                        <div>æ–‡ä»¶å¤§å°: <span id="import-file-size"></span></div>
                    </div>
                    <button class="btn btn-danger" id="import-data-btn" disabled>å¯¼å…¥æ•°æ®</button>
                </div>
                
                <div class="data-section">
                    <h4>æ•°æ®ç»Ÿè®¡</h4>
                    <div class="data-stats">
                        <div class="stat-item">
                            <span class="stat-label">ä»»åŠ¡æ€»æ•°:</span>
                            <span class="stat-value" id="stat-total-tasks">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">å·²å®Œæˆä»»åŠ¡:</span>
                            <span class="stat-value" id="stat-completed-tasks">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">ä»Šæ—¥å½•éŸ³:</span>
                            <span class="stat-value" id="stat-total-recordings">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">æ•°æ®å¤§å°:</span>
                            <span class="stat-value" id="stat-data-size">0 MB</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ä»»åŠ¡è¯¦æƒ…æ¨¡æ€æ¡† -->
    <div id="task-details-modal" class="modal hidden">
        <div class="modal-content task-details-modal">
            <div class="modal-header">
                <h3 id="task-details-title">ä»»åŠ¡è¯¦æƒ…</h3>
                <button class="close-btn" id="close-task-details">&times;</button>
            </div>
            <div class="modal-body">
                <div id="task-details-content">
                    <!-- ä»»åŠ¡è¯¦æƒ…å†…å®¹å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // IndexedDB å­˜å‚¨ç®¡ç†å™¨
        class RecordingStorage {
            constructor() {
                this.dbName = 'AudioRecorderDB';
                this.version = 1;
                this.storeName = 'recordings';
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    if (!('indexedDB' in window)) {
                        reject(new Error('æµè§ˆå™¨ä¸æ”¯æŒ IndexedDB'));
                        return;
                    }

                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => {
                        console.error('IndexedDB æ‰“å¼€å¤±è´¥:', request.error);
                        reject(request.error);
                    };
                    
                    request.onsuccess = () => {
                        this.db = request.result;
                        console.log('IndexedDB åˆå§‹åŒ–æˆåŠŸ');
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
                            store.createIndex('taskId', 'taskId', { unique: false });
                            store.createIndex('date', 'date', { unique: false });
                            console.log('IndexedDB å¯¹è±¡å­˜å‚¨åˆ›å»ºæˆåŠŸ');
                        }
                    };
                });
            }

            async saveRecording(recording) {
                if (!this.db) {
                    throw new Error('IndexedDB æœªåˆå§‹åŒ–');
                }

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    
                    const request = store.put(recording);
                    
                    request.onsuccess = () => {
                        console.log('å½•éŸ³ä¿å­˜æˆåŠŸï¼ŒID:', recording.id);
                        resolve();
                    };
                    
                    request.onerror = () => {
                        console.error('ä¿å­˜å¤±è´¥:', request.error);
                        reject(request.error);
                    };
                });
            }

            async getRecording(id) {
                if (!this.db) {
                    throw new Error('IndexedDB æœªåˆå§‹åŒ–');
                }

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    
                    const request = store.get(id);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getAllRecordings() {
                if (!this.db) {
                    throw new Error('IndexedDB æœªåˆå§‹åŒ–');
                }

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async deleteRecording(id) {
                if (!this.db) {
                    throw new Error('IndexedDB æœªåˆå§‹åŒ–');
                }

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    
                    const request = store.delete(id);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async getRecordingsByTask(taskId) {
                if (!this.db) {
                    throw new Error('IndexedDB æœªåˆå§‹åŒ–');
                }

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const index = store.index('taskId');
                    
                    const request = index.getAll(taskId);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }
        }

        // åˆå§‹åŒ–å­˜å‚¨ç®¡ç†å™¨
        const recordingStorage = new RecordingStorage();

        // åº”ç”¨æ•°æ®
        const appData = {
            tasks: [],
            recordings: [], // ç°åœ¨åªå­˜å‚¨å…ƒæ•°æ®
            feedbacks: [],
            currentTask: null,
            currentRecording: null,
            isRecording: false,
            isPaused: false,
            isPlaying: false,
            timerInterval: null,
            recordingTime: 0,
            mediaRecorder: null,
            audioChunks: [],
            audioContext: null,
            analyser: null,
            currentCalendarDate: new Date(),
            selectedCalendarDate: null,
            recordingState: null,
            editingTask: null,
            currentCheckpointIndex: null,
            uploadedAudio: null,
            currentMode: 'record',
            customDates: [],
            dailySchedule: {
                startDate: null,
                endDate: null,
                weekdays: [0, 1, 2, 3, 4, 5, 6] // é»˜è®¤å…¨é€‰
            },
            currentScheduleType: 'default'
        };

        // é»˜è®¤æ‰“å¡æ—¶é—´è¡¨
        const checkinSchedule = [1, 2, 3, 5, 8, 15, 30, 90, 180];

        // DOM å…ƒç´ 
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const todayTasksEl = document.getElementById('today-tasks');
        const todayTasksCountEl = document.getElementById('today-tasks-count');
        const allTasksEl = document.getElementById('all-tasks');
        const taskFormEl = document.getElementById('task-form');
        const editTaskFormEl = document.getElementById('edit-task-form');
        const addTaskBtn = document.getElementById('add-task-btn');
        const saveTaskBtn = document.getElementById('save-task');
        const cancelTaskBtn = document.getElementById('cancel-task');
        const updateTaskBtn = document.getElementById('update-task');
        const cancelEditTaskBtn = document.getElementById('cancel-edit-task');
        const calendarEl = document.getElementById('calendar');
        const calendarTitleEl = document.getElementById('calendar-title');
        const prevMonthBtn = document.getElementById('prev-month');
        const nextMonthBtn = document.getElementById('next-month');
        const todayBtn = document.getElementById('today-btn');
        const selectedDateTasksEl = document.getElementById('selected-date-tasks');
        const recorderTaskNameEl = document.getElementById('recorder-task-name');
        const recorderCheckpointEl = document.getElementById('recorder-checkpoint');
        const recordingStatusEl = document.getElementById('recording-status');
        const timerEl = document.getElementById('timer');
        const waveformEl = document.getElementById('waveform');
        const recordBtn = document.getElementById('record-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const playBtn = document.getElementById('play-btn');
        const audioPlayer = document.getElementById('audio-player');
        const submitRecordingBtn = document.getElementById('submit-recording');
        const resetRecorderBtn = document.getElementById('reset-recorder');
        const recordingsListEl = document.getElementById('recordings-list');
        
        const recordModeBtn = document.querySelector('.recorder-mode[data-mode="record"]');
        const uploadModeBtn = document.querySelector('.recorder-mode[data-mode="upload"]');
        const recordContainer = document.getElementById('record-container');
        const uploadContainer = document.getElementById('upload-container');
        const audioFileInput = document.getElementById('audio-file');
        const fileInfoEl = document.getElementById('file-info');
        const fileNameEl = document.getElementById('file-name');
        const fileSizeEl = document.getElementById('file-size');
        const fileDurationEl = document.getElementById('file-duration');
        const uploadedAudioPlayer = document.getElementById('uploaded-audio-player');
        const submitUploadBtn = document.getElementById('submit-upload');
        const resetUploadBtn = document.getElementById('reset-upload');
        const uploadTaskNameEl = document.getElementById('upload-task-name');
        const uploadCheckpointEl = document.getElementById('upload-checkpoint');

        const dataManagementModal = document.getElementById('data-management-modal');
        const closeDataModalBtn = document.getElementById('close-data-modal');
        const showDataModalBtn = document.getElementById('show-data-modal');
        const exportDataBtn = document.getElementById('export-data-btn');
        const importDataFile = document.getElementById('import-data-file');
        const importDataBtn = document.getElementById('import-data-btn');
        const importFileInfo = document.getElementById('import-file-info');
        const importFileName = document.getElementById('import-file-name');
        const importFileSize = document.getElementById('import-file-size');
        const clearDataBtn = document.getElementById('clear-data-btn');

        const taskDetailsModal = document.getElementById('task-details-modal');
        const taskDetailsTitle = document.getElementById('task-details-title');
        const taskDetailsContent = document.getElementById('task-details-content');
        const closeTaskDetailsBtn = document.getElementById('close-task-details');

        // æ–°å¢ï¼šæ‰“å¡è®¡åˆ’ç±»å‹ç›¸å…³å…ƒç´ 
        const scheduleTypeSelectors = document.querySelectorAll('.schedule-type');
        const defaultScheduleInfo = document.getElementById('default-schedule-info');
        const dailyScheduleContainer = document.getElementById('daily-schedule-container');
        const customScheduleContainer = document.getElementById('custom-schedule-container');
        const dailyStartDateInput = document.getElementById('daily-start-date');
        const dailyEndDateInput = document.getElementById('daily-end-date');
        const weekdayOptions = document.querySelectorAll('.weekday-option');
        const dailyPreviewDates = document.getElementById('daily-preview-dates');
        const customDateInput = document.getElementById('custom-date');
        const addCustomDateBtn = document.getElementById('add-custom-date');
        const customDatesList = document.getElementById('custom-dates-list');
        
        // æ–°å¢ï¼šä»»åŠ¡æè¿°æ˜¾ç¤ºå…ƒç´ 
        const recorderTaskDescriptionEl = document.getElementById('recorder-task-description');
        const recorderTaskDescContentEl = document.getElementById('recorder-task-desc-content');
        const uploadTaskDescriptionEl = document.getElementById('upload-task-description');
        const uploadTaskDescContentEl = document.getElementById('upload-task-desc-content');
        
        // æ–°å¢ï¼šå­˜å‚¨è­¦å‘Šç›¸å…³å…ƒç´ 
        const storageWarningEl = document.getElementById('storage-warning');
        const storageSizeDisplayEl = document.getElementById('storage-size-display');
        const storageMessageEl = document.getElementById('storage-message');

        // åˆå§‹åŒ–åº”ç”¨
        async function initApp() {
            console.log('åˆå§‹åŒ–åº”ç”¨...');
            
            try {
                await recordingStorage.init();
                console.log('âœ… IndexedDB åˆå§‹åŒ–æˆåŠŸï¼Œå¯ä»¥å­˜å‚¨å¤§æ–‡ä»¶å½•éŸ³');
            } catch (error) {
                console.error('âŒ IndexedDB åˆå§‹åŒ–å¤±è´¥:', error);
                alert('å­˜å‚¨åˆå§‹åŒ–å¤±è´¥ï¼Œé•¿å½•éŸ³å¯èƒ½æ— æ³•ä¿å­˜');
            }
            
            // æ·»åŠ æ¯æ—¥æ¸…ç†æ£€æŸ¥
            checkDailyCleanup();
            
            await loadLocalData();
            setupEventListeners();
            setupUploadEventListeners();
            setupDataManagementEventListeners();
            setupTaskDetailsEventListeners();
            setupScheduleTypeEventListeners();
            setupTabletSupport();
            
            renderTodayTasks();
            renderAllTasks();
            renderCalendar();
            renderRecordings();
            renderDataStats();
            
            restoreRecordingState();
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            console.log('åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
        }

        // å¹³æ¿è®¾å¤‡æ”¯æŒ
        function setupTabletSupport() {
            console.log('ğŸ“± åˆå§‹åŒ–å¹³æ¿è®¾å¤‡æ”¯æŒ');
            
            // ä¸ºéŸ³é¢‘å…ƒç´ æ·»åŠ è§¦æ‘¸æ”¯æŒ
            audioPlayer.addEventListener('touchstart', function(e) {
                e.stopPropagation();
            }, { passive: true });
            
            // é˜²æ­¢è§¦æ‘¸æ—¶çš„é»˜è®¤è¡Œä¸º
            document.addEventListener('touchstart', function(e) {
                if (e.target.classList.contains('btn') || 
                    e.target.classList.contains('recorder-btn') ||
                    e.target.classList.contains('tab')) {
                    e.preventDefault();
                }
            }, { passive: false });
        }

        // è®¾ç½®æ‰“å¡è®¡åˆ’ç±»å‹äº‹ä»¶ç›‘å¬
        function setupScheduleTypeEventListeners() {
            scheduleTypeSelectors.forEach(type => {
                type.addEventListener('click', () => {
                    const scheduleType = type.getAttribute('data-type');
                    switchScheduleType(scheduleType);
                });
            });
            
            // æ¯æ—¥æ‰“å¡äº‹ä»¶
            dailyStartDateInput.addEventListener('change', updateDailyPreview);
            dailyEndDateInput.addEventListener('change', updateDailyPreview);
            weekdayOptions.forEach(option => {
                option.addEventListener('click', () => {
                    option.classList.toggle('selected');
                    updateDailyWeekdays();
                    updateDailyPreview();
                });
            });
            
            // è‡ªå®šä¹‰æ—¥æœŸäº‹ä»¶
            addCustomDateBtn.addEventListener('click', addCustomDate);
        }

        // åˆ‡æ¢æ‰“å¡è®¡åˆ’ç±»å‹
        function switchScheduleType(type) {
            appData.currentScheduleType = type;
            
            scheduleTypeSelectors.forEach(t => {
                if (t.getAttribute('data-type') === type) {
                    t.classList.add('active');
                } else {
                    t.classList.remove('active');
                }
            });
            
            // éšè—æ‰€æœ‰å®¹å™¨
            defaultScheduleInfo.classList.add('hidden');
            dailyScheduleContainer.classList.add('hidden');
            customScheduleContainer.classList.add('hidden');
            
            // æ˜¾ç¤ºå¯¹åº”çš„å®¹å™¨
            if (type === 'default') {
                defaultScheduleInfo.classList.remove('hidden');
            } else if (type === 'daily') {
                dailyScheduleContainer.classList.remove('hidden');
                // è®¾ç½®é»˜è®¤æ—¥æœŸ
                const today = new Date();
                dailyStartDateInput.valueAsDate = today;
                const endDate = new Date(today);
                endDate.setDate(today.getDate() + 30); // é»˜è®¤30å¤©
                dailyEndDateInput.valueAsDate = endDate;
                updateDailyPreview();
            } else if (type === 'custom') {
                customScheduleContainer.classList.remove('hidden');
            }
        }

        // æ›´æ–°æ¯æ—¥æ‰“å¡çš„æ˜ŸæœŸé€‰æ‹©
        function updateDailyWeekdays() {
            appData.dailySchedule.weekdays = [];
            weekdayOptions.forEach((option, index) => {
                if (option.classList.contains('selected')) {
                    appData.dailySchedule.weekdays.push(index);
                }
            });
        }

        // æ›´æ–°æ¯æ—¥æ‰“å¡é¢„è§ˆ
        function updateDailyPreview() {
            const startDate = dailyStartDateInput.valueAsDate;
            const endDate = dailyEndDateInput.valueAsDate;
            
            if (!startDate || !endDate) {
                dailyPreviewDates.innerHTML = '<div style="color: #64748b; text-align: center;">è¯·é€‰æ‹©å¼€å§‹å’Œç»“æŸæ—¥æœŸ</div>';
                return;
            }
            
            if (startDate > endDate) {
                dailyPreviewDates.innerHTML = '<div style="color: #ff6b6b; text-align: center;">ç»“æŸæ—¥æœŸä¸èƒ½æ—©äºå¼€å§‹æ—¥æœŸ</div>';
                return;
            }
            
            updateDailyWeekdays();
            const dates = generateDailySchedule(startDate, endDate, appData.dailySchedule.weekdays);
            
            if (dates.length === 0) {
                dailyPreviewDates.innerHTML = '<div style="color: #64748b; text-align: center;">æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„æ—¥æœŸ</div>';
                return;
            }
            
            dailyPreviewDates.innerHTML = dates.slice(0, 10).map(date => 
                `<div class="preview-date-item">${date.toLocaleDateString()}</div>`
            ).join('');
            
            if (dates.length > 10) {
                dailyPreviewDates.innerHTML += `<div style="color: #64748b; text-align: center;">... è¿˜æœ‰ ${dates.length - 10} å¤©</div>`;
            }
            
            appData.dailySchedule.startDate = startDate;
            appData.dailySchedule.endDate = endDate;
        }

        // ç”Ÿæˆæ¯æ—¥æ‰“å¡æ—¥æœŸ
        function generateDailySchedule(startDate, endDate, weekdays) {
            const dates = [];
            const current = new Date(startDate);
            
            while (current <= endDate) {
                if (weekdays.includes(current.getDay())) {
                    dates.push(new Date(current));
                }
                current.setDate(current.getDate() + 1);
            }
            
            return dates;
        }

        // æ·»åŠ è‡ªå®šä¹‰æ—¥æœŸ
        function addCustomDate() {
            const dateValue = customDateInput.value;
            if (!dateValue) {
                alert('è¯·é€‰æ‹©æ—¥æœŸ');
                return;
            }
            
            const selectedDate = new Date(dateValue);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            if (selectedDate < today) {
                alert('ä¸èƒ½é€‰æ‹©è¿‡å»çš„æ—¥æœŸ');
                return;
            }
            
            const dateExists = appData.customDates.some(date => 
                new Date(date).getTime() === selectedDate.getTime()
            );
            
            if (dateExists) {
                alert('è¯¥æ—¥æœŸå·²å­˜åœ¨');
                return;
            }
            
            appData.customDates.push(selectedDate.toISOString());
            renderCustomDatesList();
            customDateInput.value = '';
        }

        // æ¸²æŸ“è‡ªå®šä¹‰æ—¥æœŸåˆ—è¡¨
        function renderCustomDatesList() {
            customDatesList.innerHTML = '';
            
            if (appData.customDates.length === 0) {
                customDatesList.innerHTML = '<p style="text-align: center; color: #64748b; padding: 10px;">æš‚æ— è‡ªå®šä¹‰æ—¥æœŸ</p>';
                return;
            }
            
            const sortedDates = [...appData.customDates].sort((a, b) => new Date(a) - new Date(b));
            
            sortedDates.forEach((date, index) => {
                const dateObj = new Date(date);
                const dateItem = document.createElement('div');
                dateItem.className = 'custom-date-item';
                dateItem.innerHTML = `
                    <span>${dateObj.toLocaleDateString()}</span>
                    <button class="remove-date-btn" data-index="${index}">Ã—</button>
                `;
                customDatesList.appendChild(dateItem);
            });
            
            document.querySelectorAll('.remove-date-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.getAttribute('data-index'));
                    removeCustomDate(index);
                });
            });
        }

        // åˆ é™¤è‡ªå®šä¹‰æ—¥æœŸ
        function removeCustomDate(index) {
            appData.customDates.splice(index, 1);
            renderCustomDatesList();
        }

        // æ¯æ—¥æ¸…ç†æ£€æŸ¥
        function checkDailyCleanup() {
            const lastCleanupDate = localStorage.getItem('lastCleanupDate');
            const today = new Date().toDateString();
            
            if (lastCleanupDate !== today) {
                strictDailyCleanup();
                localStorage.setItem('lastCleanupDate', today);
            }
        }

        // ä¸¥æ ¼çš„æ¯æ—¥æ¸…é›¶ - åªä¿ç•™ä»Šå¤©çš„å½•éŸ³
        function strictDailyCleanup() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const originalCount = appData.recordings.length;
            
            // åªä¿ç•™ä»Šå¤©çš„å½•éŸ³
            appData.recordings = appData.recordings.filter(recording => {
                const recordingDate = new Date(recording.date);
                recordingDate.setHours(0, 0, 0, 0);
                return recordingDate.getTime() === today.getTime();
            });
            
            const deletedCount = originalCount - appData.recordings.length;
            if (deletedCount > 0) {
                saveRecordingsMetadata();
                console.log(`ä¸¥æ ¼æ¸…ç†ï¼šåˆ é™¤äº† ${deletedCount} ä¸ªéä»Šæ—¥å½•éŸ³`);
                
                // åŒæ—¶æ¸…ç†å¯¹åº”çš„æ‰“å¡è®°å½•
                appData.tasks.forEach(task => {
                    task.checkins = task.checkins.filter(checkin => {
                        const checkinDate = new Date(checkin.date);
                        checkinDate.setHours(0, 0, 0, 0);
                        return checkinDate.getTime() === today.getTime();
                    });
                });
                saveTasks();
            }
        }

        // å¤„ç†é¡µé¢å¯è§æ€§å˜åŒ–
        function handleVisibilityChange() {
            if (document.hidden) {
                saveRecordingState();
            } else {
                restoreRecordingState();
            }
        }

        // ä¿å­˜å½•éŸ³çŠ¶æ€
        function saveRecordingState() {
            if (appData.isRecording || appData.currentRecording) {
                appData.recordingState = {
                    isRecording: appData.isRecording,
                    isPaused: appData.isPaused,
                    recordingTime: appData.recordingTime,
                    currentTask: appData.currentTask,
                    currentCheckpointIndex: appData.currentCheckpointIndex,
                    audioChunks: appData.audioChunks
                };
                localStorage.setItem('recordingState', JSON.stringify(appData.recordingState));
            }
        }

        // æ¢å¤å½•éŸ³çŠ¶æ€
        function restoreRecordingState() {
            const savedState = localStorage.getItem('recordingState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    
                    if (state.isRecording && !state.isPaused) {
                        if (confirm('æ£€æµ‹åˆ°æœªå®Œæˆçš„å½•éŸ³ï¼Œæ˜¯å¦æ¢å¤å½•éŸ³ï¼Ÿ')) {
                            appData.isRecording = state.isRecording;
                            appData.isPaused = state.isPaused;
                            appData.recordingTime = state.recordingTime;
                            appData.currentTask = state.currentTask;
                            appData.currentCheckpointIndex = state.currentCheckpointIndex;
                            appData.audioChunks = state.audioChunks || [];
                            
                            updateTimer();
                            recordBtn.classList.add('hidden');
                            pauseBtn.classList.remove('hidden');
                            stopBtn.classList.remove('hidden');
                            updatePlaybackStatus('å½•éŸ³å·²æ¢å¤ï¼Œç‚¹å‡»æš‚åœ', 'status-recording');
                            
                            switchTab('recorder');
                            resumeRecording();
                        } else {
                            clearRecordingState();
                        }
                    }
                } catch (e) {
                    console.error('æ¢å¤å½•éŸ³çŠ¶æ€å¤±è´¥:', e);
                    clearRecordingState();
                }
            }
        }

        // æ¢å¤å½•éŸ³
        async function resumeRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                appData.mediaRecorder = new MediaRecorder(stream);
                
                appData.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        appData.audioChunks.push(event.data);
                    }
                };
                
                appData.mediaRecorder.onstop = () => {
                    processRecording(stream);
                };
                
                appData.mediaRecorder.start();
                
                appData.timerInterval = setInterval(() => {
                    appData.recordingTime += 10;
                    updateTimer();
                    updateWaveform();
                }, 10);
                
            } catch (error) {
                console.error('æ¢å¤å½•éŸ³å¤±è´¥:', error);
                alert('æ— æ³•æ¢å¤å½•éŸ³ï¼Œè¯·é‡æ–°å¼€å§‹');
                resetRecorder();
            }
        }

        // å¤„ç†å½•éŸ³æ•°æ®
        async function processRecording(stream) {
            try {
                if (appData.audioChunks.length === 0) {
                    console.warn('æ²¡æœ‰å½•éŸ³æ•°æ®');
                    return;
                }

                const audioBlob = new Blob(appData.audioChunks, { 
                    type: 'audio/webm;codecs=opus' 
                });

                console.log('å½•éŸ³æ–‡ä»¶å¤§å°:', (audioBlob.size / 1024 / 1024).toFixed(2), 'MB');

                // åˆ›å»ºå½•éŸ³å¯¹è±¡
                const recording = {
                    id: Date.now(),
                    taskId: appData.currentTask.id,
                    checkpointIndex: appData.currentCheckpointIndex,
                    date: new Date().toISOString(),
                    duration: appData.recordingTime,
                    audioBlob: audioBlob,
                    mimeType: 'audio/webm;codecs=opus',
                    size: audioBlob.size
                };

                // ä¿å­˜åˆ° IndexedDB
                await recordingStorage.saveRecording(recording);
                
                // åˆ›å»ºæ’­æ”¾URL
                recording.audioUrl = URL.createObjectURL(audioBlob);
                
                // æ›´æ–°åº”ç”¨çŠ¶æ€
                appData.currentRecording = recording;
                
                // ä»å†…å­˜ä¸­ç§»é™¤æ—§å½•éŸ³è®°å½•
                appData.recordings = appData.recordings.filter(r => 
                    r.taskId !== recording.taskId
                );
                
                // ä¿å­˜å…ƒæ•°æ®åˆ°å†…å­˜
                appData.recordings.push({
                    id: recording.id,
                    taskId: recording.taskId,
                    checkpointIndex: recording.checkpointIndex,
                    date: recording.date,
                    duration: recording.duration,
                    mimeType: recording.mimeType,
                    size: recording.size
                });

                // ä¿å­˜å…ƒæ•°æ®åˆ°LocalStorage
                saveRecordingsMetadata();
                
                // æ›´æ–°UI
                recordBtn.classList.remove('recording', 'hidden');
                pauseBtn.classList.add('hidden');
                stopBtn.classList.add('hidden');
                playBtn.classList.remove('hidden');
                submitRecordingBtn.disabled = false;
                
                audioPlayer.src = recording.audioUrl;
                audioPlayer.classList.remove('hidden');
                
                console.log('å½•éŸ³å¤„ç†å®Œæˆï¼Œå¯ä»¥æ’­æ”¾');

                stream.getTracks().forEach(track => track.stop());
                clearRecordingState();
                
            } catch (error) {
                console.error('å¤„ç†å½•éŸ³æ•°æ®æ—¶å‡ºé”™:', error);
                alert('ä¿å­˜å½•éŸ³å¤±è´¥: ' + error.message);
            }
        }

        // æ¸…é™¤å½•éŸ³çŠ¶æ€
        function clearRecordingState() {
            localStorage.removeItem('recordingState');
            appData.recordingState = null;
        }

        // è·å–é»˜è®¤ä»»åŠ¡
        function getDefaultTasks() {
            return [
                {
                    id: 1,
                    subject: 'è‹±è¯­',
                    name: 'å­¦ä¹ è‹±è¯­',
                    description: 'æ¯å¤©å­¦ä¹ 30åˆ†é’Ÿè‹±è¯­ï¼ŒåŒ…æ‹¬å•è¯è®°å¿†ã€è¯­æ³•ç»ƒä¹ å’Œå¬åŠ›è®­ç»ƒ',
                    createDate: new Date().toISOString(),
                    status: 'active',
                    checkins: [],
                    scheduleType: 'default'
                },
                {
                    id: 2,
                    subject: 'å…¶ä»–',
                    name: 'å¥èº«è®¡åˆ’',
                    description: 'æ¯å‘¨ä¸‰æ¬¡å¥èº«æˆ¿é”»ç‚¼ï¼ŒåŒ…æ‹¬æœ‰æ°§è¿åŠ¨å’ŒåŠ›é‡è®­ç»ƒ',
                    createDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
                    status: 'active',
                    checkins: [],
                    scheduleType: 'default'
                }
            ];
        }

        // ä¿å­˜ä»»åŠ¡æ•°æ®
        function saveTasks() {
            try {
                localStorage.setItem('checkinTasks', JSON.stringify(appData.tasks));
            } catch (e) {
                console.error('ä¿å­˜ä»»åŠ¡æ•°æ®å¤±è´¥:', e);
            }
        }

        // ä¿å­˜å½•éŸ³å…ƒæ•°æ®
        function saveRecordingsMetadata() {
            try {
                const metadata = appData.recordings.map(recording => ({
                    id: recording.id,
                    taskId: recording.taskId,
                    checkpointIndex: recording.checkpointIndex,
                    date: recording.date,
                    duration: recording.duration,
                    mimeType: recording.mimeType,
                    size: recording.size
                }));
                
                localStorage.setItem('checkinRecordings', JSON.stringify(metadata));
            } catch (e) {
                console.error('ä¿å­˜å½•éŸ³å…ƒæ•°æ®å¤±è´¥:', e);
            }
        }

        // ä»æœ¬åœ°åŠ è½½æ•°æ®
        async function loadLocalData() {
            const savedTasks = localStorage.getItem('checkinTasks');
            const savedRecordingsMetadata = localStorage.getItem('checkinRecordings');
            const savedFeedbacks = localStorage.getItem('checkinFeedbacks');
            
            if (savedTasks) {
                try {
                    appData.tasks = JSON.parse(savedTasks);
                } catch (e) {
                    console.error('è§£æä»»åŠ¡æ•°æ®å¤±è´¥:', e);
                    appData.tasks = getDefaultTasks();
                }
            } else {
                appData.tasks = getDefaultTasks();
            }
            
            // åªåŠ è½½å…ƒæ•°æ®
            if (savedRecordingsMetadata) {
                try {
                    appData.recordings = JSON.parse(savedRecordingsMetadata);
                    cleanupOldRecordings();
                    } catch (e) {
                    console.error('è§£æå½•éŸ³å…ƒæ•°æ®å¤±è´¥:', e);
                    appData.recordings = [];
                }
            } else {
                appData.recordings = [];
            }
            
            if (savedFeedbacks) {
                try {
                    appData.feedbacks = JSON.parse(savedFeedbacks);
                    } catch (e) {
                    console.error('è§£æç‚¹è¯„æ•°æ®å¤±è´¥:', e);
                    appData.feedbacks = [];
                }
            } else {
                appData.feedbacks = [];
            }
            
            saveLocalData();
        }

        // æ¸…ç†æ—§å½•éŸ³ï¼Œæ¯ä¸ªä»»åŠ¡åªä¿ç•™æœ€æ–°ä¸€æ¬¡æ‰“å¡
        function cleanupOldRecordings() {
            const taskRecordings = {};
            
            appData.recordings.forEach(recording => {
                if (!taskRecordings[recording.taskId]) {
                    taskRecordings[recording.taskId] = [];
                }
                taskRecordings[recording.taskId].push(recording);
            });
            
            const cleanedRecordings = [];
            Object.keys(taskRecordings).forEach(taskId => {
                const recordings = taskRecordings[taskId];
                if (recordings.length > 0) {
                    const latestRecording = recordings.sort((a, b) => 
                        new Date(b.date) - new Date(a.date)
                    )[0];
                    cleanedRecordings.push(latestRecording);
                }
            });
            
            appData.recordings = cleanedRecordings;
            saveRecordingsMetadata();
        }

        // ä¿å­˜æ•°æ®åˆ°æœ¬åœ°
        function saveLocalData() {
            saveTasks();
            saveRecordingsMetadata();
            localStorage.setItem('checkinFeedbacks', JSON.stringify(appData.feedbacks));
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.getAttribute('data-tab');
                    switchTab(tabId);
                });
            });

            addTaskBtn.addEventListener('click', showTaskForm);
            saveTaskBtn.addEventListener('click', saveTask);
            cancelTaskBtn.addEventListener('click', hideTaskForm);
            updateTaskBtn.addEventListener('click', updateTask);
            cancelEditTaskBtn.addEventListener('click', hideEditTaskForm);

            prevMonthBtn.addEventListener('click', () => navigateCalendar(-1));
            nextMonthBtn.addEventListener('click', () => navigateCalendar(1));
            todayBtn.addEventListener('click', goToToday);

            recordBtn.addEventListener('click', startRecording);
            pauseBtn.addEventListener('click', togglePause);
            stopBtn.addEventListener('click', stopRecording);
            playBtn.addEventListener('click', playRecording);
            submitRecordingBtn.addEventListener('click', submitRecording);
            resetRecorderBtn.addEventListener('click', resetRecorder);
        }
        
        // è®¾ç½®ä¸Šä¼ ç›¸å…³äº‹ä»¶ç›‘å¬å™¨
        function setupUploadEventListeners() {
            recordModeBtn.addEventListener('click', () => switchRecorderMode('record'));
            uploadModeBtn.addEventListener('click', () => switchRecorderMode('upload'));
            
            audioFileInput.addEventListener('change', handleFileUpload);
            submitUploadBtn.addEventListener('click', submitUploadedAudio);
            resetUploadBtn.addEventListener('click', resetUpload);
        }

        // è®¾ç½®æ•°æ®ç®¡ç†äº‹ä»¶ç›‘å¬å™¨
        function setupDataManagementEventListeners() {
            showDataModalBtn.addEventListener('click', showDataManagementModal);
            closeDataModalBtn.addEventListener('click', hideDataManagementModal);
            exportDataBtn.addEventListener('click', exportData);
            importDataFile.addEventListener('change', handleImportFileSelect);
            importDataBtn.addEventListener('click', importData);
            clearDataBtn.addEventListener('click', clearAllData);
        }

        // è®¾ç½®ä»»åŠ¡è¯¦æƒ…äº‹ä»¶ç›‘å¬å™¨
        function setupTaskDetailsEventListeners() {
            closeTaskDetailsBtn.addEventListener('click', hideTaskDetails);
        }

        // æ›´æ–°æ’­æ”¾çŠ¶æ€æ˜¾ç¤º
        function updatePlaybackStatus(message, statusClass) {
            recordingStatusEl.textContent = message;
            recordingStatusEl.className = 'recording-status ' + statusClass;
            recordingStatusEl.classList.remove('hidden');
        }

        // åˆ‡æ¢æ ‡ç­¾é¡µ
        function switchTab(tabId) {
            tabs.forEach(tab => {
                if (tab.getAttribute('data-tab') === tabId) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            tabContents.forEach(content => {
                if (content.id === `${tabId}-tab`) {
                    content.classList.add('active');
                } else {
                    content.classList.remove('active');
                }
            });

            if (tabId === 'today') {
                renderTodayTasks();
            } else if (tabId === 'tasks') {
                renderAllTasks();
            } else if (tabId === 'calendar') {
                renderCalendar();
            } else if (tabId === 'recorder') {
                renderRecordings();
            } else if (tabId === 'data') {
                renderDataStats();
            }
        }
        
        // åˆ‡æ¢å½•éŸ³æ¨¡å¼
        function switchRecorderMode(mode) {
            appData.currentMode = mode;
            
            if (mode === 'record') {
                recordModeBtn.classList.add('active');
                uploadModeBtn.classList.remove('active');
                recordContainer.classList.remove('hidden');
                uploadContainer.classList.add('hidden');
                
                if (appData.currentTask) {
                    updateRecorderTaskInfo();
                }
            } else {
                recordModeBtn.classList.remove('active');
                uploadModeBtn.classList.add('active');
                recordContainer.classList.add('hidden');
                uploadContainer.classList.remove('hidden');
                
                if (appData.currentTask) {
                    updateUploadTaskInfo();
                }
            }
        }

        // æ›´æ–°å½•éŸ³ç•Œé¢çš„ä»»åŠ¡ä¿¡æ¯
        function updateRecorderTaskInfo() {
            recorderTaskNameEl.textContent = `${appData.currentTask.subject} - ${appData.currentTask.name}`;
            const taskSchedule = getTaskCheckinSchedule(appData.currentTask);
            const checkpointDay = taskSchedule[appData.currentCheckpointIndex];
            
            if (appData.currentTask.scheduleType === 'custom') {
                const startDate = new Date(appData.currentTask.createDate);
                const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                recorderCheckpointEl.textContent = `${checkinDate.toLocaleDateString()} æ‰“å¡`;
            } else if (appData.currentTask.scheduleType === 'daily') {
                const startDate = new Date(appData.currentTask.createDate);
                const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                recorderCheckpointEl.textContent = `${checkinDate.toLocaleDateString()} æ‰“å¡`;
            } else {
                recorderCheckpointEl.textContent = `ç¬¬${checkpointDay}å¤©æ‰“å¡`;
            }
            
            if (appData.currentTask.description) {
                recorderTaskDescContentEl.textContent = appData.currentTask.description;
                recorderTaskDescriptionEl.classList.remove('hidden');
            } else {
                recorderTaskDescriptionEl.classList.add('hidden');
            }
        }

        // æ›´æ–°ä¸Šä¼ ç•Œé¢çš„ä»»åŠ¡ä¿¡æ¯
        function updateUploadTaskInfo() {
            uploadTaskNameEl.textContent = `${appData.currentTask.subject} - ${appData.currentTask.name}`;
            const taskSchedule = getTaskCheckinSchedule(appData.currentTask);
            const checkpointDay = taskSchedule[appData.currentCheckpointIndex];
            
            if (appData.currentTask.scheduleType === 'custom') {
                const startDate = new Date(appData.currentTask.createDate);
                const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                uploadCheckpointEl.textContent = `${checkinDate.toLocaleDateString()} æ‰“å¡`;
            } else if (appData.currentTask.scheduleType === 'daily') {
                const startDate = new Date(appData.currentTask.createDate);
                const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                uploadCheckpointEl.textContent = `${checkinDate.toLocaleDateString()} æ‰“å¡`;
            } else {
                uploadCheckpointEl.textContent = `ç¬¬${checkpointDay}å¤©æ‰“å¡`;
            }
            
            if (appData.currentTask.description) {
                uploadTaskDescContentEl.textContent = appData.currentTask.description;
                uploadTaskDescriptionEl.classList.remove('hidden');
            } else {
                uploadTaskDescriptionEl.classList.add('hidden');
            }
        }

        // æ˜¾ç¤ºä»»åŠ¡è¡¨å•
        function showTaskForm() {
            taskFormEl.classList.remove('hidden');
            hideEditTaskForm();
            document.getElementById('task-subject').value = 'è¯­æ–‡';
            document.getElementById('task-name').value = '';
            document.getElementById('task-desc').value = '';
            document.getElementById('task-date').valueAsDate = new Date();
            
            switchScheduleType('default');
            appData.customDates = [];
            appData.dailySchedule = {
                startDate: null,
                endDate: null,
                weekdays: [0, 1, 2, 3, 4, 5, 6]
            };
            renderCustomDatesList();
            
            taskFormEl.scrollIntoView({ behavior: 'smooth' });
        }

        // éšè—ä»»åŠ¡è¡¨å•
        function hideTaskForm() {
            taskFormEl.classList.add('hidden');
        }

        // æ˜¾ç¤ºç¼–è¾‘ä»»åŠ¡è¡¨å•
        function showEditTaskForm(taskId) {
            const task = appData.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            appData.editingTask = task;
            editTaskFormEl.classList.remove('hidden');
            hideTaskForm();
            
            document.getElementById('edit-task-subject').value = task.subject;
            document.getElementById('edit-task-name').value = task.name;
            document.getElementById('edit-task-desc').value = task.description || '';
            editTaskFormEl.scrollIntoView({ behavior: 'smooth' });
        }

        // éšè—ç¼–è¾‘ä»»åŠ¡è¡¨å•
        function hideEditTaskForm() {
            editTaskFormEl.classList.add('hidden');
            appData.editingTask = null;
        }

        // ä¿å­˜ä»»åŠ¡
        function saveTask() {
            const subject = document.getElementById('task-subject').value;
            const name = document.getElementById('task-name').value.trim();
            const desc = document.getElementById('task-desc').value.trim();
            let date = document.getElementById('task-date').value;
            
            if (!name) {
                alert('è¯·è¾“å…¥ä»»åŠ¡åç§°');
                return;
            }
            
            if (!date) {
                date = new Date().toISOString().split('T')[0];
            }
            
            const newTask = {
                id: Date.now(),
                subject: subject,
                name: name,
                description: desc,
                createDate: date ? new Date(date).toISOString() : new Date().toISOString(),
                status: 'active',
                checkins: [],
                scheduleType: appData.currentScheduleType
            };
            
            if (appData.currentScheduleType === 'daily') {
                if (!appData.dailySchedule.startDate || !appData.dailySchedule.endDate) {
                    alert('è¯·è®¾ç½®æ¯æ—¥æ‰“å¡çš„å¼€å§‹å’Œç»“æŸæ—¥æœŸ');
                    return;
                }
                newTask.dailySchedule = { ...appData.dailySchedule };
                newTask.dailySchedule.startDate = appData.dailySchedule.startDate.toISOString();
                newTask.dailySchedule.endDate = appData.dailySchedule.endDate.toISOString();
            } else if (appData.currentScheduleType === 'custom') {
                if (appData.customDates.length === 0) {
                    alert('è¯·è‡³å°‘æ·»åŠ ä¸€ä¸ªè‡ªå®šä¹‰æ‰“å¡æ—¥æœŸ');
                    return;
                }
                newTask.customDates = [...appData.customDates];
            }
            
            appData.tasks.push(newTask);
            saveTasks();
            hideTaskForm();
            
            appData.customDates = [];
            appData.dailySchedule = {
                startDate: null,
                endDate: null,
                weekdays: [0, 1, 2, 3, 4, 5, 6]
            };
            renderCustomDatesList();
            
            renderAllTasks();
            renderTodayTasks();
            renderCalendar();
            renderDataStats();
        }

        // æ›´æ–°ä»»åŠ¡
        function updateTask() {
            if (!appData.editingTask) return;
            
            const subject = document.getElementById('edit-task-subject').value;
            const name = document.getElementById('edit-task-name').value.trim();
            const desc = document.getElementById('edit-task-desc').value.trim();
            
            if (!name) {
                alert('è¯·è¾“å…¥ä»»åŠ¡åç§°');
                return;
            }
            
            appData.editingTask.subject = subject;
            appData.editingTask.name = name;
            appData.editingTask.description = desc;
            
            saveTasks();
            hideEditTaskForm();
            renderAllTasks();
            renderTodayTasks();
            renderCalendar();
            renderDataStats();
        }

        // è·å–ä»»åŠ¡çš„ä¸Šæ¬¡å½•éŸ³ç”¨æ—¶
        function getLastRecordingDuration(task) {
            if (task.checkins.length === 0) return null;
            
            const latestCheckin = task.checkins.reduce((latest, current) => 
                new Date(current.date) > new Date(latest.date) ? current : latest
            );
            
            const recording = appData.recordings.find(r => r.id === latestCheckin.recordingId);
            return recording ? recording.duration : null;
        }

        // è·å–ä»»åŠ¡çš„æ‰“å¡è®¡åˆ’
        function getTaskCheckinSchedule(task) {
            if (task.scheduleType === 'daily' && task.dailySchedule) {
                const startDate = new Date(task.createDate);
                startDate.setHours(0, 0, 0, 0);
                
                const dailyStart = new Date(task.dailySchedule.startDate);
                const dailyEnd = new Date(task.dailySchedule.endDate);
                const weekdays = task.dailySchedule.weekdays || [0, 1, 2, 3, 4, 5, 6];
                
                const dates = generateDailySchedule(dailyStart, dailyEnd, weekdays);
                return dates.map(date => {
                    date.setHours(0, 0, 0, 0);
                    return Math.floor((date - startDate) / (1000 * 60 * 60 * 24));
                }).sort((a, b) => a - b);
            } else if (task.scheduleType === 'custom' && task.customDates) {
                const startDate = new Date(task.createDate);
                startDate.setHours(0, 0, 0, 0);
                
                return task.customDates.map(customDate => {
                    const date = new Date(customDate);
                    date.setHours(0, 0, 0, 0);
                    return Math.floor((date - startDate) / (1000 * 60 * 60 * 24));
                }).sort((a, b) => a - b);
            }
            
            return checkinSchedule;
        }

        // æ¸²æŸ“ä»Šæ—¥ä»»åŠ¡
        function renderTodayTasks() {
            todayTasksEl.innerHTML = '';
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            let tasksForToday = [];
            let totalTasks = 0;
            let uncompletedTasks = 0;
            
            appData.tasks.forEach(task => {
                if (task.status !== 'active') return;
                
                const taskSchedule = getTaskCheckinSchedule(task);
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((today - taskDate) / (1000 * 60 * 60 * 60 * 24));
                
                const checkpointIndex = taskSchedule.findIndex(day => day === daysSinceStart);
                
                if (checkpointIndex !== -1) {
                    const hasCheckedIn = task.checkins.some(checkin => 
                        checkin.checkpointIndex === checkpointIndex
                    );
                    
                    totalTasks++;
                    if (!hasCheckedIn) uncompletedTasks++;
                    
                    tasksForToday.push({
                        task,
                        checkpointIndex,
                        daysSinceStart,
                        isOverdue: false,
                        hasCheckedIn,
                        hasPendingRecording: false
                    });
                }
                
                for (let i = 0; i < taskSchedule.length; i++) {
                    const checkpointDay = taskSchedule[i];
                    if (checkpointDay < daysSinceStart && 
                        !task.checkins.some(checkin => checkin.checkpointIndex === i)) {
                        
                        totalTasks++;
                        uncompletedTasks++;
                        
                        tasksForToday.push({
                            task,
                            checkpointIndex: i,
                            daysSinceStart,
                            isOverdue: true,
                            hasCheckedIn: false,
                            hasPendingRecording: false
                        });
                    }
                }
            });
            
            todayTasksCountEl.textContent = `${uncompletedTasks}/${totalTasks} ä¸ªä»»åŠ¡`;
            
            tasksForToday.sort((a, b) => {
                const subjectOrder = { 'è¯­æ–‡': 1, 'æ•°å­¦': 2, 'è‹±è¯­': 3, 'ç§‘å­¦': 4, 'å…¶ä»–': 5 };
                const subjectA = subjectOrder[a.task.subject] || 6;
                const subjectB = subjectOrder[b.task.subject] || 6;
                
                if (subjectA !== subjectB) {
                    return subjectA - subjectB;
                }
                
                return new Date(b.task.createDate) - new Date(a.task.createDate);
            });
            
            if (tasksForToday.length === 0) {
                todayTasksEl.innerHTML = `
                    <div class="empty-state">
                        <i>ğŸ“…</i>
                        <p>ä»Šå¤©æ²¡æœ‰æ‰“å¡ä»»åŠ¡ï¼Œæ”¾æ¾ä¸€ä¸‹å§ï¼</p>
                    </div>
                `;
                return;
            }
            
            tasksForToday.forEach(item => {
                renderTodayTaskItem(item.task, todayTasksEl, item.checkpointIndex, item.daysSinceStart, 
                              item.isOverdue, item.hasCheckedIn, item.hasPendingRecording);
            });
        }

        // æ¸²æŸ“ä»Šæ—¥ä»»åŠ¡é¡¹
        function renderTodayTaskItem(task, container, checkpointIndex, daysSinceStart, isOverdue = false, hasCheckedIn = false, hasPendingRecording = false) {
            const taskEl = document.createElement('div');
            
            let taskClass = 'task-item';
            if (isOverdue) {
                taskClass += ' overdue';
            } else if (hasCheckedIn) {
                taskClass += ' completed';
            }
            
            taskEl.className = taskClass;
            
            const taskSchedule = getTaskCheckinSchedule(task);
            const checkpointDay = taskSchedule[checkpointIndex];
            
            let statusText = '';
            let scheduleTypeText = '';
            
            if (isOverdue) {
                statusText = `é€¾æœŸ${daysSinceStart - checkpointDay}å¤©`;
            } else {
                if (task.scheduleType === 'custom') {
                    const startDate = new Date(task.createDate);
                    const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                    statusText = checkinDate.toLocaleDateString();
                    scheduleTypeText = 'ğŸ“… è‡ªå®šä¹‰æ—¥æœŸè®¡åˆ’';
                } else if (task.scheduleType === 'daily') {
                    const startDate = new Date(task.createDate);
                    const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                    statusText = checkinDate.toLocaleDateString();
                    scheduleTypeText = 'ğŸ“… æ¯æ—¥æ‰“å¡è®¡åˆ’';
                } else {
                    statusText = checkpointDay === 0 ? 'æ–°ä»»åŠ¡' : `ç¬¬${checkpointDay}å¤©`;
                }
            }
            
            const completedCheckins = task.checkins.length;
            const totalCheckins = taskSchedule.length;
            const progressPercent = (completedCheckins / totalCheckins) * 100;
            
            const lastRecordingDuration = getLastRecordingDuration(task);
            const lastRecordingText = lastRecordingDuration ? 
                `ä¸Šæ¬¡å½•éŸ³ç”¨æ—¶: ${formatTime(lastRecordingDuration)}` : '';
            
            const compactCheckinInfo = generateCompactCheckinInfo(task);
            
            const subjectClass = `subject-${getSubjectClass(task.subject)}`;
            
            const hasPlayableRecording = completedCheckins > 0;
            
            taskEl.innerHTML = `
                <div class="task-header">
                    <div class="task-name ${subjectClass}">${task.subject} - ${task.name}</div>
                    <div class="task-status ${hasCheckedIn ? 'status-completed' : (isOverdue ? 'status-overdue' : 'status-today')}">
                        ${statusText} ${hasCheckedIn ? 'âœ“ ä»Šæ—¥å·²æ‰“å¡' : 'æœªå®Œæˆ'}
                    </div>
                </div>
                ${task.description ? `<p>${task.description}</p>` : ''}
                <div class="task-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    <div class="progress-text">
                        å·²å®Œæˆ ${completedCheckins} æ¬¡æ‰“å¡
                        ${lastRecordingText ? `<div class="last-recording-time">${lastRecordingText}</div>` : ''}
                        ${scheduleTypeText ? `<div>${scheduleTypeText}</div>` : ''}
                    </div>
                    ${compactCheckinInfo}
                </div>
                <div class="task-actions">
                    ${!hasCheckedIn ? 
                        `<button class="btn btn-primary" onclick="startCheckin(${task.id}, ${checkpointIndex})">
                            ç«‹å³æ‰“å¡
                        </button>` : ''}
                    <button class="btn btn-secondary" onclick="showEditTaskForm(${task.id})">ç¼–è¾‘</button>
                    <button class="btn btn-secondary" onclick="viewTaskDetails(${task.id})">è¯¦æƒ…</button>
                    <button class="btn btn-danger" onclick="deleteTask(${task.id})">åˆ é™¤</button>
                    ${hasPlayableRecording ? `<button class="btn btn-secondary" onclick="playLatestRecording(${task.id}, event)" id="play-latest-${task.id}">å›æ”¾å½•éŸ³</button>` : ''}
                </div>
            `;
            
            container.appendChild(taskEl);
        }

        // æ¸²æŸ“æ‰€æœ‰ä»»åŠ¡
        function renderAllTasks() {
            allTasksEl.innerHTML = '';
            
            if (appData.tasks.length === 0) {
                allTasksEl.innerHTML = `
                    <div class="empty-state">
                        <i>ğŸ“</i>
                        <p>è¿˜æ²¡æœ‰ä»»ä½•ä»»åŠ¡ï¼Œç‚¹å‡»"æ–°å»ºä»»åŠ¡"å¼€å§‹å§ï¼</p>
                    </div>
                `;
                return;
            }
            
            const sortedTasks = [...appData.tasks].sort((a, b) => {
                const subjectOrder = { 'è¯­æ–‡': 1, 'æ•°å­¦': 2, 'è‹±è¯­': 3, 'ç§‘å­¦': 4, 'å…¶ä»–': 5 };
                const subjectA = subjectOrder[a.subject] || 6;
                const subjectB = subjectOrder[b.subject] || 6;
                
                if (subjectA !== subjectB) {
                    return subjectA - subjectB;
                }
                
                return new Date(b.createDate) - new Date(a.createDate);
            });
            
            sortedTasks.forEach(task => {
                const taskEl = document.createElement('div');
                taskEl.className = 'task-item';
                
                const taskSchedule = getTaskCheckinSchedule(task);
                const completedCheckins = task.checkins.length;
                const totalCheckins = taskSchedule.length;
                const progressPercent = (completedCheckins / totalCheckins) * 100;
                
                const lastRecordingDuration = getLastRecordingDuration(task);
                const lastRecordingText = lastRecordingDuration ? 
                    `ä¸Šæ¬¡å½•éŸ³ç”¨æ—¶: ${formatTime(lastRecordingDuration)}` : '';
                
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((today - taskDate) / (1000 * 60 * 60 * 24));
                const checkpointIndex = taskSchedule.findIndex(day => day === daysSinceStart);
                const shouldCheckinToday = checkpointIndex !== -1;
                const hasCheckedInToday = shouldCheckinToday ? 
                    task.checkins.some(checkin => checkin.checkpointIndex === checkpointIndex) : false;
                
                let hasOverdue = false;
                for (let i = 0; i < taskSchedule.length; i++) {
                    const checkpointDay = taskSchedule[i];
                    if (checkpointDay < daysSinceStart && 
                        !task.checkins.some(checkin => checkin.checkpointIndex === i)) {
                        hasOverdue = true;
                        break;
                    }
                }
                
                const canCheckinToday = shouldCheckinToday && !hasCheckedInToday;
                const hasOverdueCheckin = hasOverdue;
                const checkinBtnEnabled = canCheckinToday || hasOverdueCheckin;
                
                let statusClass = 'status-future';
                let statusText = '';
                let scheduleTypeText = '';
                
                if (hasOverdue) {
                    statusClass = 'status-overdue';
                    statusText = 'æœ‰é€¾æœŸ';
                } else if (shouldCheckinToday) {
                    statusClass = hasCheckedInToday ? 'status-completed' : 'status-pending';
                    statusText = hasCheckedInToday ? 'ä»Šæ—¥å·²æ‰“å¡' : 'ä»Šæ—¥æœªæ‰“å¡';
                }
                
                if (task.scheduleType === 'daily') {
                    scheduleTypeText = 'ğŸ“… æ¯æ—¥æ‰“å¡è®¡åˆ’';
                } else if (task.scheduleType === 'custom') {
                    scheduleTypeText = 'ğŸ“… è‡ªå®šä¹‰æ—¥æœŸè®¡åˆ’';
                }
                
                const compactCheckinInfo = generateCompactCheckinInfo(task);
                
                const subjectClass = `subject-${getSubjectClass(task.subject)}`;
                
                const hasPlayableRecording = completedCheckins > 0;
                
                taskEl.innerHTML = `
                    <div class="task-header">
                        <div class="task-name ${subjectClass}">${task.subject} - ${task.name}</div>
                        <div class="task-status ${statusClass}">
                            ${completedCheckins}/${totalCheckins}
                            ${statusText}
                        </div>
                    </div>
                    ${task.description ? `<p>${task.description}</p>` : ''}
                    <div class="task-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${progressPercent}%"></div>
                        </div>
                        <div class="progress-text">
                            å·²å®Œæˆ ${completedCheckins} æ¬¡æ‰“å¡ï¼Œè¿˜éœ€ ${totalCheckins - completedCheckins} æ¬¡
                            ${lastRecordingText ? `<div class="last-recording-time">${lastRecordingText}</div>` : ''}
                            ${scheduleTypeText ? `<div>${scheduleTypeText}</div>` : ''}
                        </div>
                        ${compactCheckinInfo}
                    </div>
                    <div class="task-actions">
                        <button class="btn ${checkinBtnEnabled ? 'btn-primary' : 'btn-disabled'}" onclick="handleCheckinClick(${task.id}, ${!checkinBtnEnabled})">
                            æ‰“å¡
                        </button>
                        <button class="btn btn-secondary" onclick="showEditTaskForm(${task.id})">ç¼–è¾‘</button>
                        <button class="btn btn-secondary" onclick="viewTaskDetails(${task.id})">è¯¦æƒ…</button>
                        <button class="btn btn-danger" onclick="deleteTask(${task.id})">åˆ é™¤</button>
                        ${hasPlayableRecording ? `<button class="btn btn-secondary" onclick="playLatestRecording(${task.id}, event)" id="play-latest-${task.id}">å›æ”¾å½•éŸ³</button>` : ''}
                    </div>
                `;
                
                allTasksEl.appendChild(taskEl);
            });
        }

        // è·å–ç§‘ç›®å¯¹åº”çš„CSSç±»å
        function getSubjectClass(subject) {
            const subjectMap = {
                'è¯­æ–‡': 'chinese',
                'æ•°å­¦': 'math',
                'è‹±è¯­': 'english',
                'ç§‘å­¦': 'science',
                'å…¶ä»–': 'other'
            };
            return subjectMap[subject] || 'other';
        }

        // ç”Ÿæˆç´§å‡‘çš„æ‰“å¡è®°å½•ä¿¡æ¯
        function generateCompactCheckinInfo(task) {
            if (task.checkins.length === 0) {
                return '';
            }
            
            const taskSchedule = getTaskCheckinSchedule(task);
            const recentCheckins = [...task.checkins]
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .slice(0, 3);
            
            const checkinItems = recentCheckins.map(checkin => {
                const checkpointDay = taskSchedule[checkin.checkpointIndex];
                
                if (task.scheduleType === 'custom' || task.scheduleType === 'daily') {
                    const startDate = new Date(task.createDate);
                    const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                    const formattedDate = `${checkinDate.getMonth()+1}/${checkinDate.getDate()}`;
                    return `<span class="compact-checkin-item">${formattedDate}</span>`;
                } else {
                    const date = new Date(checkin.date);
                    const formattedDate = `${date.getMonth()+1}/${date.getDate()}`;
                    return `<span class="compact-checkin-item">ç¬¬${checkpointDay}å¤© ${formattedDate}</span>`;
                }
            }).join('');
            
            return `<div class="compact-checkin-info">æœ€è¿‘æ‰“å¡: ${checkinItems}</div>`;
        }

        // å¤„ç†æ‰“å¡æŒ‰é’®ç‚¹å‡»
        function handleCheckinClick(taskId, isDisabled) {
            if (isDisabled) {
                alert('ä»Šæ—¥å·²ç»æ‰“å¡æˆåŠŸï¼');
                return;
            }
            startCheckin(taskId);
        }

        // æ’­æ”¾æœ€æ–°å½•éŸ³ - å¹³æ¿å…¼å®¹ç‰ˆæœ¬
        async function playLatestRecording(taskId, event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            console.log('ğŸ“± å¹³æ¿æ’­æ”¾æœ€æ–°å½•éŸ³...');
            const task = appData.tasks.find(t => t.id === taskId);
            if (!task) {
                alert('æœªæ‰¾åˆ°ä»»åŠ¡');
                return;
            }
            
            if (task.checkins.length === 0) {
                alert('è¯¥ä»»åŠ¡æ²¡æœ‰å½•éŸ³è®°å½•');
                return;
            }
            
            const latestCheckin = task.checkins.reduce((latest, current) => {
                const latestDate = new Date(latest.date);
                const currentDate = new Date(current.date);
                return currentDate > latestDate ? current : latest;
            });
            
            if (!latestCheckin.recordingId) {
                alert('è¯¥ä»»åŠ¡æ²¡æœ‰å½•éŸ³è®°å½•');
                return;
            }
            
            // ç›´æ¥ä¼ é€’äº‹ä»¶å¯¹è±¡
            await playSavedRecording(latestCheckin.recordingId, event);
        }

        // æ’­æ”¾ä¿å­˜çš„å½•éŸ³ - å¹³æ¿å…¼å®¹ç‰ˆæœ¬
        async function playSavedRecording(recordingId, event) {
            // åœ¨å¹³æ¿ä¸Šï¼Œç¡®ä¿æˆ‘ä»¬æœ‰ç”¨æˆ·äº‹ä»¶å¯¹è±¡
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            try {
                console.log('ğŸ“± å¹³æ¿å…¼å®¹æ’­æ”¾å¼€å§‹...');
                
                // ç«‹å³æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                const playBtn = event ? event.target : document.getElementById(`play-saved-${recordingId}`);
                const originalText = playBtn?.textContent || 'æ’­æ”¾';
                
                if (playBtn) {
                    playBtn.textContent = 'åŠ è½½ä¸­...';
                    playBtn.disabled = true;
                }
                
                // å¿«é€ŸåŒæ­¥æ‰§è¡Œæ‰€æœ‰æ“ä½œ
                console.log('1. è·å–å½•éŸ³æ•°æ®...');
                const recording = await recordingStorage.getRecording(recordingId);
                
                if (!recording?.audioBlob) {
                    throw new Error('å½•éŸ³æ•°æ®ä¸å­˜åœ¨');
                }
                
                console.log('2. åˆ›å»ºéŸ³é¢‘URL...');
                const audioUrl = URL.createObjectURL(recording.audioBlob);
                
                // åˆ‡æ¢åˆ°å½•éŸ³æ ‡ç­¾é¡µ
                switchTab('recorder');
                
                // ç¡®ä¿éŸ³é¢‘å…ƒç´ å¯è§ä¸”å·²è®¾ç½®
                audioPlayer.classList.remove('hidden');
                audioPlayer.src = audioUrl;
                
                // æ·»åŠ è¯¦ç»†çš„é”™è¯¯å¤„ç†
                audioPlayer.onerror = () => {
                    console.error('éŸ³é¢‘å…ƒç´ é”™è¯¯:', audioPlayer.error);
                    if (playBtn) {
                        playBtn.textContent = originalText;
                        playBtn.disabled = false;
                    }
                    URL.revokeObjectURL(audioUrl);
                };
                
                audioPlayer.oncanplay = () => {
                    console.log('éŸ³é¢‘å¯ä»¥æ’­æ”¾');
                };
                
                // å…³é”®ï¼šç«‹å³åŒæ­¥æ’­æ”¾ï¼
                console.log('3. ç«‹å³æ’­æ”¾...');
                await audioPlayer.play();
                
                console.log('ğŸ‰ æ’­æ”¾æˆåŠŸ');
                
                // æ’­æ”¾ç»“æŸåçš„æ¸…ç†
                audioPlayer.onended = () => {
                    if (playBtn) {
                        playBtn.textContent = originalText;
                        playBtn.disabled = false;
                    }
                    setTimeout(() => URL.revokeObjectURL(audioUrl), 1000);
                };
                
            } catch (error) {
                console.error('âŒ å¹³æ¿æ’­æ”¾å¤±è´¥:', error);
                
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                const playBtn = event ? event.target : document.getElementById(`play-saved-${recordingId}`);
                if (playBtn) {
                    playBtn.textContent = 'æ’­æ”¾';
                    playBtn.disabled = false;
                }
                
                // å¹³æ¿ç‰¹å®šçš„é”™è¯¯å¤„ç†
                if (error.name === 'NotAllowedError') {
                    alert('è¯·åœ¨å¹³æ¿ä¸Šç‚¹å‡»"å…è®¸"éŸ³é¢‘æ’­æ”¾æƒé™\næˆ–è€…å°è¯•é•¿æŒ‰æ’­æ”¾æŒ‰é’®');
                } else {
                    alert('æ’­æ”¾å¤±è´¥: ' + error.message);
                }
            }
        }

        // æ¸²æŸ“æ—¥å†
        function renderCalendar() {
            calendarEl.innerHTML = '';
            
            const weekdays = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
            weekdays.forEach(day => {
                const dayEl = document.createElement('div');
                dayEl.className = 'calendar-weekday';
                dayEl.textContent = day;
                calendarEl.appendChild(dayEl);
            });
            
            const year = appData.currentCalendarDate.getFullYear();
            const month = appData.currentCalendarDate.getMonth();
            calendarTitleEl.textContent = `${year}å¹´${month + 1}æœˆ`;
            
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            
            const firstDayIndex = firstDay.getDay();
            const prevMonthLastDay = new Date(year, month, 0).getDate();
            
            for (let i = firstDayIndex - 1; i >= 0; i--) {
                const dayEl = document.createElement('div');
                dayEl.className = 'calendar-day other-month';
                dayEl.innerHTML = `<div class="day-number">${prevMonthLastDay - i}</div>`;
                calendarEl.appendChild(dayEl);
            }
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            for (let day = 1; day <= lastDay.getDate(); day++) {
                const dayEl = document.createElement('div');
                dayEl.className = 'calendar-day';
                
                const date = new Date(year, month, day);
                if (date.getTime() === today.getTime()) {
                    dayEl.classList.add('today');
                }
                
                if (appData.selectedCalendarDate && 
                    appData.selectedCalendarDate.getDate() === day &&
                    appData.selectedCalendarDate.getMonth() === month &&
                    appData.selectedCalendarDate.getFullYear() === year) {
                    dayEl.classList.add('selected');
                }
                
                // è·å–è¯¥æ—¥æœŸçš„ä»»åŠ¡æ•°é‡
                const tasksOnDate = getTasksOnDate(date);
                const totalTasks = tasksOnDate.overdue + tasksOnDate.today + tasksOnDate.future + tasksOnDate.completed;
                
                let indicators = '';
                if (tasksOnDate.overdue > 0) {
                    indicators += '<div class="task-indicator indicator-overdue"></div>';
                }
                if (tasksOnDate.today > 0) {
                    indicators += '<div class="task-indicator indicator-today"></div>';
                }
                if (tasksOnDate.future > 0) {
                    indicators += '<div class="task-indicator indicator-future"></div>';
                }
                if (tasksOnDate.completed > 0) {
                    indicators += '<div class="task-indicator indicator-completed"></div>';
                }
                
                // æ·»åŠ ä»»åŠ¡æ•°é‡æŒ‡ç¤ºå™¨
                let taskCountIndicator = '';
                if (totalTasks > 0) {
                    taskCountIndicator = `<div class="task-count-indicator">${totalTasks}</div>`;
                }
                
                dayEl.innerHTML = `
                    <div class="day-number">${day}</div>
                    ${indicators}
                    ${taskCountIndicator}
                `;
                
                dayEl.addEventListener('click', () => showDateTasks(date));
                calendarEl.appendChild(dayEl);
            }
            
            const totalCells = 42;
            const filledCells = firstDayIndex + lastDay.getDate();
            const remainingCells = totalCells - filledCells;
            
            for (let day = 1; day <= remainingCells; day++) {
                const dayEl = document.createElement('div');
                dayEl.className = 'calendar-day other-month';
                dayEl.innerHTML = `<div class="day-number">${day}</div>`;
                calendarEl.appendChild(dayEl);
            }
        }

        // æ—¥å†å¯¼èˆª
        function navigateCalendar(direction) {
            const currentDate = appData.currentCalendarDate;
            const newDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + direction, 1);
            appData.currentCalendarDate = newDate;
            renderCalendar();
        }

        // å›åˆ°ä»Šå¤©
        function goToToday() {
            appData.currentCalendarDate = new Date();
            appData.selectedCalendarDate = new Date();
            renderCalendar();
            showDateTasks(new Date());
        }

        // è·å–æŒ‡å®šæ—¥æœŸçš„ä»»åŠ¡
        function getTasksOnDate(date) {
            const result = {
                overdue: 0,
                today: 0,
                future: 0,
                completed: 0
            };
            
            appData.tasks.forEach(task => {
                if (task.status !== 'active') return;
                
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const targetDate = new Date(date);
                targetDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((targetDate - taskDate) / (1000 * 60 * 60 * 24));
                const taskSchedule = getTaskCheckinSchedule(task);
                
                const isCheckpointDay = taskSchedule.includes(daysSinceStart);
                if (isCheckpointDay) {
                    const checkpointIndex = taskSchedule.indexOf(daysSinceStart);
                    const hasCheckedIn = task.checkins.some(checkin => checkin.checkpointIndex === checkpointIndex);
                    
                    if (hasCheckedIn) {
                        result.completed++;
                    } else {
                        if (daysSinceStart < 0) {
                            result.future++;
                        } else if (daysSinceStart === 0) {
                            result.today++;
                        } else {
                            result.overdue++;
                        }
                    }
                }
            });
            
            return result;
        }

        // æ˜¾ç¤ºæŒ‡å®šæ—¥æœŸçš„ä»»åŠ¡
        function showDateTasks(date) {
            appData.selectedCalendarDate = date;
            renderCalendar();
            
            selectedDateTasksEl.innerHTML = '';
            
            const dateStr = date.toLocaleDateString();
            selectedDateTasksEl.innerHTML = `<h3>${dateStr} çš„ä»»åŠ¡</h3>`;
            
            let hasTasks = false;
            
            appData.tasks.forEach(task => {
                if (task.status !== 'active') return;
                
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const targetDate = new Date(date);
                targetDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((targetDate - taskDate) / (1000 * 60 * 60 * 24));
                const taskSchedule = getTaskCheckinSchedule(task);
                
                const checkpointIndex = taskSchedule.findIndex(day => day === daysSinceStart);
                
                if (checkpointIndex !== -1) {
                    hasTasks = true;
                    const checkpointDay = taskSchedule[checkpointIndex];
                    const isOverdue = daysSinceStart > checkpointDay;
                    const hasCheckedIn = task.checkins.some(checkin => checkin.checkpointIndex === checkpointIndex);
                    
                    const taskEl = document.createElement('div');
                    
                    let taskClass = 'task-item';
                    if (isOverdue) {
                        taskClass += ' overdue';
                    } else if (hasCheckedIn) {
                        taskClass += ' completed';
                    }
                    
                    taskEl.className = taskClass;
                    
                    let dayDisplay;
                    if (task.scheduleType === 'custom' || task.scheduleType === 'daily') {
                        const startDate = new Date(task.createDate);
                        const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                        dayDisplay = checkinDate.toLocaleDateString();
                    } else {
                        dayDisplay = `ç¬¬${checkpointDay}å¤©`;
                    }
                    
                    taskEl.innerHTML = `
                        <div class="task-header">
                            <div class="task-name">${task.subject} - ${task.name}</div>
                            <div class="task-status ${hasCheckedIn ? 'status-completed' : (isOverdue ? 'status-overdue' : 'status-today')}">
                                ${isOverdue ? `é€¾æœŸ${daysSinceStart - checkpointDay}å¤©` : dayDisplay} ${hasCheckedIn ? 'âœ“' : ''}
                            </div>
                        </div>
                        <p>${task.description || ''}</p>
                        <div class="task-actions">
                            ${!hasCheckedIn ? 
                                `<button class="btn btn-primary" onclick="startCheckin(${task.id}, ${checkpointIndex})">
                                    æ‰“å¡
                                </button>` : ''}
                        </div>
                    `;
                    
                    selectedDateTasksEl.appendChild(taskEl);
                }
            });
            
            if (!hasTasks) {
                selectedDateTasksEl.innerHTML += `
                    <div class="empty-state">
                        <i>ğŸ“…</i>
                        <p>è¿™ä¸€å¤©æ²¡æœ‰æ‰“å¡ä»»åŠ¡</p>
                    </div>
                `;
            }
        }

        // æ¸²æŸ“å½•éŸ³è®°å½•
        function renderRecordings() {
            recordingsListEl.innerHTML = '';
            
            if (appData.recordings.length === 0) {
                recordingsListEl.innerHTML = `
                    <div class="empty-state">
                        <i>ğŸ¤</i>
                        <p>è¿˜æ²¡æœ‰ä»»ä½•æ‰“å¡è®°å½•</p>
                    </div>
                `;
                return;
            }
            
            appData.recordings.forEach(recording => {
                const recordingEl = document.createElement('div');
                recordingEl.className = 'recording-item';
                
                const task = appData.tasks.find(t => t.id === recording.taskId);
                const taskName = task ? `${task.subject} - ${task.name}` : 'æœªçŸ¥ä»»åŠ¡';
                const taskSchedule = getTaskCheckinSchedule(task);
                const checkpointDay = taskSchedule[recording.checkpointIndex];
                
                let dayDisplay;
                if (task.scheduleType === 'custom' || task.scheduleType === 'daily') {
                    const startDate = new Date(task.createDate);
                    const checkinDate = new Date(startDate.getTime() + checkpointDay * 24 * 60 * 60 * 1000);
                    dayDisplay = checkinDate.toLocaleDateString();
                } else {
                    dayDisplay = `ç¬¬${checkpointDay}å¤©`;
                }
                
                const date = new Date(recording.date).toLocaleString();
                
                recordingEl.innerHTML = `
                    <div class="recording-info">
                        <div class="recording-name">${taskName} - ${dayDisplay}</div>
                        <div class="recording-duration">${date} | æ—¶é•¿: ${formatTime(recording.duration)}</div>
                    </div>
                    <div class="task-actions">
                        <button class="btn btn-secondary" onclick="playSavedRecording(${recording.id}, event)" id="play-saved-${recording.id}">æ’­æ”¾</button>
                    </div>
                `;
                
                recordingsListEl.appendChild(recordingEl);
            });
        }

        // å¼€å§‹æ‰“å¡
        function startCheckin(taskId, checkpointIndex = null) {
            const task = appData.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            appData.currentTask = task;
            
            if (checkpointIndex === null) {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((today - taskDate) / (1000 * 60 * 60 * 24));
                const taskSchedule = getTaskCheckinSchedule(task);
                checkpointIndex = taskSchedule.findIndex(day => day === daysSinceStart);
                
                if (checkpointIndex === -1) {
                    const overdueCheckpoints = [];
                    for (let i = 0; i < taskSchedule.length; i++) {
                        if (taskSchedule[i] < daysSinceStart && 
                            !task.checkins.some(checkin => checkin.checkpointIndex === i)) {
                            overdueCheckpoints.push({
                                index: i,
                                day: taskSchedule[i]
                            });
                        }
                    }
                    
                    overdueCheckpoints.sort((a, b) => a.day - b.day);
                    
                    if (overdueCheckpoints.length > 0) {
                        checkpointIndex = overdueCheckpoints[0].index;
                    }
                }
            }
            
            appData.currentCheckpointIndex = checkpointIndex;
            
            switchTab('recorder');
            
            updateRecorderTaskInfo();
            updateUploadTaskInfo();
            
            resetRecorder();
            resetUpload();
        }

        // å¼€å§‹å½•éŸ³
        async function startRecording() {
            if (!appData.currentTask) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªä»»åŠ¡ï¼');
                return;
            }
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                appData.mediaRecorder = new MediaRecorder(stream);
                appData.audioChunks = [];
                
                appData.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        appData.audioChunks.push(event.data);
                    }
                };
                
                appData.mediaRecorder.onstop = () => {
                    processRecording(stream);
                };
                
                appData.isRecording = true;
                appData.isPaused = false;
                appData.recordingTime = 0;
                
                recordBtn.classList.add('recording');
                pauseBtn.classList.remove('hidden');
                stopBtn.classList.remove('hidden');
                recordBtn.classList.add('hidden');
                
                updatePlaybackStatus('å½•éŸ³ä¸­...', 'status-recording');
                
                appData.mediaRecorder.start();
                
                appData.timerInterval = setInterval(() => {
                    appData.recordingTime += 10;
                    updateTimer();
                    updateWaveform();
                }, 10);
                
            } catch (error) {
                console.error('å½•éŸ³å¯åŠ¨å¤±è´¥:', error);
                alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
            }
        }

        // æš‚åœå½•éŸ³
        function togglePause() {
            if (!appData.mediaRecorder) return;
            
            if (appData.isPaused) {
                appData.mediaRecorder.resume();
                appData.isPaused = false;
                pauseBtn.innerHTML = 'âšâš';
                updatePlaybackStatus('å½•éŸ³ä¸­...', 'status-recording');
                
                appData.timerInterval = setInterval(() => {
                    appData.recordingTime += 10;
                    updateTimer();
                    updateWaveform();
                }, 10);
            } else {
                appData.mediaRecorder.pause();
                appData.isPaused = true;
                clearInterval(appData.timerInterval);
                pauseBtn.innerHTML = 'â–¶';
                updatePlaybackStatus('å½•éŸ³å·²æš‚åœ', 'status-playing');
                saveRecordingState();
            }
        }

        // åœæ­¢å½•éŸ³
        function stopRecording() {
            if (!appData.mediaRecorder || appData.mediaRecorder.state === 'inactive') return;
            
            appData.mediaRecorder.stop();
            appData.isRecording = false;
            appData.isPaused = false;
            
            clearInterval(appData.timerInterval);
            
            recordingStatusEl.classList.add('hidden');
        }

        // æ’­æ”¾å½•éŸ³
        function playRecording() {
            if (!appData.currentRecording) {
                console.log('æ²¡æœ‰å½“å‰å½•éŸ³å¯æ’­æ”¾');
                return;
            }
            
            if (appData.currentRecording.audioUrl) {
                audioPlayer.src = appData.currentRecording.audioUrl;
                audioPlayer.classList.remove('hidden');
                audioPlayer.play().catch(error => {
                    console.error('æ’­æ”¾å¤±è´¥:', error);
                    alert('æ’­æ”¾å½•éŸ³å¤±è´¥');
                });
            } else {
                alert('å½•éŸ³æ•°æ®ä¸å¯ç”¨ï¼Œå¯èƒ½å·²æŸå');
            }
        }

        // æäº¤å½•éŸ³
        function submitRecording() {
            if (!appData.currentRecording) {
                alert('è¯·å…ˆå®Œæˆå½•éŸ³ï¼');
                return;
            }
            
            const task = appData.tasks.find(t => t.id === appData.currentRecording.taskId);
            if (!task) return;
            
            const taskSchedule = getTaskCheckinSchedule(task);
            const alreadyCheckedIn = task.checkins.some(
                checkin => checkin.checkpointIndex === appData.currentRecording.checkpointIndex
            );
            
            if (alreadyCheckedIn) {
                alert('è¿™ä¸ªæ‰“å¡ç‚¹å·²ç»å®Œæˆè¿‡äº†ï¼');
                return;
            }
            
            task.checkins.push({
                checkpointIndex: appData.currentRecording.checkpointIndex,
                date: appData.currentRecording.date,
                recordingId: appData.currentRecording.id
            });
            
            if (task.checkins.length === taskSchedule.length) {
                task.status = 'completed';
                alert(`æ­å–œï¼ä»»åŠ¡"${task.name}"å·²å®Œæˆï¼`);
            } else {
                alert('æ‰“å¡æˆåŠŸï¼');
            }
            
            saveTasks();
            
            resetRecorder();
            renderRecordings();
            renderTodayTasks();
            renderAllTasks();
            renderCalendar();
            renderDataStats();
        }

        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('audio/')) {
                alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶ï¼');
                resetUpload();
                return;
            }
            
            if (file.size > 50 * 1024 * 1024) {
                alert('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡50MB');
                resetUpload();
                return;
            }
            
            fileNameEl.textContent = file.name;
            fileSizeEl.textContent = formatFileSize(file.size);
            fileDurationEl.textContent = 'è®¡ç®—ä¸­...';
            fileInfoEl.classList.remove('hidden');
            
            const tempAudio = new Audio();
            const tempUrl = URL.createObjectURL(file);
            tempAudio.src = tempUrl;
            
            tempAudio.addEventListener('loadedmetadata', () => {
                const duration = Math.floor(tempAudio.duration * 1000);
                fileDurationEl.textContent = formatTime(duration);
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    appData.uploadedAudio = {
                        file: file,
                        duration: duration,
                        audioData: e.target.result,
                        mimeType: file.type
                    };
                    
                    uploadedAudioPlayer.src = e.target.result;
                    uploadedAudioPlayer.classList.remove('hidden');
                    
                    submitUploadBtn.disabled = false;
                    
                    URL.revokeObjectURL(tempUrl);
                };
                reader.readAsDataURL(file);
            });
            
            tempAudio.addEventListener('error', () => {
                fileDurationEl.textContent = 'è®¡ç®—å¤±è´¥';
                alert('æ— æ³•è¯»å–éŸ³é¢‘æ–‡ä»¶ï¼Œè¯·é€‰æ‹©å…¶ä»–æ–‡ä»¶');
                resetUpload();
                URL.revokeObjectURL(tempUrl);
            });
        }

        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / 1048576).toFixed(1) + ' MB';
        }

        // æäº¤ä¸Šä¼ çš„éŸ³é¢‘
        async function submitUploadedAudio() {
            if (!appData.uploadedAudio || !appData.currentTask) return;
            
            try {
                // å°†Base64æ•°æ®è½¬æ¢ä¸ºBlob
                const response = await fetch(appData.uploadedAudio.audioData);
                const audioBlob = await response.blob();
                
                const recording = {
                    id: Date.now(),
                    taskId: appData.currentTask.id,
                    checkpointIndex: appData.currentCheckpointIndex,
                    date: new Date().toISOString(),
                    duration: appData.uploadedAudio.duration,
                    audioBlob: audioBlob,
                    mimeType: appData.uploadedAudio.mimeType,
                    source: 'upload',
                    size: audioBlob.size
                };
                
                // ä¿å­˜åˆ° IndexedDB
                await recordingStorage.saveRecording(recording);
                
                // åˆ›å»ºæ’­æ”¾URL
                recording.audioUrl = URL.createObjectURL(audioBlob);
                
                // æ›´æ–°åº”ç”¨çŠ¶æ€
                appData.currentRecording = recording;
                
                // ä»å†…å­˜ä¸­ç§»é™¤æ—§å½•éŸ³è®°å½•
                appData.recordings = appData.recordings.filter(r => 
                    r.taskId !== recording.taskId
                );
                
                // ä¿å­˜å…ƒæ•°æ®åˆ°å†…å­˜
                appData.recordings.push({
                    id: recording.id,
                    taskId: recording.taskId,
                    checkpointIndex: recording.checkpointIndex,
                    date: recording.date,
                    duration: recording.duration,
                    mimeType: recording.mimeType,
                    size: recording.size
                });

                // ä¿å­˜å…ƒæ•°æ®åˆ°LocalStorage
                saveRecordingsMetadata();
                
                const task = appData.tasks.find(t => t.id === recording.taskId);
                if (!task) return;
                
                const taskSchedule = getTaskCheckinSchedule(task);
                const alreadyCheckedIn = task.checkins.some(
                    checkin => checkin.checkpointIndex === recording.checkpointIndex
                );
                
                if (alreadyCheckedIn) {
                    alert('è¿™ä¸ªæ‰“å¡ç‚¹å·²ç»å®Œæˆè¿‡äº†ï¼');
                    return;
                }
                
                task.checkins.push({
                    checkpointIndex: recording.checkpointIndex,
                    date: recording.date,
                    recordingId: recording.id
                });
                
                if (task.checkins.length === taskSchedule.length) {
                    task.status = 'completed';
                    alert(`æ­å–œï¼ä»»åŠ¡"${task.name}"å·²å®Œæˆï¼`);
                } else {
                    alert('æ‰“å¡æˆåŠŸï¼');
                }
                
                saveTasks();
                
                resetUpload();
                renderRecordings();
                renderTodayTasks();
                renderAllTasks();
                renderCalendar();
                renderDataStats();
                
            } catch (error) {
                console.error('æäº¤ä¸Šä¼ éŸ³é¢‘å¤±è´¥:', error);
                alert('æäº¤å¤±è´¥: ' + error.message);
            }
        }

        // é‡ç½®ä¸Šä¼ ç•Œé¢
        function resetUpload() {
            audioFileInput.value = '';
            fileInfoEl.classList.add('hidden');
            uploadedAudioPlayer.classList.add('hidden');
            uploadedAudioPlayer.src = '';
            submitUploadBtn.disabled = true;
            appData.uploadedAudio = null;
        }

        // æ›´æ–°è®¡æ—¶å™¨
        function updateTimer() {
            timerEl.textContent = formatTime(appData.recordingTime);
        }

        // æ ¼å¼åŒ–æ—¶é—´
        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            const ms = Math.floor((milliseconds % 1000) / 10);
            
            if (hours > 0) {
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }

        // æ›´æ–°æ³¢å½¢å›¾
        function updateWaveform() {
            if (Math.random() < 0.3) {
                const bar = document.createElement('div');
                bar.className = 'waveform-bar';
                bar.style.height = `${10 + Math.random() * 80}px`;
                bar.style.left = `${Math.random() * 95}%`;
                waveformEl.appendChild(bar);
                
                if (waveformEl.children.length > 50) {
                    waveformEl.removeChild(waveformEl.firstChild);
                }
            }
        }

        // æ¸…ç©ºæ³¢å½¢å›¾
        function clearWaveform() {
            waveformEl.innerHTML = '';
        }

        // é‡ç½®å½•éŸ³å™¨
        function resetRecorder() {
            appData.isRecording = false;
            appData.isPaused = false;
            appData.recordingTime = 0;
            
            clearInterval(appData.timerInterval);
            
            recordBtn.classList.remove('recording', 'hidden');
            pauseBtn.classList.add('hidden');
            stopBtn.classList.add('hidden');
            playBtn.classList.add('hidden');
            submitRecordingBtn.disabled = true;
            
            audioPlayer.classList.add('hidden');
            audioPlayer.src = '';
            recordingStatusEl.classList.add('hidden');
            
            updateTimer();
            clearWaveform();
            clearRecordingState();
        }

        // æŸ¥çœ‹ä»»åŠ¡è¯¦æƒ…
        function viewTaskDetails(taskId) {
            const task = appData.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            appData.currentTask = task;
            
            const taskSchedule = getTaskCheckinSchedule(task);
            const checkinDetails = taskSchedule.map((day, index) => {
                const checkin = task.checkins.find(c => c.checkpointIndex === index);
                
                let status = checkin ? 'å®Œæˆ' : 'æœªå®Œæˆ';
                let statusIcon = checkin ? 'âœ…' : 'âŒ';
                let statusClass = checkin ? 'status-completed-icon' : 'status-missed-icon';
                
                let dayDisplay;
                let dateDisplay = '';
                if (task.scheduleType === 'custom' || task.scheduleType === 'daily') {
                    const startDate = new Date(task.createDate);
                    const checkinDate = new Date(startDate.getTime() + day * 24 * 60 * 60 * 1000);
                    dayDisplay = checkinDate.toLocaleDateString();
                    const weekdays = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
                    const weekday = weekdays[checkinDate.getDay()];
                    dateDisplay = ` (å‘¨${weekday})`;
                } else {
                    dayDisplay = `ç¬¬${day.toString().padStart(3, ' ')}å¤©`;
                    const startDate = new Date(task.createDate);
                    const checkinDate = new Date(startDate.getTime() + day * 24 * 60 * 60 * 1000);
                    const weekdays = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
                    const weekday = weekdays[checkinDate.getDay()];
                    dateDisplay = ` (${checkinDate.toLocaleDateString()} å‘¨${weekday})`;
                }
                
                return `
                    <div class="checkin-item">
                        <div class="checkin-day">${dayDisplay}${dateDisplay}:</div>
                        <div class="checkin-status">
                            <span class="status-icon ${statusClass}">${statusIcon}</span>
                            <span>${status}</span>
                        </div>
                    </div>
                `;
            }).join('');
            
            taskDetailsTitle.textContent = `${task.subject} - ${task.name}`;
            taskDetailsContent.innerHTML = `
                <div class="form-group">
                    <label>ä»»åŠ¡æè¿°</label>
                    <p>${task.description || 'æ— æè¿°'}</p>
                </div>
                <div class="form-group">
                    <label>åˆ›å»ºæ—¥æœŸ</label>
                    <p>${new Date(task.createDate).toLocaleDateString()}</p>
                </div>
                <div class="form-group">
                    <label>æ‰“å¡è®¡åˆ’ç±»å‹</label>
                    <p>${task.scheduleType === 'daily' ? 'æ¯æ—¥æ‰“å¡' : (task.scheduleType === 'custom' ? 'è‡ªå®šä¹‰æ—¥æœŸ' : 'é»˜è®¤è®¡åˆ’')}</p>
                </div>
                <div class="checkin-progress">
                    <h4>æ‰“å¡è¿›åº¦</h4>
                    ${checkinDetails}
                </div>
            `;
            
            taskDetailsModal.classList.remove('hidden');
        }

        // éšè—ä»»åŠ¡è¯¦æƒ…
        function hideTaskDetails() {
            taskDetailsModal.classList.add('hidden');
            appData.currentTask = null;
        }

        // åˆ é™¤ä»»åŠ¡
        async function deleteTask(taskId) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä»»åŠ¡å—ï¼Ÿæ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤ä»»åŠ¡åŠå…¶ç›¸å…³æ•°æ®ï¼Œä¸å¯æ¢å¤ï¼')) {
                // åˆ é™¤IndexedDBä¸­çš„å½•éŸ³æ•°æ®
                const taskRecordings = await recordingStorage.getRecordingsByTask(taskId);
                for (const recording of taskRecordings) {
                    await recordingStorage.deleteRecording(recording.id);
                }
                
                appData.tasks = appData.tasks.filter(t => t.id !== taskId);
                appData.recordings = appData.recordings.filter(r => r.taskId !== taskId);
                appData.feedbacks = appData.feedbacks.filter(f => f.taskId !== taskId);
                
                saveTasks();
                saveRecordingsMetadata();
                
                renderAllTasks();
                renderTodayTasks();
                renderCalendar();
                renderDataStats();
                renderRecordings();
            }
        }

        // æ•°æ®ç®¡ç†åŠŸèƒ½
        function showDataManagementModal() {
            dataManagementModal.classList.remove('hidden');
            updateDataStats();
        }

        function hideDataManagementModal() {
            dataManagementModal.classList.add('hidden');
        }

        function updateDataStats() {
            const totalTasks = appData.tasks.length;
            const completedTasks = appData.tasks.filter(task => {
                const taskSchedule = getTaskCheckinSchedule(task);
                return task.checkins.length === taskSchedule.length;
            }).length;
            
            // åªç»Ÿè®¡ä»Šå¤©çš„å½•éŸ³æ•°é‡
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const todayRecordings = appData.recordings.filter(recording => {
                const recordingDate = new Date(recording.date);
                recordingDate.setHours(0, 0, 0, 0);
                return recordingDate.getTime() === today.getTime();
            }).length;
            
            const dataSize = calculateDataSize();

            document.getElementById('stat-total-tasks').textContent = totalTasks;
            document.getElementById('stat-completed-tasks').textContent = completedTasks;
            document.getElementById('stat-total-recordings').textContent = todayRecordings;
            document.getElementById('stat-data-size').textContent = dataSize.totalSize;
        }

        function renderDataStats() {
            const totalTasks = appData.tasks.length;
            
            const completedTasks = appData.tasks.filter(task => {
                const taskSchedule = getTaskCheckinSchedule(task);
                return task.checkins.length === taskSchedule.length;
            }).length;
            
            // åªç»Ÿè®¡ä»Šå¤©çš„å½•éŸ³æ•°é‡
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const todayRecordings = appData.recordings.filter(recording => {
                const recordingDate = new Date(recording.date);
                recordingDate.setHours(0, 0, 0, 0);
                return recordingDate.getTime() === today.getTime();
            }).length;
            
            const totalDuration = appData.recordings.reduce((total, recording) => total + recording.duration, 0);
            const totalMinutes = Math.floor(totalDuration / 60000);
            
            const dataSize = calculateDataSize();

            document.getElementById('stats-total-tasks').textContent = totalTasks;
            document.getElementById('stats-completed-tasks').textContent = completedTasks;
            document.getElementById('stats-total-recordings').textContent = todayRecordings;
            document.getElementById('stats-total-duration').textContent = `${totalMinutes}åˆ†é’Ÿ`;
            document.getElementById('stats-data-size').textContent = dataSize.totalSize;
            
            showStorageWarning();
        }

        // è®¡ç®—æ•°æ®å¤§å°
        function calculateDataSize() {
            const tasksSize = JSON.stringify(appData.tasks).length;
            const recordingsSize = JSON.stringify(appData.recordings).length;
            const feedbacksSize = JSON.stringify(appData.feedbacks).length;
            const totalSizeBytes = tasksSize + recordingsSize + feedbacksSize;
            const totalSizeMB = (totalSizeBytes / (1024 * 1024)).toFixed(2);
            
            return {
                tasksSize: (tasksSize / 1024).toFixed(2) + ' KB',
                recordingsSize: (recordingsSize / 1024).toFixed(2) + ' KB',
                feedbacksSize: (feedbacksSize / 1024).toFixed(2) + ' KB',
                totalSize: totalSizeMB + ' MB',
                totalSizeBytes: totalSizeBytes
            };
        }

        // æ˜¾ç¤ºå­˜å‚¨è­¦å‘Š
        function showStorageWarning() {
            const dataSize = calculateDataSize();
            const totalSizeMB = parseFloat(dataSize.totalSize);
            
            storageSizeDisplayEl.textContent = dataSize.totalSize;
            storageWarningEl.classList.remove('hidden', 'low', 'medium', 'high');
            
            if (totalSizeMB > 5) {
                storageWarningEl.classList.add('high');
                storageSizeDisplayEl.classList.add('high');
                storageMessageEl.textContent = 'âš ï¸ æ•°æ®å­˜å‚¨é‡è¾ƒå¤§ï¼ˆè¶…è¿‡5MBï¼‰ï¼Œå»ºè®®åŠæ—¶æ¸…ç†æˆ–å¯¼å‡ºå¤‡ä»½æ•°æ®';
                storageWarningEl.classList.remove('hidden');
            } else if (totalSizeMB > 2) {
                storageWarningEl.classList.add('medium');
                storageSizeDisplayEl.classList.add('medium');
                storageMessageEl.textContent = 'æ•°æ®å­˜å‚¨é‡é€‚ä¸­ï¼Œå»ºè®®å®šæœŸå¯¼å‡ºå¤‡ä»½';
                storageWarningEl.classList.remove('hidden');
            } else {
                storageWarningEl.classList.add('low');
                storageSizeDisplayEl.classList.add('low');
                storageMessageEl.textContent = 'æ•°æ®å­˜å‚¨é‡æ­£å¸¸';
                storageWarningEl.classList.remove('hidden');
            }
        }

        async function exportData() {
            try {
                // ä»IndexedDBè·å–æ‰€æœ‰å½•éŸ³æ•°æ®
                const allRecordings = await recordingStorage.getAllRecordings();
                
                const exportData = {
                    version: '2.0',
                    exportDate: new Date().toISOString(),
                    tasks: appData.tasks,
                    recordings: allRecordings, // åŒ…å«å®Œæ•´çš„å½•éŸ³æ•°æ®
                    feedbacks: appData.feedbacks
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `å¤ä¹ æ‰“å¡è®¡åˆ’å¤‡ä»½_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                alert('æ•°æ®å¯¼å‡ºæˆåŠŸï¼');
                
            } catch (error) {
                console.error('å¯¼å‡ºæ•°æ®å¤±è´¥:', error);
                alert('å¯¼å‡ºæ•°æ®å¤±è´¥: ' + error.message);
            }
        }

        function handleImportFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.json')) {
                alert('è¯·é€‰æ‹©JSONæ ¼å¼çš„æ–‡ä»¶ï¼');
                resetImportFile();
                return;
            }
            
            importFileName.textContent = file.name;
            importFileSize.textContent = formatFileSize(file.size);
            importFileInfo.classList.remove('hidden');
            importDataBtn.disabled = false;
        }

        async function importData() {
            const file = importDataFile.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!importedData.tasks) {
                        throw new Error('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘ä»»åŠ¡æ•°æ®');
                    }
                    
                    if (!confirm('å¯¼å…¥æ•°æ®å°†è¦†ç›–å½“å‰æ‰€æœ‰æ•°æ®ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ')) {
                        return;
                    }
                    
                    // æ¸…ç©ºç°æœ‰æ•°æ®
                    const allRecordings = await recordingStorage.getAllRecordings();
                    for (const recording of allRecordings) {
                        await recordingStorage.deleteRecording(recording.id);
                    }
                    
                    appData.tasks = importedData.tasks;
                    appData.feedbacks = importedData.feedbacks || [];
                    
                    // å¯¼å…¥å½•éŸ³æ•°æ®åˆ°IndexedDB
                    if (importedData.recordings) {
                        for (const recording of importedData.recordings) {
                            await recordingStorage.saveRecording(recording);
                        }
                        
                        // æ›´æ–°å†…å­˜ä¸­çš„å½•éŸ³å…ƒæ•°æ®
                        appData.recordings = importedData.recordings.map(recording => ({
                            id: recording.id,
                            taskId: recording.taskId,
                            checkpointIndex: recording.checkpointIndex,
                            date: recording.date,
                            duration: recording.duration,
                            mimeType: recording.mimeType,
                            size: recording.size
                        }));
                    } else {
                        appData.recordings = [];
                    }
                    
                    cleanupOldRecordings();
                    
                    saveLocalData();
                    
                    appData.currentTask = null;
                    appData.currentRecording = null;
                    appData.selectedCalendarDate = null;
                    appData.editingTask = null;
                    appData.currentCheckpointIndex = null;
                    
                    renderTodayTasks();
                    renderAllTasks();
                    renderCalendar();
                    renderRecordings();
                    renderDataStats();
                    
                    hideDataManagementModal();
                    resetImportFile();
                    
                    alert('æ•°æ®å¯¼å…¥æˆåŠŸï¼');
                    
                } catch (error) {
                    console.error('æ•°æ®å¯¼å…¥å¤±è´¥:', error);
                    alert('æ•°æ®å¯¼å…¥å¤±è´¥ï¼š' + error.message);
                }
            };
            reader.onerror = function() {
                alert('æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•');
            };
            reader.readAsText(file);
        }

        function resetImportFile() {
            importDataFile.value = '';
            importFileInfo.classList.add('hidden');
            importDataBtn.disabled = true;
        }

        async function clearAllData() {
            if (!confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼')) {
                return;
            }
            
            if (!confirm('å†æ¬¡ç¡®è®¤ï¼šè¿™å°†åˆ é™¤æ‰€æœ‰ä»»åŠ¡ã€å½•éŸ³è®°å½•å’Œç‚¹è¯„ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ')) {
                return;
            }
            
            // æ¸…ç©ºIndexedDB
            const allRecordings = await recordingStorage.getAllRecordings();
            for (const recording of allRecordings) {
                await recordingStorage.deleteRecording(recording.id);
            }
            
            appData.tasks = [];
            appData.recordings = [];
            appData.feedbacks = [];
            
            localStorage.removeItem('checkinTasks');
            localStorage.removeItem('checkinRecordings');
            localStorage.removeItem('checkinFeedbacks');
            localStorage.removeItem('recordingState');
            localStorage.removeItem('lastCleanupDate');
            
            appData.currentTask = null;
            appData.currentRecording = null;
            appData.selectedCalendarDate = null;
            appData.editingTask = null;
            appData.currentCheckpointIndex = null;
            
            renderTodayTasks();
            renderAllTasks();
            renderCalendar();
            renderRecordings();
            renderDataStats();
            
            alert('æ‰€æœ‰æ•°æ®å·²æ¸…é™¤ï¼');
        }

        // åˆå§‹åŒ–åº”ç”¨
        window.onload = initApp;
    </script>
</body>
</html>