<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤ä¹ æ‰“å¡è®¡åˆ’</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .app-description {
            font-size: 14px;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            background: #f1f5f9;
            border-bottom: 1px solid #e2e8f0;
        }

        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .tab.active {
            background: white;
            color: #4facfe;
            border-bottom: 3px solid #4facfe;
        }

        .tab-content {
            display: none;
            padding: 20px;
            min-height: 500px;
        }

        .tab-content.active {
            display: block;
        }

        .task-list {
            margin-bottom: 20px;
        }

        .task-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border-left: 4px solid #4facfe;
            transition: transform 0.2s;
        }

        .task-item:hover {
            transform: translateY(-2px);
        }

        .task-item.overdue {
            border-left-color: #ff6b6b;
            background: #fff5f5;
        }

        .task-item.completed {
            border-left-color: #1dd1a1;
            background: #f0fff4;
        }

        .task-item.pending-review {
            border-left-color: #feca57;
            background: #fff9e6;
        }

        .task-item.needs-redo {
            border-left-color: #ff9f43;
            background: #fff9e6;
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .task-name {
            font-weight: 600;
            font-size: 18px;
        }

        .task-status {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            color: white;
        }

        .status-overdue {
            background: #ff6b6b;
        }

        .status-today {
            background: #4ecdc4;
        }

        .status-future {
            background: #45aaf2;
        }

        .status-completed {
            background: #1dd1a1;
        }

        .status-pending {
            background: #feca57;
        }

        .status-pending-review {
            background: #ff9ff3;
        }

        .status-rejected {
            background: #ff9f43;
        }

        .task-progress {
            margin: 10px 0;
        }

        .progress-bar {
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            border-radius: 4px;
            transition: width 0.5s;
        }

        .progress-text {
            font-size: 12px;
            color: #64748b;
            margin-top: 5px;
        }

        .task-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #4facfe;
            color: white;
        }

        .btn-primary:hover {
            background: #3a9bf7;
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #475569;
        }

        .btn-secondary:hover {
            background: #cbd5e1;
        }

        .btn-danger {
            background: #ff6b6b;
            color: white;
        }

        .btn-danger:hover {
            background: #ff5252;
        }

        .btn-warning {
            background: #ff9f43;
            color: white;
        }

        .btn-warning:hover {
            background: #ff8c2a;
        }

        .btn-disabled {
            background: #cbd5e1;
            color: #94a3b8;
            cursor: not-allowed;
        }

        .btn-disabled:hover {
            background: #cbd5e1;
        }

        .recorder-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }

        .recorder-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .recorder-display {
            text-align: center;
            margin: 20px 0;
        }

        .timer {
            font-size: 48px;
            font-weight: 700;
            color: #4facfe;
            margin: 20px 0;
        }

        .recorder-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .recorder-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .record-btn {
            background: #ff6b6b;
            color: white;
        }

        .record-btn.recording {
            animation: pulse 1.5s infinite;
        }

        .pause-btn {
            background: #feca57;
            color: white;
        }

        .stop-btn {
            background: #48dbfb;
            color: white;
        }

        .play-btn {
            background: #1dd1a1;
            color: white;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .waveform {
            height: 100px;
            background: #f8fafc;
            border-radius: 10px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 4px;
            background: #4facfe;
            border-radius: 2px 2px 0 0;
        }

        .recordings-list {
            margin-top: 20px;
        }

        .recording-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .recording-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .recording-name {
            font-weight: 600;
        }

        .recording-duration {
            font-size: 12px;
            color: #64748b;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px 0;
        }

        .calendar-nav {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .calendar-nav-btn {
            background: #4facfe;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .calendar-nav-btn:hover {
            background: #3a9bf7;
        }

        .calendar-title {
            font-size: 18px;
            font-weight: 600;
            color: #475569;
        }

        .calendar {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .calendar-weekday {
            text-align: center;
            font-weight: 600;
            padding: 10px 0;
            color: #475569;
            background: #f8fafc;
            border-radius: 5px;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            padding: 5px;
            position: relative;
            border: 2px solid transparent;
        }

        .calendar-day:hover {
            background: #f1f5f9;
        }

        .calendar-day.active {
            background: #4facfe;
            color: white;
        }

        .calendar-day.selected {
            background: #ff6b6b;
            color: white;
            border-color: #ff6b6b;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .calendar-day.today {
            border-color: #ff6b6b;
        }

        .calendar-day.other-month {
            color: #cbd5e1;
        }

        .day-number {
            font-size: 16px;
            font-weight: 600;
        }

        .task-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-top: 2px;
        }

        .indicator-overdue {
            background: #ff6b6b;
        }

        .indicator-today {
            background: #4ecdc4;
        }

        .indicator-future {
            background: #45aaf2;
        }

        .indicator-completed {
            background: #1dd1a1;
        }

        .indicator-pending-review {
            background: #ff9ff3;
        }

        .indicator-rejected {
            background: #ff9f43;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #475569;
        }

        input, textarea, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            font-size: 16px;
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #64748b;
        }

        .empty-state i {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .hidden {
            display: none;
        }

        .checkin-history {
            margin-top: 10px;
        }

        .history-item {
            padding: 8px 12px;
            border-left: 3px solid #4facfe;
            background: #f8fafc;
            margin-bottom: 8px;
            border-radius: 0 8px 8px 0;
            font-size: 12px;
        }

        .history-date {
            font-weight: 600;
            margin-bottom: 3px;
        }

        .history-status {
            font-size: 11px;
            color: #64748b;
        }

        .status-completed {
            color: #1dd1a1;
        }

        .status-pending {
            color: #feca57;
        }

        .status-missed {
            color: #ff6b6b;
        }

        .status-pending-review {
            color: #ff9ff3;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #64748b;
            font-size: 14px;
            border-top: 1px solid #e2e8f0;
        }

        .task-form-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .audio-player {
            width: 100%;
            margin: 10px 0;
        }

        .recording-status {
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-weight: 600;
        }

        .status-recording {
            background: #fff5f5;
            color: #ff6b6b;
        }

        .status-playing {
            background: #f0fff4;
            color: #1dd1a1;
        }

        .last-recording-time {
            font-size: 12px;
            color: #64748b;
            margin-top: 5px;
        }

        .edit-task-form {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .compact-checkin-info {
            font-size: 12px;
            color: #64748b;
            margin-top: 5px;
        }

        .compact-checkin-item {
            display: inline-block;
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 5px;
            margin-bottom: 3px;
        }
        
        .upload-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .upload-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .upload-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-input-btn {
            display: block;
            padding: 12px 20px;
            background: #4facfe;
            color: white;
            border-radius: 6px;
            text-align: center;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .file-input-btn:hover {
            background: #3a9bf7;
        }
        
        .file-info {
            margin-top: 10px;
            padding: 10px;
            background: #f8fafc;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .recorder-mode-selector {
            display: flex;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #cbd5e1;
        }
        
        .recorder-mode {
            flex: 1;
            padding: 12px;
            text-align: center;
            background: #f8fafc;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .recorder-mode.active {
            background: #4facfe;
            color: white;
        }
        
        .uploaded-audio-player {
            width: 100%;
            margin: 15px 0;
        }

        .data-management-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .data-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .data-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border-left: 4px solid #4facfe;
        }

        .stat-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .stat-number {
            font-size: 24px;
            font-weight: 700;
            color: #4facfe;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: #64748b;
        }

        .instructions-list {
            padding-left: 20px;
            margin-top: 10px;
        }

        .instructions-list li {
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .modal-header h3 {
            margin: 0;
            color: #475569;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #64748b;
        }

        .close-btn:hover {
            color: #475569;
        }

        .modal-body {
            padding: 20px;
        }

        .data-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .data-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .data-section h4 {
            margin-bottom: 10px;
            color: #475569;
        }

        .data-section p {
            margin-bottom: 15px;
            color: #64748b;
            font-size: 14px;
        }

        .data-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f1f5f9;
        }

        .stat-label {
            color: #64748b;
            font-size: 14px;
        }

        .stat-value {
            font-weight: 600;
            color: #475569;
        }

        .hidden {
            display: none !important;
        }

        .subject-chinese {
            color: #4facfe;
        }

        .subject-math {
            color: #764ba2;
        }

        .subject-english {
            color: #ff6b6b;
        }

        .subject-science {
            color: #1dd1a1;
        }

        .subject-other {
            color: #feca57;
        }

        .task-details-modal {
            max-width: 600px;
        }

        .checkin-progress {
            margin-top: 15px;
        }

        .checkin-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f1f5f9;
        }

        .checkin-day {
            font-weight: 600;
            width: 80px;
        }

        .checkin-status {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-icon {
            font-size: 16px;
        }

        .status-completed-icon {
            color: #1dd1a1;
        }

        .status-pending-icon {
            color: #feca57;
        }

        .status-missed-icon {
            color: #ff6b6b;
        }

        .today-tasks-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
        }

        .tasks-count {
            background: #4facfe;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .rejection-reason {
            font-size: 12px;
            color: #ff6b6b;
            margin-top: 5px;
            padding: 5px;
            background: #fff5f5;
            border-radius: 4px;
            border-left: 3px solid #ff6b6b;
        }

        .redo-notice {
            background: #fff9e6;
            border: 1px solid #ff9f43;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 14px;
            width: 100%;
        }

        .redo-notice h4 {
            color: #ff9f43;
            margin-bottom: 5px;
        }

        .storage-warning {
            background: #fff5f5;
            border: 2px solid #ff6b6b;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .storage-warning.high {
            background: #fff5f5;
            border-color: #ff6b6b;
            animation: pulse-warning 2s infinite;
        }

        .storage-warning.medium {
            background: #fff9e6;
            border-color: #feca57;
        }

        .storage-warning.low {
            background: #f0fff4;
            border-color: #1dd1a1;
        }

        @keyframes pulse-warning {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .storage-size {
            font-weight: 700;
            font-size: 18px;
            margin: 5px 0;
        }

        .storage-size.high {
            color: #ff6b6b;
        }

        .storage-size.medium {
            color: #feca57;
        }

        .storage-size.low {
            color: #1dd1a1;
        }

        .rejection-history {
            margin-top: 10px;
            padding: 10px;
            background: #f8fafc;
            border-radius: 6px;
        }

        .rejection-history-item {
            padding: 8px;
            margin-bottom: 5px;
            background: white;
            border-radius: 4px;
            border-left: 3px solid #ff9f43;
        }

        .rejection-date {
            font-size: 11px;
            color: #64748b;
        }

        .rejection-reason-text {
            font-size: 12px;
            color: #475569;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>å¤ä¹ æ‰“å¡è®¡åˆ’</h1>
            <p class="app-description">æ—¥ç§¯æœˆç´¯ã€æŒä¹‹ä»¥æ’ï¼Œå†²åˆº100åˆ†</p>
        </header>

        <div class="tabs">
            <div class="tab active" data-tab="today">ä»Šæ—¥ä»»åŠ¡</div>
            <div class="tab" data-tab="tasks">ä»»åŠ¡ç®¡ç†</div>
            <div class="tab" data-tab="calendar">æ—¥å†è§†å›¾</div>
            <div class="tab" data-tab="recorder">å½•éŸ³æ‰“å¡</div>
            <div class="tab" data-tab="data">æ•°æ®ç®¡ç†</div>
        </div>

        <div class="tab-content active" id="today-tab">
            <div class="today-tasks-header">
                <h2>ä»Šæ—¥ä»»åŠ¡</h2>
                <div class="tasks-count" id="today-tasks-count">0 ä¸ªä»»åŠ¡</div>
            </div>
            <div class="task-list" id="today-tasks">
                <!-- ä»Šæ—¥ä»»åŠ¡å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <div class="tab-content" id="tasks-tab">
            <h2>ä»»åŠ¡ç®¡ç†</h2>
            
            <div id="task-form" class="task-form-container hidden">
                <h3>æ–°å»ºä»»åŠ¡</h3>
                <div class="form-group">
                    <label for="task-subject">ç§‘ç›®</label>
                    <select id="task-subject">
                        <option value="è¯­æ–‡">è¯­æ–‡</option>
                        <option value="æ•°å­¦">æ•°å­¦</option>
                        <option value="è‹±è¯­">è‹±è¯­</option>
                        <option value="ç§‘å­¦">ç§‘å­¦</option>
                        <option value="å…¶ä»–">å…¶ä»–</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="task-name">ä»»åŠ¡åç§°</label>
                    <input type="text" id="task-name" placeholder="è¾“å…¥ä»»åŠ¡åç§°">
                </div>
                <div class="form-group">
                    <label for="task-desc">ä»»åŠ¡æè¿°</label>
                    <textarea id="task-desc" placeholder="è¾“å…¥ä»»åŠ¡æè¿°ï¼ˆå¯é€‰ï¼‰"></textarea>
                </div>
                <div class="form-group">
                    <label for="task-date">å¼€å§‹æ—¥æœŸ</label>
                    <input type="date" id="task-date">
                </div>
                <div class="task-actions">
                    <button class="btn btn-primary" id="save-task">ä¿å­˜ä»»åŠ¡</button>
                    <button class="btn btn-secondary" id="cancel-task">å–æ¶ˆ</button>
                </div>
            </div>

            <div id="edit-task-form" class="edit-task-form hidden">
                <h3>ç¼–è¾‘ä»»åŠ¡</h3>
                <div class="form-group">
                    <label for="edit-task-subject">ç§‘ç›®</label>
                    <select id="edit-task-subject">
                        <option value="è¯­æ–‡">è¯­æ–‡</option>
                        <option value="æ•°å­¦">æ•°å­¦</option>
                        <option value="è‹±è¯­">è‹±è¯­</option>
                        <option value="ç§‘å­¦">ç§‘å­¦</option>
                        <option value="å…¶ä»–">å…¶ä»–</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="edit-task-name">ä»»åŠ¡åç§°</label>
                    <input type="text" id="edit-task-name" placeholder="è¾“å…¥ä»»åŠ¡åç§°">
                </div>
                <div class="form-group">
                    <label for="edit-task-desc">ä»»åŠ¡æè¿°</label>
                    <textarea id="edit-task-desc" placeholder="è¾“å…¥ä»»åŠ¡æè¿°ï¼ˆå¯é€‰ï¼‰"></textarea>
                </div>
                <div class="task-actions">
                    <button class="btn btn-primary" id="update-task">æ›´æ–°ä»»åŠ¡</button>
                    <button class="btn btn-secondary" id="cancel-edit-task">å–æ¶ˆ</button>
                </div>
            </div>
            
            <button class="btn btn-primary" id="add-task-btn">æ–°å»ºä»»åŠ¡</button>
            
            <div class="task-list" id="all-tasks">
                <!-- æ‰€æœ‰ä»»åŠ¡å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <div class="tab-content" id="calendar-tab">
            <h2>æ—¥å†è§†å›¾</h2>
            <div class="calendar-header">
                <div class="calendar-nav">
                    <button class="calendar-nav-btn" id="prev-month">â†</button>
                    <button class="calendar-nav-btn" id="next-month">â†’</button>
                </div>
                <div class="calendar-title" id="calendar-title"></div>
                <button class="btn btn-secondary" id="today-btn">ä»Šå¤©</button>
            </div>
            <div class="calendar" id="calendar">
                <!-- æ—¥å†å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
            <div class="checkin-history" id="selected-date-tasks">
                <!-- é€‰ä¸­æ—¥æœŸçš„ä»»åŠ¡å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <div class="tab-content" id="recorder-tab">
            <h2>å½•éŸ³æ‰“å¡</h2>
            
            <div class="recorder-mode-selector">
                <div class="recorder-mode active" data-mode="record">å®æ—¶å½•éŸ³</div>
                <div class="recorder-mode" data-mode="upload">ä¸Šä¼ å½•éŸ³</div>
            </div>
            
            <div class="recorder-container" id="record-container">
                <div class="recorder-header">
                    <h3 id="recorder-task-name">é€‰æ‹©ä»»åŠ¡è¿›è¡Œæ‰“å¡</h3>
                    <p id="recorder-checkpoint">è¯·å…ˆä»ä»Šæ—¥ä»»åŠ¡ä¸­é€‰æ‹©ä¸€ä¸ªä»»åŠ¡</p>
                </div>
                
                <div class="recording-status hidden" id="recording-status"></div>
                
                <div class="recorder-display">
                    <div class="timer" id="timer">00:00:00</div>
                    <div class="waveform" id="waveform">
                        <!-- æ³¢å½¢å›¾å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
                
                <div class="recorder-controls">
                    <button class="recorder-btn record-btn" id="record-btn" title="å¼€å§‹å½•éŸ³">
                        â—
                    </button>
                    <button class="recorder-btn pause-btn hidden" id="pause-btn" title="æš‚åœ">
                        âšâš
                    </button>
                    <button class="recorder-btn stop-btn hidden" id="stop-btn" title="åœæ­¢">
                        â– 
                    </button>
                    <button class="recorder-btn play-btn hidden" id="play-btn" title="æ’­æ”¾">
                        â–¶
                    </button>
                </div>

                <audio id="audio-player" class="audio-player hidden" controls></audio>
                
                <div class="task-actions">
                    <button class="btn btn-primary" id="submit-recording" disabled>æäº¤æ‰“å¡</button>
                    <button class="btn btn-secondary" id="reset-recorder">é‡ç½®</button>
                </div>
            </div>
            
            <div class="upload-container hidden" id="upload-container">
                <div class="upload-header">
                    <h3 id="upload-task-name">é€‰æ‹©ä»»åŠ¡è¿›è¡Œæ‰“å¡</h3>
                    <p id="upload-checkpoint">è¯·å…ˆä»ä»Šæ—¥ä»»åŠ¡ä¸­é€‰æ‹©ä¸€ä¸ªä»»åŠ¡</p>
                </div>
                
                <div class="upload-controls">
                    <div class="file-input-wrapper">
                        <div class="file-input-btn">é€‰æ‹©å½•éŸ³æ–‡ä»¶</div>
                        <input type="file" id="audio-file" accept="audio/*">
                    </div>
                    
                    <div class="file-info hidden" id="file-info">
                        <div>æ–‡ä»¶å: <span id="file-name"></span></div>
                        <div>æ–‡ä»¶å¤§å°: <span id="file-size"></span></div>
                        <div>æ—¶é•¿: <span id="file-duration">è®¡ç®—ä¸­...</span></div>
                    </div>
                    
                    <audio id="uploaded-audio-player" class="uploaded-audio-player hidden" controls></audio>
                </div>
                
                <div class="task-actions">
                    <button class="btn btn-primary" id="submit-upload" disabled>æäº¤æ‰“å¡</button>
                    <button class="btn btn-secondary" id="reset-upload">é‡ç½®</button>
                </div>
            </div>
            
            <div class="recordings-list" id="recordings-list">
                <h3>æ‰“å¡è®°å½•</h3>
                <!-- å½•éŸ³è®°å½•å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <div class="tab-content" id="data-tab">
            <h2>æ•°æ®ç®¡ç†</h2>
            
            <div class="data-management-container">
                <div class="data-card">
                    <h3>æ•°æ®å¤‡ä»½ä¸åŒæ­¥</h3>
                    <p>å°†æ‚¨çš„å­¦ä¹ æ•°æ®å¯¼å‡ºä¸ºæ–‡ä»¶ï¼Œç„¶åå¯ä»¥åœ¨å…¶ä»–è®¾å¤‡ä¸Šå¯¼å…¥ï¼Œå®ç°æ•°æ®åŒæ­¥ã€‚</p>
                    
                    <div class="data-actions">
                        <button class="btn btn-primary" id="show-data-modal">ç®¡ç†æ•°æ®</button>
                        <button class="btn btn-secondary" id="clear-data-btn">æ¸…é™¤æ‰€æœ‰æ•°æ®</button>
                    </div>
                </div>
                
                <div class="data-card">
                    <h3>æ•°æ®ç»Ÿè®¡</h3>
                    <div id="storage-warning" class="storage-warning hidden">
                        <h4>âš ï¸ å­˜å‚¨ç©ºé—´è­¦å‘Š</h4>
                        <div class="storage-size" id="storage-size-display">0 MB</div>
                        <p id="storage-message">å½“å‰æ•°æ®å­˜å‚¨é‡è¾ƒå¤§ï¼Œå»ºè®®åŠæ—¶æ¸…ç†æˆ–å¯¼å‡ºå¤‡ä»½</p>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-icon">ğŸ“</div>
                            <div class="stat-number" id="stats-total-tasks">0</div>
                            <div class="stat-label">æ€»ä»»åŠ¡æ•°</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">âœ…</div>
                            <div class="stat-number" id="stats-completed-tasks">0</div>
                            <div class="stat-label">å·²å®Œæˆ</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">ğŸ¤</div>
                            <div class="stat-number" id="stats-total-recordings">0</div>
                            <div class="stat-label">å½•éŸ³æ€»æ•°</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">â±ï¸</div>
                            <div class="stat-number" id="stats-total-duration">0</div>
                            <div class="stat-label">æ€»å½•éŸ³æ—¶é•¿</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">ğŸ“Š</div>
                            <div class="stat-number" id="stats-data-size">0 MB</div>
                            <div class="stat-label">æ•°æ®å¤§å°</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">ğŸ”„</div>
                            <div class="stat-number" id="stats-rejected-count">0</div>
                            <div class="stat-label">éœ€é‡åš</div>
                        </div>
                    </div>
                </div>
                
                <div class="data-card">
                    <h3>ä½¿ç”¨è¯´æ˜</h3>
                    <ol class="instructions-list">
                        <li>ç‚¹å‡»"ç®¡ç†æ•°æ®"æŒ‰é’®æ‰“å¼€æ•°æ®ç®¡ç†é¢æ¿</li>
                        <li>ä½¿ç”¨"å¯¼å‡ºæ•°æ®"åŠŸèƒ½å°†æ•°æ®ä¿å­˜ä¸ºJSONæ–‡ä»¶</li>
                        <li>åœ¨å…¶ä»–è®¾å¤‡ä¸Šæ‰“å¼€æœ¬åº”ç”¨ï¼Œä½¿ç”¨"å¯¼å…¥æ•°æ®"åŠŸèƒ½</li>
                        <li>é€‰æ‹©ä¹‹å‰å¯¼å‡ºçš„JSONæ–‡ä»¶å®Œæˆæ•°æ®åŒæ­¥</li>
                        <li>æ³¨æ„ï¼šå¯¼å…¥æ•°æ®å°†è¦†ç›–å½“å‰è®¾å¤‡ä¸Šçš„æ‰€æœ‰æ•°æ®</li>
                    </ol>
                </div>
            </div>
        </div>

        <footer>
            <p>å¤ä¹ æ‰“å¡è®¡åˆ’ &copy; 2023 - ç¬¬180å¤©æ‰“å¡å®Œæˆåä»»åŠ¡å®Œæˆ</p>
        </footer>
    </div>

    <!-- æ•°æ®ç®¡ç†æ¨¡æ€æ¡† -->
    <div id="data-management-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>æ•°æ®ç®¡ç†</h3>
                <button class="close-btn" id="close-data-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="data-section">
                    <h4>å¯¼å‡ºæ•°æ®</h4>
                    <p>å°†æ‚¨çš„ä»»åŠ¡å’Œæ‰“å¡è®°å½•å¯¼å‡ºä¸ºJSONæ–‡ä»¶ï¼Œç”¨äºå¤‡ä»½æˆ–è¿ç§»åˆ°å…¶ä»–è®¾å¤‡ã€‚</p>
                    <button class="btn btn-primary" id="export-data-btn">å¯¼å‡ºæ•°æ®</button>
                </div>
                
                <div class="data-section">
                    <h4>å¯¼å…¥æ•°æ®</h4>
                    <p>ä»JSONæ–‡ä»¶å¯¼å…¥ä»»åŠ¡å’Œæ‰“å¡è®°å½•ï¼Œå°†è¦†ç›–å½“å‰è®¾å¤‡ä¸Šçš„æ‰€æœ‰æ•°æ®ã€‚</p>
                    <div class="file-input-wrapper">
                        <div class="file-input-btn">é€‰æ‹©æ•°æ®æ–‡ä»¶</div>
                        <input type="file" id="import-data-file" accept=".json">
                    </div>
                    <div class="file-info hidden" id="import-file-info">
                        <div>æ–‡ä»¶å: <span id="import-file-name"></span></div>
                        <div>æ–‡ä»¶å¤§å°: <span id="import-file-size"></span></div>
                    </div>
                    <button class="btn btn-danger" id="import-data-btn" disabled>å¯¼å…¥æ•°æ®</button>
                </div>
                
                <div class="data-section">
                    <h4>æ•°æ®ç»Ÿè®¡</h4>
                    <div class="data-stats">
                        <div class="stat-item">
                            <span class="stat-label">ä»»åŠ¡æ€»æ•°:</span>
                            <span class="stat-value" id="stat-total-tasks">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">å·²å®Œæˆä»»åŠ¡:</span>
                            <span class="stat-value" id="stat-completed-tasks">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">æ‰“å¡è®°å½•:</span>
                            <span class="stat-value" id="stat-total-recordings">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">å¾…éªŒæ”¶å½•éŸ³:</span>
                            <span class="stat-value" id="stat-pending-recordings">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">éœ€é‡åšä»»åŠ¡:</span>
                            <span class="stat-value" id="stat-rejected-recordings">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">æ•°æ®å¤§å°:</span>
                            <span class="stat-value" id="stat-data-size">0 MB</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ä»»åŠ¡è¯¦æƒ…æ¨¡æ€æ¡† -->
    <div id="task-details-modal" class="modal hidden">
        <div class="modal-content task-details-modal">
            <div class="modal-header">
                <h3 id="task-details-title">ä»»åŠ¡è¯¦æƒ…</h3>
                <button class="close-btn" id="close-task-details">&times;</button>
            </div>
            <div class="modal-body">
                <div id="task-details-content">
                    <!-- ä»»åŠ¡è¯¦æƒ…å†…å®¹å°†é€šè¿‡JavaScriptåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
        </div>
    </div>

    <!-- éªŒæ”¶ç¡®è®¤æ¨¡æ€æ¡† -->
    <div id="approval-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>éªŒæ”¶ç¡®è®¤</h3>
                <button class="close-btn" id="close-approval-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="approval-password">è¯·è¾“å…¥éªŒæ”¶å¯†ç </label>
                    <input type="password" id="approval-password" placeholder="è¯·è¾“å…¥å¯†ç ">
                </div>
                <div class="task-actions">
                    <button class="btn btn-primary" id="confirm-approval">ç¡®è®¤</button>
                    <button class="btn btn-secondary" id="cancel-approval">å–æ¶ˆ</button>
                </div>
            </div>
        </div>
    </div>

    <!-- éªŒæ”¶ä¸åˆæ ¼æ¨¡æ€æ¡† -->
    <div id="rejection-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>éªŒæ”¶ä¸åˆæ ¼</h3>
                <button class="close-btn" id="close-rejection-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="rejection-reason">ä¸åˆæ ¼åŸå› </label>
                    <textarea id="rejection-reason" placeholder="è¯·è¾“å…¥éªŒæ”¶ä¸åˆæ ¼çš„å…·ä½“åŸå› ï¼ˆå¦‚ï¼šå½•éŸ³æ—¶é—´å¤ªçŸ­ã€å†…å®¹ä¸å®Œæ•´ã€å‘éŸ³ä¸æ¸…æ™°ç­‰ï¼‰..." rows="4"></textarea>
                </div>
                <div class="task-actions">
                    <button class="btn btn-danger" id="confirm-rejection">ç¡®è®¤ä¸åˆæ ¼</button>
                    <button class="btn btn-secondary" id="cancel-rejection">å–æ¶ˆ</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // åº”ç”¨æ•°æ®
        const appData = {
            tasks: [],
            recordings: [],
            currentTask: null,
            currentRecording: null,
            isRecording: false,
            isPaused: false,
            isPlaying: false,
            timerInterval: null,
            recordingTime: 0,
            mediaRecorder: null,
            audioChunks: [],
            audioContext: null,
            analyser: null,
            currentCalendarDate: new Date(),
            selectedCalendarDate: null,
            recordingState: null,
            editingTask: null,
            currentCheckpointIndex: null,
            uploadedAudio: null,
            currentMode: 'record',
            approvalPassword: "123456",
            pendingApprovalRecordingId: null,
            pendingRejectionRecordingId: null
        };

        // æ‰“å¡æ—¶é—´è¡¨
        const checkinSchedule = [1, 2, 3, 5, 8, 15, 30, 90, 180];

        // DOM å…ƒç´ 
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const todayTasksEl = document.getElementById('today-tasks');
        const todayTasksCountEl = document.getElementById('today-tasks-count');
        const allTasksEl = document.getElementById('all-tasks');
        const taskFormEl = document.getElementById('task-form');
        const editTaskFormEl = document.getElementById('edit-task-form');
        const addTaskBtn = document.getElementById('add-task-btn');
        const saveTaskBtn = document.getElementById('save-task');
        const cancelTaskBtn = document.getElementById('cancel-task');
        const updateTaskBtn = document.getElementById('update-task');
        const cancelEditTaskBtn = document.getElementById('cancel-edit-task');
        const calendarEl = document.getElementById('calendar');
        const calendarTitleEl = document.getElementById('calendar-title');
        const prevMonthBtn = document.getElementById('prev-month');
        const nextMonthBtn = document.getElementById('next-month');
        const todayBtn = document.getElementById('today-btn');
        const selectedDateTasksEl = document.getElementById('selected-date-tasks');
        const recorderTaskNameEl = document.getElementById('recorder-task-name');
        const recorderCheckpointEl = document.getElementById('recorder-checkpoint');
        const recordingStatusEl = document.getElementById('recording-status');
        const timerEl = document.getElementById('timer');
        const waveformEl = document.getElementById('waveform');
        const recordBtn = document.getElementById('record-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const playBtn = document.getElementById('play-btn');
        const audioPlayer = document.getElementById('audio-player');
        const submitRecordingBtn = document.getElementById('submit-recording');
        const resetRecorderBtn = document.getElementById('reset-recorder');
        const recordingsListEl = document.getElementById('recordings-list');
        
        const recordModeBtn = document.querySelector('.recorder-mode[data-mode="record"]');
        const uploadModeBtn = document.querySelector('.recorder-mode[data-mode="upload"]');
        const recordContainer = document.getElementById('record-container');
        const uploadContainer = document.getElementById('upload-container');
        const audioFileInput = document.getElementById('audio-file');
        const fileInfoEl = document.getElementById('file-info');
        const fileNameEl = document.getElementById('file-name');
        const fileSizeEl = document.getElementById('file-size');
        const fileDurationEl = document.getElementById('file-duration');
        const uploadedAudioPlayer = document.getElementById('uploaded-audio-player');
        const submitUploadBtn = document.getElementById('submit-upload');
        const resetUploadBtn = document.getElementById('reset-upload');
        const uploadTaskNameEl = document.getElementById('upload-task-name');
        const uploadCheckpointEl = document.getElementById('upload-checkpoint');

        const dataManagementModal = document.getElementById('data-management-modal');
        const closeDataModalBtn = document.getElementById('close-data-modal');
        const showDataModalBtn = document.getElementById('show-data-modal');
        const exportDataBtn = document.getElementById('export-data-btn');
        const importDataFile = document.getElementById('import-data-file');
        const importDataBtn = document.getElementById('import-data-btn');
        const importFileInfo = document.getElementById('import-file-info');
        const importFileName = document.getElementById('import-file-name');
        const importFileSize = document.getElementById('import-file-size');
        const clearDataBtn = document.getElementById('clear-data-btn');

        const taskDetailsModal = document.getElementById('task-details-modal');
        const taskDetailsTitle = document.getElementById('task-details-title');
        const taskDetailsContent = document.getElementById('task-details-content');
        const closeTaskDetailsBtn = document.getElementById('close-task-details');

        const approvalModal = document.getElementById('approval-modal');
        const approvalPasswordInput = document.getElementById('approval-password');
        const confirmApprovalBtn = document.getElementById('confirm-approval');
        const cancelApprovalBtn = document.getElementById('cancel-approval');
        const closeApprovalModalBtn = document.getElementById('close-approval-modal');

        const rejectionModal = document.getElementById('rejection-modal');
        const rejectionReasonInput = document.getElementById('rejection-reason');
        const confirmRejectionBtn = document.getElementById('confirm-rejection');
        const cancelRejectionBtn = document.getElementById('cancel-rejection');
        const closeRejectionModalBtn = document.getElementById('close-rejection-modal');

        const storageWarningEl = document.getElementById('storage-warning');
        const storageSizeDisplayEl = document.getElementById('storage-size-display');
        const storageMessageEl = document.getElementById('storage-message');

        // è®¡ç®—æ•°æ®å¤§å°
        function calculateDataSize() {
            const tasksSize = JSON.stringify(appData.tasks).length;
            const recordingsSize = JSON.stringify(appData.recordings).length;
            const totalSizeBytes = tasksSize + recordingsSize;
            const totalSizeMB = (totalSizeBytes / (1024 * 1024)).toFixed(2);
            
            return {
                tasksSize: (tasksSize / 1024).toFixed(2) + ' KB',
                recordingsSize: (recordingsSize / 1024).toFixed(2) + ' KB',
                totalSize: totalSizeMB + ' MB',
                totalSizeBytes: totalSizeBytes
            };
        }

        // æ˜¾ç¤ºå­˜å‚¨è­¦å‘Š
        function showStorageWarning() {
            const dataSize = calculateDataSize();
            const totalSizeMB = parseFloat(dataSize.totalSize);
            
            storageSizeDisplayEl.textContent = dataSize.totalSize;
            storageWarningEl.classList.remove('hidden', 'low', 'medium', 'high');
            
            if (totalSizeMB > 5) {
                // é«˜é£é™©ï¼šè¶…è¿‡5MB
                storageWarningEl.classList.add('high');
                storageSizeDisplayEl.classList.add('high');
                storageMessageEl.textContent = 'âš ï¸ æ•°æ®å­˜å‚¨é‡è¾ƒå¤§ï¼ˆè¶…è¿‡5MBï¼‰ï¼Œå»ºè®®ç«‹å³æ¸…ç†æˆ–å¯¼å‡ºå¤‡ä»½æ•°æ®';
                storageWarningEl.classList.remove('hidden');
            } else if (totalSizeMB > 2) {
                // ä¸­é£é™©ï¼š2-5MB
                storageWarningEl.classList.add('medium');
                storageSizeDisplayEl.classList.add('medium');
                storageMessageEl.textContent = 'æ•°æ®å­˜å‚¨é‡é€‚ä¸­ï¼Œå»ºè®®å®šæœŸå¯¼å‡ºå¤‡ä»½';
                storageWarningEl.classList.remove('hidden');
            } else {
                // ä½é£é™©ï¼šå°äº2MB
                storageWarningEl.classList.add('low');
                storageSizeDisplayEl.classList.add('low');
                storageMessageEl.textContent = 'æ•°æ®å­˜å‚¨é‡æ­£å¸¸';
                storageWarningEl.classList.remove('hidden');
            }
        }

        // ä»Base64æ•°æ®åˆ›å»ºå¯æ’­æ”¾çš„URL
        function createAudioUrlFromData(recording) {
            if (recording.audioData && !recording.audioUrl) {
                try {
                    const parts = recording.audioData.split(',');
                    if (parts.length < 2) {
                        console.error('Base64æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
                        return;
                    }
                    
                    const mimeType = parts[0].match(/:(.*?);/)[1];
                    const base64Data = parts[1];
                    
                    const byteCharacters = atob(base64Data);
                    const byteArrays = [];
                    
                    for (let offset = 0; offset < byteCharacters.length; offset += 512) {
                        const slice = byteCharacters.slice(offset, offset + 512);
                        
                        const byteNumbers = new Array(slice.length);
                        for (let i = 0; i < slice.length; i++) {
                            byteNumbers[i] = slice.charCodeAt(i);
                        }
                        
                        const byteArray = new Uint8Array(byteNumbers);
                        byteArrays.push(byteArray);
                    }
                    
                    const blob = new Blob(byteArrays, { type: mimeType });
                    recording.audioUrl = URL.createObjectURL(blob);
                } catch (error) {
                    console.error('åˆ›å»ºéŸ³é¢‘URLå¤±è´¥:', error);
                }
            }
        }

        // åŠ è½½å½•éŸ³æ•°æ®æ—¶æ¢å¤æ‰€æœ‰å½•éŸ³çš„URL
        function restoreRecordingUrls() {
            appData.recordings.forEach(recording => {
                createAudioUrlFromData(recording);
            });
        }

        // åˆå§‹åŒ–åº”ç”¨
        function initApp() {
            console.log('åˆå§‹åŒ–åº”ç”¨...');
            loadData();
            setupEventListeners();
            setupUploadEventListeners();
            setupDataManagementEventListeners();
            setupTaskDetailsEventListeners();
            setupApprovalEventListeners();
            setupRejectionEventListeners();
            
            restoreRecordingUrls();
            
            renderTodayTasks();
            renderAllTasks();
            renderCalendar();
            renderRecordings();
            renderDataStats();
            
            restoreRecordingState();
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            console.log('åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
        }

        // å¤„ç†é¡µé¢å¯è§æ€§å˜åŒ–
        function handleVisibilityChange() {
            if (document.hidden) {
                saveRecordingState();
            } else {
                restoreRecordingState();
            }
        }

        // ä¿å­˜å½•éŸ³çŠ¶æ€
        function saveRecordingState() {
            if (appData.isRecording || appData.currentRecording) {
                appData.recordingState = {
                    isRecording: appData.isRecording,
                    isPaused: appData.isPaused,
                    recordingTime: appData.recordingTime,
                    currentTask: appData.currentTask,
                    currentCheckpointIndex: appData.currentCheckpointIndex,
                    audioChunks: appData.audioChunks
                };
                localStorage.setItem('recordingState', JSON.stringify(appData.recordingState));
            }
        }

        // æ¢å¤å½•éŸ³çŠ¶æ€
        function restoreRecordingState() {
            const savedState = localStorage.getItem('recordingState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    
                    if (state.isRecording && !state.isPaused) {
                        if (confirm('æ£€æµ‹åˆ°æœªå®Œæˆçš„å½•éŸ³ï¼Œæ˜¯å¦æ¢å¤å½•éŸ³ï¼Ÿ')) {
                            appData.isRecording = state.isRecording;
                            appData.isPaused = state.isPaused;
                            appData.recordingTime = state.recordingTime;
                            appData.currentTask = state.currentTask;
                            appData.currentCheckpointIndex = state.currentCheckpointIndex;
                            appData.audioChunks = state.audioChunks || [];
                            
                            updateTimer();
                            recordBtn.classList.add('hidden');
                            pauseBtn.classList.remove('hidden');
                            stopBtn.classList.remove('hidden');
                            updatePlaybackStatus('å½•éŸ³å·²æ¢å¤ï¼Œç‚¹å‡»æš‚åœ', 'status-recording');
                            
                            switchTab('recorder');
                            resumeRecording();
                        } else {
                            clearRecordingState();
                        }
                    }
                } catch (e) {
                    console.error('æ¢å¤å½•éŸ³çŠ¶æ€å¤±è´¥:', e);
                    clearRecordingState();
                }
            }
        }

        // æ¢å¤å½•éŸ³
        async function resumeRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                appData.mediaRecorder = new MediaRecorder(stream);
                
                appData.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        appData.audioChunks.push(event.data);
                    }
                };
                
                appData.mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(appData.audioChunks, { type: 'audio/wav' });
                    
                    const reader = new FileReader();
                    reader.onload = function() {
                        const base64Audio = reader.result;
                        
                        const recording = {
                            id: Date.now(),
                            taskId: appData.currentTask.id,
                            checkpointIndex: appData.currentCheckpointIndex,
                            date: new Date().toISOString(),
                            duration: appData.recordingTime,
                            audioData: base64Audio,
                            mimeType: 'audio/wav'
                        };
                        
                        createAudioUrlFromData(recording);
                        
                        // åˆ é™¤åŒä¸€ä»»åŠ¡çš„æ‰€æœ‰æ—§å½•éŸ³
                        appData.recordings = appData.recordings.filter(r => 
                            r.taskId !== recording.taskId
                        );
                        
                        appData.recordings.push(recording);
                        saveRecordings();
                        
                        stream.getTracks().forEach(track => track.stop());
                        clearRecordingState();
                        
                        recordBtn.classList.remove('recording', 'hidden');
                        pauseBtn.classList.add('hidden');
                        stopBtn.classList.add('hidden');
                        playBtn.classList.remove('hidden');
                        submitRecordingBtn.disabled = false;
                        
                        audioPlayer.src = recording.audioUrl;
                        audioPlayer.classList.remove('hidden');
                        
                        alert('å½•éŸ³å·²ä¿å­˜ï¼ç­‰å¾…ç­¾æ”¶ç¡®è®¤ã€‚');
                        renderRecordings();
                        renderTodayTasks();
                        renderAllTasks();
                        renderDataStats();
                    };
                    reader.readAsDataURL(audioBlob);
                };
                
                appData.mediaRecorder.start();
                
                appData.timerInterval = setInterval(() => {
                    appData.recordingTime += 10;
                    updateTimer();
                    updateWaveform();
                }, 10);
                
            } catch (error) {
                console.error('æ¢å¤å½•éŸ³å¤±è´¥:', error);
                alert('æ— æ³•æ¢å¤å½•éŸ³ï¼Œè¯·é‡æ–°å¼€å§‹');
                resetRecorder();
            }
        }

        // æ¸…é™¤å½•éŸ³çŠ¶æ€
        function clearRecordingState() {
            localStorage.removeItem('recordingState');
            appData.recordingState = null;
        }

        // åŠ è½½æ•°æ®
        function loadData() {
            const savedTasks = localStorage.getItem('checkinTasks');
            const savedRecordings = localStorage.getItem('checkinRecordings');
            
            if (savedTasks) {
                try {
                    appData.tasks = JSON.parse(savedTasks);
                } catch (e) {
                    console.error('è§£æä»»åŠ¡æ•°æ®å¤±è´¥:', e);
                    appData.tasks = getDefaultTasks();
                }
            } else {
                appData.tasks = getDefaultTasks();
            }
            
            if (savedRecordings) {
                try {
                    appData.recordings = JSON.parse(savedRecordings);
                } catch (e) {
                    console.error('è§£æå½•éŸ³æ•°æ®å¤±è´¥:', e);
                    appData.recordings = [];
                }
            } else {
                appData.recordings = [];
            }
            
            saveTasks();
            saveRecordings();
        }

        // è·å–é»˜è®¤ä»»åŠ¡
        function getDefaultTasks() {
            return [
                {
                    id: 1,
                    subject: 'è‹±è¯­',
                    name: 'å­¦ä¹ è‹±è¯­',
                    description: 'æ¯å¤©å­¦ä¹ 30åˆ†é’Ÿè‹±è¯­',
                    createDate: new Date().toISOString(),
                    status: 'active',
                    checkins: []
                },
                {
                    id: 2,
                    subject: 'å…¶ä»–',
                    name: 'å¥èº«è®¡åˆ’',
                    description: 'æ¯å‘¨ä¸‰æ¬¡å¥èº«æˆ¿é”»ç‚¼',
                    createDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
                    status: 'active',
                    checkins: []
                }
            ];
        }

        // ä¿å­˜ä»»åŠ¡æ•°æ®
        function saveTasks() {
            try {
                localStorage.setItem('checkinTasks', JSON.stringify(appData.tasks));
            } catch (e) {
                console.error('ä¿å­˜ä»»åŠ¡æ•°æ®å¤±è´¥:', e);
            }
        }

        // ä¿å­˜å½•éŸ³æ•°æ®
        function saveRecordings() {
            try {
                const recordingsToSave = appData.recordings.map(recording => {
                    return {
                        id: recording.id,
                        taskId: recording.taskId,
                        checkpointIndex: recording.checkpointIndex,
                        date: recording.date,
                        duration: recording.duration,
                        audioData: recording.audioData,
                        mimeType: recording.mimeType,
                        source: recording.source,
                        status: recording.status,
                        rejectionReason: recording.rejectionReason,
                        rejectedAt: recording.rejectedAt
                    };
                });
                
                localStorage.setItem('checkinRecordings', JSON.stringify(recordingsToSave));
            } catch (e) {
                console.error('ä¿å­˜å½•éŸ³æ•°æ®å¤±è´¥:', e);
                if (e.name === 'QuotaExceededError') {
                    alert('å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œå»ºè®®å¯¼å‡ºæ•°æ®å¹¶æ¸…ç†');
                }
            }
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.getAttribute('data-tab');
                    switchTab(tabId);
                });
            });

            addTaskBtn.addEventListener('click', showTaskForm);
            saveTaskBtn.addEventListener('click', saveTask);
            cancelTaskBtn.addEventListener('click', hideTaskForm);
            updateTaskBtn.addEventListener('click', updateTask);
            cancelEditTaskBtn.addEventListener('click', hideEditTaskForm);

            prevMonthBtn.addEventListener('click', () => navigateCalendar(-1));
            nextMonthBtn.addEventListener('click', () => navigateCalendar(1));
            todayBtn.addEventListener('click', goToToday);

            recordBtn.addEventListener('click', startRecording);
            pauseBtn.addEventListener('click', togglePause);
            stopBtn.addEventListener('click', stopRecording);
            playBtn.addEventListener('click', playRecording);
            submitRecordingBtn.addEventListener('click', submitRecording);
            resetRecorderBtn.addEventListener('click', resetRecorder);
        }
        
        // è®¾ç½®ä¸Šä¼ ç›¸å…³äº‹ä»¶ç›‘å¬å™¨
        function setupUploadEventListeners() {
            recordModeBtn.addEventListener('click', () => switchRecorderMode('record'));
            uploadModeBtn.addEventListener('click', () => switchRecorderMode('upload'));
            
            audioFileInput.addEventListener('change', handleFileUpload);
            submitUploadBtn.addEventListener('click', submitUploadedAudio);
            resetUploadBtn.addEventListener('click', resetUpload);
        }

        // è®¾ç½®æ•°æ®ç®¡ç†äº‹ä»¶ç›‘å¬å™¨
        function setupDataManagementEventListeners() {
            showDataModalBtn.addEventListener('click', showDataManagementModal);
            closeDataModalBtn.addEventListener('click', hideDataManagementModal);
            exportDataBtn.addEventListener('click', exportData);
            importDataFile.addEventListener('change', handleImportFileSelect);
            importDataBtn.addEventListener('click', importData);
            clearDataBtn.addEventListener('click', clearAllData);
        }

        // è®¾ç½®ä»»åŠ¡è¯¦æƒ…äº‹ä»¶ç›‘å¬å™¨
        function setupTaskDetailsEventListeners() {
            closeTaskDetailsBtn.addEventListener('click', hideTaskDetails);
        }

        // è®¾ç½®éªŒæ”¶äº‹ä»¶ç›‘å¬å™¨
        function setupApprovalEventListeners() {
            confirmApprovalBtn.addEventListener('click', handleApproval);
            cancelApprovalBtn.addEventListener('click', hideApprovalModal);
            closeApprovalModalBtn.addEventListener('click', hideApprovalModal);
        }

        // è®¾ç½®éªŒæ”¶ä¸åˆæ ¼äº‹ä»¶ç›‘å¬å™¨
        function setupRejectionEventListeners() {
            confirmRejectionBtn.addEventListener('click', confirmRejection);
            cancelRejectionBtn.addEventListener('click', hideRejectionModal);
            closeRejectionModalBtn.addEventListener('click', hideRejectionModal);
        }

        // æ›´æ–°æ’­æ”¾çŠ¶æ€æ˜¾ç¤º
        function updatePlaybackStatus(message, statusClass) {
            recordingStatusEl.textContent = message;
            recordingStatusEl.className = 'recording-status ' + statusClass;
            recordingStatusEl.classList.remove('hidden');
        }

        // åˆ‡æ¢æ ‡ç­¾é¡µ
        function switchTab(tabId) {
            tabs.forEach(tab => {
                if (tab.getAttribute('data-tab') === tabId) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            tabContents.forEach(content => {
                if (content.id === `${tabId}-tab`) {
                    content.classList.add('active');
                } else {
                    content.classList.remove('active');
                }
            });

            if (tabId === 'today') {
                renderTodayTasks();
            } else if (tabId === 'tasks') {
                renderAllTasks();
            } else if (tabId === 'calendar') {
                renderCalendar();
            } else if (tabId === 'recorder') {
                renderRecordings();
            } else if (tabId === 'data') {
                renderDataStats();
            }
        }
        
        // åˆ‡æ¢å½•éŸ³æ¨¡å¼
        function switchRecorderMode(mode) {
            appData.currentMode = mode;
            
            if (mode === 'record') {
                recordModeBtn.classList.add('active');
                uploadModeBtn.classList.remove('active');
                recordContainer.classList.remove('hidden');
                uploadContainer.classList.add('hidden');
                
                if (appData.currentTask) {
                    recorderTaskNameEl.textContent = `${appData.currentTask.subject} - ${appData.currentTask.name}`;
                    const checkpointDay = checkinSchedule[appData.currentCheckpointIndex];
                    recorderCheckpointEl.textContent = `ç¬¬${checkpointDay}å¤©æ‰“å¡`;
                }
            } else {
                recordModeBtn.classList.remove('active');
                uploadModeBtn.classList.add('active');
                recordContainer.classList.add('hidden');
                uploadContainer.classList.remove('hidden');
                
                if (appData.currentTask) {
                    uploadTaskNameEl.textContent = `${appData.currentTask.subject} - ${appData.currentTask.name}`;
                    const checkpointDay = checkinSchedule[appData.currentCheckpointIndex];
                    uploadCheckpointEl.textContent = `ç¬¬${checkpointDay}å¤©æ‰“å¡`;
                }
            }
        }

        // æ˜¾ç¤ºä»»åŠ¡è¡¨å•
        function showTaskForm() {
            taskFormEl.classList.remove('hidden');
            hideEditTaskForm();
            document.getElementById('task-subject').value = 'è¯­æ–‡';
            document.getElementById('task-name').value = '';
            document.getElementById('task-desc').value = '';
            document.getElementById('task-date').valueAsDate = new Date();
            taskFormEl.scrollIntoView({ behavior: 'smooth' });
        }

        // éšè—ä»»åŠ¡è¡¨å•
        function hideTaskForm() {
            taskFormEl.classList.add('hidden');
        }

        // æ˜¾ç¤ºç¼–è¾‘ä»»åŠ¡è¡¨å•
        function showEditTaskForm(taskId) {
            const task = appData.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            appData.editingTask = task;
            editTaskFormEl.classList.remove('hidden');
            hideTaskForm();
            
            document.getElementById('edit-task-subject').value = task.subject;
            document.getElementById('edit-task-name').value = task.name;
            document.getElementById('edit-task-desc').value = task.description || '';
            editTaskFormEl.scrollIntoView({ behavior: 'smooth' });
        }

        // éšè—ç¼–è¾‘ä»»åŠ¡è¡¨å•
        function hideEditTaskForm() {
            editTaskFormEl.classList.add('hidden');
            appData.editingTask = null;
        }

        // ä¿å­˜ä»»åŠ¡
        function saveTask() {
            const subject = document.getElementById('task-subject').value;
            const name = document.getElementById('task-name').value.trim();
            const desc = document.getElementById('task-desc').value.trim();
            let date = document.getElementById('task-date').value;
            
            if (!name) {
                alert('è¯·è¾“å…¥ä»»åŠ¡åç§°');
                return;
            }
            
            if (!date) {
                date = new Date().toISOString().split('T')[0];
            }
            
            const newTask = {
                id: Date.now(),
                subject: subject,
                name: name,
                description: desc,
                createDate: date ? new Date(date).toISOString() : new Date().toISOString(),
                status: 'active',
                checkins: []
            };
            
            appData.tasks.push(newTask);
            saveTasks();
            hideTaskForm();
            renderAllTasks();
            renderTodayTasks();
            renderCalendar();
            renderDataStats();
        }

        // æ›´æ–°ä»»åŠ¡
        function updateTask() {
            if (!appData.editingTask) return;
            
            const subject = document.getElementById('edit-task-subject').value;
            const name = document.getElementById('edit-task-name').value.trim();
            const desc = document.getElementById('edit-task-desc').value.trim();
            
            if (!name) {
                alert('è¯·è¾“å…¥ä»»åŠ¡åç§°');
                return;
            }
            
            appData.editingTask.subject = subject;
            appData.editingTask.name = name;
            appData.editingTask.description = desc;
            
            saveTasks();
            hideEditTaskForm();
            renderAllTasks();
            renderTodayTasks();
            renderCalendar();
            renderDataStats();
        }

        // è·å–ä»»åŠ¡çš„ä¸Šæ¬¡å½•éŸ³ç”¨æ—¶
        function getLastRecordingDuration(task) {
            if (task.checkins.length === 0) return null;
            
            const latestCheckin = task.checkins.reduce((latest, current) => 
                new Date(current.date) > new Date(latest.date) ? current : latest
            );
            
            const recording = appData.recordings.find(r => r.id === latestCheckin.recordingId);
            return recording ? recording.duration : null;
        }

        // æ¸²æŸ“ä»Šæ—¥ä»»åŠ¡
        function renderTodayTasks() {
            todayTasksEl.innerHTML = '';
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            let tasksForToday = [];
            
            appData.tasks.forEach(task => {
                if (task.status !== 'active') return;
                
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((today - taskDate) / (1000 * 60 * 60 * 24));
                
                const checkpointIndex = checkinSchedule.findIndex(day => day === daysSinceStart);
                
                if (checkpointIndex !== -1) {
                    const hasCheckedIn = task.checkins.some(checkin => 
                        checkin.checkpointIndex === checkpointIndex
                    );
                    
                    const hasPendingRecording = appData.recordings.some(recording => 
                        recording.taskId === task.id && 
                        recording.checkpointIndex === checkpointIndex &&
                        !task.checkins.some(checkin => checkin.recordingId === recording.id) &&
                        recording.status !== 'rejected'
                    );
                    
                    tasksForToday.push({
                        task,
                        checkpointIndex,
                        daysSinceStart,
                        isOverdue: false,
                        hasCheckedIn,
                        hasPendingRecording
                    });
                }
                
                for (let i = 0; i < checkinSchedule.length; i++) {
                    const checkpointDay = checkinSchedule[i];
                    if (checkpointDay < daysSinceStart && 
                        !task.checkins.some(checkin => checkin.checkpointIndex === i)) {
                        
                        const hasPendingRecording = appData.recordings.some(recording => 
                            recording.taskId === task.id && 
                            recording.checkpointIndex === i &&
                            !task.checkins.some(checkin => checkin.recordingId === recording.id) &&
                            recording.status !== 'rejected'
                        );
                        
                        tasksForToday.push({
                            task,
                            checkpointIndex: i,
                            daysSinceStart,
                            isOverdue: true,
                            hasCheckedIn: false,
                            hasPendingRecording
                        });
                    }
                }
            });
            
            // æ›´æ–°ä»»åŠ¡æ•°é‡æ˜¾ç¤º
            todayTasksCountEl.textContent = `${tasksForToday.length} ä¸ªä»»åŠ¡`;
            
            tasksForToday.sort((a, b) => {
                const subjectOrder = { 'è¯­æ–‡': 1, 'æ•°å­¦': 2, 'è‹±è¯­': 3, 'ç§‘å­¦': 4, 'å…¶ä»–': 5 };
                const subjectA = subjectOrder[a.task.subject] || 6;
                const subjectB = subjectOrder[b.task.subject] || 6;
                
                if (subjectA !== subjectB) {
                    return subjectA - subjectB;
                }
                
                return new Date(b.task.createDate) - new Date(a.task.createDate);
            });
            
            if (tasksForToday.length === 0) {
                todayTasksEl.innerHTML = `
                    <div class="empty-state">
                        <i>ğŸ“…</i>
                        <p>ä»Šå¤©æ²¡æœ‰æ‰“å¡ä»»åŠ¡ï¼Œæ”¾æ¾ä¸€ä¸‹å§ï¼</p>
                    </div>
                `;
                return;
            }
            
            tasksForToday.forEach(item => {
                renderTaskItem(item.task, todayTasksEl, item.checkpointIndex, item.daysSinceStart, 
                              item.isOverdue, item.hasCheckedIn, item.hasPendingRecording);
            });
        }

        // æ¸²æŸ“æ‰€æœ‰ä»»åŠ¡
        function renderAllTasks() {
            allTasksEl.innerHTML = '';
            
            if (appData.tasks.length === 0) {
                allTasksEl.innerHTML = `
                    <div class="empty-state">
                        <i>ğŸ“</i>
                        <p>è¿˜æ²¡æœ‰ä»»ä½•ä»»åŠ¡ï¼Œç‚¹å‡»"æ–°å»ºä»»åŠ¡"å¼€å§‹å§ï¼</p>
                    </div>
                `;
                return;
            }
            
            const sortedTasks = [...appData.tasks].sort((a, b) => {
                const subjectOrder = { 'è¯­æ–‡': 1, 'æ•°å­¦': 2, 'è‹±è¯­': 3, 'ç§‘å­¦': 4, 'å…¶ä»–': 5 };
                const subjectA = subjectOrder[a.subject] || 6;
                const subjectB = subjectOrder[b.subject] || 6;
                
                if (subjectA !== subjectB) {
                    return subjectA - subjectB;
                }
                
                return new Date(b.createDate) - new Date(a.createDate);
            });
            
            sortedTasks.forEach(task => {
                const taskEl = document.createElement('div');
                taskEl.className = 'task-item';
                
                const completedCheckins = task.checkins.length;
                const totalCheckins = checkinSchedule.length;
                const progressPercent = (completedCheckins / totalCheckins) * 100;
                
                const lastRecordingDuration = getLastRecordingDuration(task);
                const lastRecordingText = lastRecordingDuration ? 
                    `ä¸Šæ¬¡å½•éŸ³ç”¨æ—¶: ${formatTime(lastRecordingDuration)}` : '';
                
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((today - taskDate) / (1000 * 60 * 60 * 24));
                const checkpointIndex = checkinSchedule.findIndex(day => day === daysSinceStart);
                const shouldCheckinToday = checkpointIndex !== -1;
                const hasCheckedInToday = shouldCheckinToday ? 
                    task.checkins.some(checkin => checkin.checkpointIndex === checkpointIndex) : false;
                
                let hasOverdue = false;
                for (let i = 0; i < checkinSchedule.length; i++) {
                    const checkpointDay = checkinSchedule[i];
                    if (checkpointDay < daysSinceStart && 
                        !task.checkins.some(checkin => checkin.checkpointIndex === i)) {
                        hasOverdue = true;
                        break;
                    }
                }
                
                const hasPendingReview = appData.recordings.some(recording => 
                    recording.taskId === task.id && 
                    !task.checkins.some(checkin => checkin.recordingId === recording.id) &&
                    recording.status !== 'rejected'
                );
                
                // æ£€æŸ¥æ˜¯å¦æœ‰éœ€è¦é‡åšçš„å½•éŸ³
                const hasRejectedRecording = appData.recordings.some(recording => 
                    recording.taskId === task.id && 
                    recording.status === 'rejected' &&
                    !task.checkins.some(checkin => checkin.recordingId === recording.id)
                );
                
                const latestCheckin = task.checkins.length > 0 ? 
                    task.checkins.reduce((latest, current) => 
                        new Date(current.date) > new Date(latest.date) ? current : latest
                    ) : null;
                
                const canCheckinToday = shouldCheckinToday && !hasCheckedInToday && !hasPendingReview && !hasRejectedRecording;
                const hasOverdueCheckin = hasOverdue && !hasPendingReview && !hasRejectedRecording;
                const checkinBtnEnabled = canCheckinToday || hasOverdueCheckin;
                
                let statusClass = 'status-future';
                let statusText = '';
                
                if (hasRejectedRecording) {
                    statusClass = 'status-rejected';
                    statusText = 'éœ€é‡åš';
                } else if (hasPendingReview) {
                    statusClass = 'status-pending-review';
                    statusText = 'å¾…éªŒæ”¶';
                } else if (hasOverdue) {
                    statusClass = 'status-overdue';
                    statusText = 'æœ‰é€¾æœŸ';
                } else if (shouldCheckinToday) {
                    statusClass = hasCheckedInToday ? 'status-completed' : 'status-pending';
                    statusText = hasCheckedInToday ? 'ä»Šæ—¥å·²æ‰“å¡' : 'ä»Šæ—¥æœªæ‰“å¡';
                }
                
                const compactCheckinInfo = generateCompactCheckinInfo(task);
                
                const subjectClass = `subject-${getSubjectClass(task.subject)}`;
                
                const hasPlayableRecording = latestCheckin && 
                    appData.recordings.some(r => r.id === latestCheckin.recordingId && r.audioData);
                
                // è·å–ä¸åˆæ ¼åŸå› 
                const rejectionInfo = hasRejectedRecording ? getRejectionInfo(task.id) : '';
                
                taskEl.innerHTML = `
                    <div class="task-header">
                        <div class="task-name ${subjectClass}">${task.subject} - ${task.name}</div>
                        <div class="task-status ${statusClass}">
                            ${completedCheckins}/${totalCheckins}
                            ${statusText}
                        </div>
                    </div>
                    ${task.description ? `<p>${task.description}</p>` : ''}
                    <div class="task-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${progressPercent}%"></div>
                        </div>
                        <div class="progress-text">
                            å·²å®Œæˆ ${completedCheckins} æ¬¡æ‰“å¡ï¼Œè¿˜éœ€ ${totalCheckins - completedCheckins} æ¬¡
                            ${lastRecordingText ? `<div class="last-recording-time">${lastRecordingText}</div>` : ''}
                        </div>
                        ${compactCheckinInfo}
                    </div>
                    ${rejectionInfo}
                    <div class="task-actions">
                        <button class="btn ${checkinBtnEnabled ? 'btn-primary' : 'btn-disabled'}" onclick="handleCheckinClick(${task.id}, ${!checkinBtnEnabled})">
                            ${hasRejectedRecording ? 'é‡æ–°æ‰“å¡' : 'æ‰“å¡'}
                        </button>
                        <button class="btn btn-secondary" onclick="showEditTaskForm(${task.id})">ç¼–è¾‘</button>
                        <button class="btn btn-secondary" onclick="viewTaskDetails(${task.id})">è¯¦æƒ…</button>
                        <button class="btn btn-danger" onclick="deleteTask(${task.id})">åˆ é™¤</button>
                        ${hasPlayableRecording ? `<button class="btn btn-secondary" onclick="playLatestRecording(${task.id})" id="play-latest-${task.id}">å›æ”¾å½•éŸ³</button>` : ''}
                    </div>
                `;
                
                if (hasRejectedRecording) {
                    taskEl.classList.add('needs-redo');
                } else if (hasPendingReview) {
                    taskEl.classList.add('pending-review');
                }
                
                allTasksEl.appendChild(taskEl);
            });
        }

        // è·å–ä¸åˆæ ¼ä¿¡æ¯
        function getRejectionInfo(taskId) {
            const rejectedRecordings = appData.recordings.filter(recording => 
                recording.taskId === taskId && 
                recording.status === 'rejected'
            );
            
            if (rejectedRecordings.length === 0) return '';
            
            const latestRejection = rejectedRecordings.reduce((latest, current) => 
                new Date(current.rejectedAt) > new Date(latest.rejectedAt) ? current : latest
            );
            
            const checkpointDay = checkinSchedule[latestRejection.checkpointIndex];
            const rejectionDate = new Date(latestRejection.rejectedAt).toLocaleDateString();
            
            return `
                <div class="redo-notice">
                    <h4>ğŸ“ ç¬¬${checkpointDay}å¤©æ‰“å¡éœ€è¦é‡åš</h4>
                    <p><strong>ä¸åˆæ ¼åŸå› :</strong> ${latestRejection.rejectionReason}</p>
                    <p><strong>åé¦ˆæ—¶é—´:</strong> ${rejectionDate}</p>
                    <button class="btn btn-warning" onclick="startCheckin(${taskId}, ${latestRejection.checkpointIndex})">
                        ç«‹å³é‡æ–°å½•éŸ³
                    </button>
                </div>
            `;
        }

        // è·å–ç§‘ç›®å¯¹åº”çš„CSSç±»å
        function getSubjectClass(subject) {
            const subjectMap = {
                'è¯­æ–‡': 'chinese',
                'æ•°å­¦': 'math',
                'è‹±è¯­': 'english',
                'ç§‘å­¦': 'science',
                'å…¶ä»–': 'other'
            };
            return subjectMap[subject] || 'other';
        }

        // ç”Ÿæˆç´§å‡‘çš„æ‰“å¡è®°å½•ä¿¡æ¯
        function generateCompactCheckinInfo(task) {
            if (task.checkins.length === 0) {
                return '';
            }
            
            const recentCheckins = [...task.checkins]
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .slice(0, 3);
            
            const checkinItems = recentCheckins.map(checkin => {
                const checkpointDay = checkinSchedule[checkin.checkpointIndex];
                const date = new Date(checkin.date);
                const formattedDate = `${date.getMonth()+1}/${date.getDate()}`;
                return `<span class="compact-checkin-item">ç¬¬${checkpointDay}å¤© ${formattedDate}</span>`;
            }).join('');
            
            return `<div class="compact-checkin-info">æœ€è¿‘æ‰“å¡: ${checkinItems}</div>`;
        }

        // å¤„ç†æ‰“å¡æŒ‰é’®ç‚¹å‡»
        function handleCheckinClick(taskId, isDisabled) {
            if (isDisabled) {
                alert('ä»Šæ—¥å·²ç»æ‰“å¡æˆåŠŸæˆ–æ­£åœ¨ç­‰å¾…éªŒæ”¶ï¼');
                return;
            }
            startCheckin(taskId);
        }

        // æ¸²æŸ“ä»»åŠ¡é¡¹
        function renderTaskItem(task, container, checkpointIndex, daysSinceStart, isOverdue = false, hasCheckedIn = false, hasPendingRecording = false) {
            const taskEl = document.createElement('div');
            
            let taskClass = 'task-item';
            if (hasPendingRecording) {
                taskClass += ' pending-review';
            } else if (isOverdue) {
                taskClass += ' overdue';
            } else if (hasCheckedIn) {
                taskClass += ' completed';
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰éœ€è¦é‡åšçš„å½•éŸ³
            const hasRejectedRecording = appData.recordings.some(recording => 
                recording.taskId === task.id && 
                recording.checkpointIndex === checkpointIndex &&
                recording.status === 'rejected'
            );
            
            if (hasRejectedRecording) {
                taskClass += ' needs-redo';
            }
            
            taskEl.className = taskClass;
            
            const checkpointDay = checkinSchedule[checkpointIndex];
            let statusText = '';
            
            if (hasRejectedRecording) {
                statusText = 'éœ€é‡åš';
            } else if (hasPendingRecording) {
                statusText = 'å¾…éªŒæ”¶';
            } else if (isOverdue) {
                statusText = `é€¾æœŸ${daysSinceStart - checkpointDay}å¤©`;
            } else {
                statusText = checkpointDay === 0 ? 'æ–°ä»»åŠ¡' : `ç¬¬${checkpointDay}å¤©`;
            }
            
            const completedCheckins = task.checkins.length;
            const totalCheckins = checkinSchedule.length;
            const progressPercent = (completedCheckins / totalCheckins) * 100;
            
            const lastRecordingDuration = getLastRecordingDuration(task);
            const lastRecordingText = lastRecordingDuration ? 
                `ä¸Šæ¬¡å½•éŸ³ç”¨æ—¶: ${formatTime(lastRecordingDuration)}` : '';
            
            const compactCheckinInfo = generateCompactCheckinInfo(task);
            
            const subjectClass = `subject-${getSubjectClass(task.subject)}`;
            
            // è·å–ä¸åˆæ ¼åŸå› 
            const rejectionReason = hasRejectedRecording ? 
                appData.recordings.find(recording => 
                    recording.taskId === task.id && 
                    recording.checkpointIndex === checkpointIndex &&
                    recording.status === 'rejected'
                )?.rejectionReason : '';
            
            taskEl.innerHTML = `
                <div class="task-header">
                    <div class="task-name ${subjectClass}">${task.subject} - ${task.name}</div>
                    <div class="task-status ${hasRejectedRecording ? 'status-rejected' : (hasPendingRecording ? 'status-pending-review' : (hasCheckedIn ? 'status-completed' : (isOverdue ? 'status-overdue' : 'status-today')))}">
                        ${statusText} ${hasCheckedIn ? 'âœ“ ä»Šæ—¥å·²æ‰“å¡' : (hasPendingRecording ? 'å¾…éªŒæ”¶' : (hasRejectedRecording ? 'éœ€é‡åš' : 'æœªå®Œæˆ'))}
                    </div>
                </div>
                ${task.description ? `<p>${task.description}</p>` : ''}
                <div class="task-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    <div class="progress-text">
                        å·²å®Œæˆ ${completedCheckins} æ¬¡æ‰“å¡
                        ${lastRecordingText ? `<div class="last-recording-time">${lastRecordingText}</div>` : ''}
                    </div>
                    ${compactCheckinInfo}
                    ${rejectionReason ? `<div class="rejection-reason">ä¸åˆæ ¼åŸå› : ${rejectionReason}</div>` : ''}
                </div>
                <div class="task-actions">
                    ${!hasCheckedIn && !hasPendingRecording ? 
                        `<button class="btn btn-primary" onclick="startCheckin(${task.id}, ${checkpointIndex})">
                            ${hasRejectedRecording ? 'é‡æ–°æ‰“å¡' : 'ç«‹å³æ‰“å¡'}
                        </button>` : ''}
                    ${hasPendingRecording ? 
                        `<button class="btn btn-secondary" onclick="viewPendingRecording(${task.id}, ${checkpointIndex})">
                            æŸ¥çœ‹å¾…éªŒæ”¶å½•éŸ³
                        </button>` : ''}
                    <button class="btn btn-secondary" onclick="viewTaskDetails(${task.id})">è¯¦æƒ…</button>
                </div>
            `;
            
            container.appendChild(taskEl);
        }

        // æŸ¥çœ‹å¾…éªŒæ”¶å½•éŸ³
        function viewPendingRecording(taskId, checkpointIndex) {
            const task = appData.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            const pendingRecording = appData.recordings.find(recording => 
                recording.taskId === taskId && 
                recording.checkpointIndex === checkpointIndex &&
                !task.checkins.some(checkin => checkin.recordingId === recording.id) &&
                recording.status !== 'rejected'
            );
            
            if (pendingRecording) {
                switchTab('recorder');
                playSavedRecording(pendingRecording.id);
            } else {
                alert('æœªæ‰¾åˆ°å¾…éªŒæ”¶çš„å½•éŸ³');
            }
        }

        // æ’­æ”¾æœ€æ–°å½•éŸ³
        function playLatestRecording(taskId) {
            const task = appData.tasks.find(t => t.id === taskId);
            if (!task) {
                alert('æœªæ‰¾åˆ°ä»»åŠ¡');
                return;
            }
            
            if (task.checkins.length === 0) {
                alert('è¯¥ä»»åŠ¡æ²¡æœ‰å½•éŸ³è®°å½•');
                return;
            }
            
            const latestCheckin = task.checkins.reduce((latest, current) => {
                const latestDate = new Date(latest.date);
                const currentDate = new Date(current.date);
                return currentDate > latestDate ? current : latest;
            });
            
            if (!latestCheckin.recordingId) {
                alert('è¯¥ä»»åŠ¡æ²¡æœ‰å½•éŸ³è®°å½•');
                return;
            }
            
            const recording = appData.recordings.find(r => r.id === latestCheckin.recordingId);
            if (!recording) {
                alert('æœªæ‰¾åˆ°å½•éŸ³è®°å½•');
                return;
            }
            
            if (!recording.audioUrl && recording.audioData) {
                createAudioUrlFromData(recording);
            }
            
            if (recording.audioUrl) {
                const playBtn = document.getElementById(`play-latest-${taskId}`);
                if (playBtn) {
                    playBtn.textContent = 'å½•éŸ³å›æ”¾ä¸­';
                    playBtn.disabled = true;
                }
                
                switchTab('recorder');
                
                audioPlayer.src = recording.audioUrl;
                audioPlayer.classList.remove('hidden');
                
                audioPlayer.play().then(() => {
                    console.log('å½•éŸ³å¼€å§‹æ’­æ”¾');
                }).catch(error => {
                    console.error('æ’­æ”¾å¤±è´¥:', error);
                    alert('æ’­æ”¾å½•éŸ³å¤±è´¥: ' + error.message);
                    if (playBtn) {
                        playBtn.textContent = 'å›æ”¾å½•éŸ³';
                        playBtn.disabled = false;
                    }
                });
                
                audioPlayer.onended = () => {
                    if (playBtn) {
                        playBtn.textContent = 'å›æ”¾å½•éŸ³';
                        playBtn.disabled = false;
                    }
                };
                
                audioPlayer.onerror = () => {
                    console.error('éŸ³é¢‘æ’­æ”¾é”™è¯¯');
                    alert('æ’­æ”¾å½•éŸ³æ—¶å‘ç”Ÿé”™è¯¯');
                    if (playBtn) {
                        playBtn.textContent = 'å›æ”¾å½•éŸ³';
                        playBtn.disabled = false;
                    }
                };
                
            } else {
                alert('å½•éŸ³æ•°æ®ä¸å¯ç”¨ï¼Œå¯èƒ½å·²æŸå');
            }
        }

        // æ’­æ”¾ä¿å­˜çš„å½•éŸ³
        function playSavedRecording(recordingId) {
            const recording = appData.recordings.find(r => r.id === recordingId);
            if (!recording) {
                return;
            }
            
            if (!recording.audioUrl && recording.audioData) {
                createAudioUrlFromData(recording);
            }
            
            if (recording.audioUrl) {
                const playBtn = document.getElementById(`play-saved-${recordingId}`);
                if (playBtn) {
                    playBtn.textContent = 'å½•éŸ³å›æ”¾ä¸­';
                    playBtn.disabled = true;
                }
                
                audioPlayer.src = recording.audioUrl;
                audioPlayer.classList.remove('hidden');
                audioPlayer.play().catch(error => {
                    console.error('æ’­æ”¾å¤±è´¥:', error);
                    alert('æ’­æ”¾å½•éŸ³å¤±è´¥');
                    if (playBtn) {
                        playBtn.textContent = 'æ’­æ”¾';
                        playBtn.disabled = false;
                    }
                });
                
                audioPlayer.onended = () => {
                    if (playBtn) {
                        playBtn.textContent = 'æ’­æ”¾';
                        playBtn.disabled = false;
                    }
                };
            } else {
                alert('å½•éŸ³æ•°æ®å·²æŸåæˆ–ä¸¢å¤±');
            }
        }

        // æ¸²æŸ“æ—¥å†
        function renderCalendar() {
            calendarEl.innerHTML = '';
            
            const weekdays = ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'];
            weekdays.forEach(day => {
                const dayEl = document.createElement('div');
                dayEl.className = 'calendar-weekday';
                dayEl.textContent = day;
                calendarEl.appendChild(dayEl);
            });
            
            const year = appData.currentCalendarDate.getFullYear();
            const month = appData.currentCalendarDate.getMonth();
            calendarTitleEl.textContent = `${year}å¹´${month + 1}æœˆ`;
            
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            
            const firstDayIndex = firstDay.getDay();
            const prevMonthLastDay = new Date(year, month, 0).getDate();
            
            for (let i = firstDayIndex - 1; i >= 0; i--) {
                const dayEl = document.createElement('div');
                dayEl.className = 'calendar-day other-month';
                dayEl.innerHTML = `<div class="day-number">${prevMonthLastDay - i}</div>`;
                calendarEl.appendChild(dayEl);
            }
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            for (let day = 1; day <= lastDay.getDate(); day++) {
                const dayEl = document.createElement('div');
                dayEl.className = 'calendar-day';
                
                const date = new Date(year, month, day);
                if (date.getTime() === today.getTime()) {
                    dayEl.classList.add('today');
                }
                
                if (appData.selectedCalendarDate && 
                    appData.selectedCalendarDate.getDate() === day &&
                    appData.selectedCalendarDate.getMonth() === month &&
                    appData.selectedCalendarDate.getFullYear() === year) {
                    dayEl.classList.add('selected');
                }
                
                const tasksOnDate = getTasksOnDate(date);
                
                let indicators = '';
                if (tasksOnDate.overdue > 0) {
                    indicators += '<div class="task-indicator indicator-overdue"></div>';
                }
                if (tasksOnDate.today > 0) {
                    indicators += '<div class="task-indicator indicator-today"></div>';
                }
                if (tasksOnDate.future > 0) {
                    indicators += '<div class="task-indicator indicator-future"></div>';
                }
                if (tasksOnDate.completed > 0) {
                    indicators += '<div class="task-indicator indicator-completed"></div>';
                }
                if (tasksOnDate.pendingReview > 0) {
                    indicators += '<div class="task-indicator indicator-pending-review"></div>';
                }
                if (tasksOnDate.rejected > 0) {
                    indicators += '<div class="task-indicator indicator-rejected"></div>';
                }
                
                dayEl.innerHTML = `
                    <div class="day-number">${day}</div>
                    ${indicators}
                `;
                
                dayEl.addEventListener('click', () => showDateTasks(date));
                calendarEl.appendChild(dayEl);
            }
            
            const totalCells = 42;
            const filledCells = firstDayIndex + lastDay.getDate();
            const remainingCells = totalCells - filledCells;
            
            for (let day = 1; day <= remainingCells; day++) {
                const dayEl = document.createElement('div');
                dayEl.className = 'calendar-day other-month';
                dayEl.innerHTML = `<div class="day-number">${day}</div>`;
                calendarEl.appendChild(dayEl);
            }
        }

        // æ—¥å†å¯¼èˆª
        function navigateCalendar(direction) {
            const currentDate = appData.currentCalendarDate;
            const newDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + direction, 1);
            appData.currentCalendarDate = newDate;
            renderCalendar();
        }

        // å›åˆ°ä»Šå¤©
        function goToToday() {
            appData.currentCalendarDate = new Date();
            appData.selectedCalendarDate = new Date();
            renderCalendar();
            showDateTasks(new Date());
        }

        // è·å–æŒ‡å®šæ—¥æœŸçš„ä»»åŠ¡
        function getTasksOnDate(date) {
            const result = {
                overdue: 0,
                today: 0,
                future: 0,
                completed: 0,
                pendingReview: 0,
                rejected: 0
            };
            
            appData.tasks.forEach(task => {
                if (task.status !== 'active') return;
                
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const targetDate = new Date(date);
                targetDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((targetDate - taskDate) / (1000 * 60 * 60 * 24));
                
                const isCheckpointDay = checkinSchedule.includes(daysSinceStart);
                if (isCheckpointDay) {
                    const checkpointIndex = checkinSchedule.indexOf(daysSinceStart);
                    const hasCheckedIn = task.checkins.some(checkin => checkin.checkpointIndex === checkpointIndex);
                    
                    const hasPendingRecording = appData.recordings.some(recording => 
                        recording.taskId === task.id && 
                        recording.checkpointIndex === checkpointIndex &&
                        !task.checkins.some(checkin => checkin.recordingId === recording.id) &&
                        recording.status !== 'rejected'
                    );
                    
                    const hasRejectedRecording = appData.recordings.some(recording => 
                        recording.taskId === task.id && 
                        recording.checkpointIndex === checkpointIndex &&
                        recording.status === 'rejected'
                    );
                    
                    if (hasRejectedRecording) {
                        result.rejected++;
                    } else if (hasPendingRecording) {
                        result.pendingReview++;
                    } else if (hasCheckedIn) {
                        result.completed++;
                    } else {
                        if (daysSinceStart < 0) {
                            result.future++;
                        } else if (daysSinceStart === 0) {
                            result.today++;
                        } else {
                            result.overdue++;
                        }
                    }
                }
            });
            
            return result;
        }

        // æ˜¾ç¤ºæŒ‡å®šæ—¥æœŸçš„ä»»åŠ¡
        function showDateTasks(date) {
            appData.selectedCalendarDate = date;
            renderCalendar();
            
            selectedDateTasksEl.innerHTML = '';
            
            const dateStr = date.toLocaleDateString();
            selectedDateTasksEl.innerHTML = `<h3>${dateStr} çš„ä»»åŠ¡</h3>`;
            
            let hasTasks = false;
            
            appData.tasks.forEach(task => {
                if (task.status !== 'active') return;
                
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const targetDate = new Date(date);
                targetDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((targetDate - taskDate) / (1000 * 60 * 60 * 24));
                
                const checkpointIndex = checkinSchedule.findIndex(day => day === daysSinceStart);
                
                if (checkpointIndex !== -1) {
                    hasTasks = true;
                    const checkpointDay = checkinSchedule[checkpointIndex];
                    const isOverdue = daysSinceStart > checkpointDay;
                    const hasCheckedIn = task.checkins.some(checkin => checkin.checkpointIndex === checkpointIndex);
                    
                    const hasPendingRecording = appData.recordings.some(recording => 
                        recording.taskId === task.id && 
                        recording.checkpointIndex === checkpointIndex &&
                        !task.checkins.some(checkin => checkin.recordingId === recording.id) &&
                        recording.status !== 'rejected'
                    );
                    
                    const hasRejectedRecording = appData.recordings.some(recording => 
                        recording.taskId === task.id && 
                        recording.checkpointIndex === checkpointIndex &&
                        recording.status === 'rejected'
                    );
                    
                    const taskEl = document.createElement('div');
                    
                    let taskClass = 'task-item';
                    if (hasRejectedRecording) {
                        taskClass += ' needs-redo';
                    } else if (hasPendingRecording) {
                        taskClass += ' pending-review';
                    } else if (isOverdue) {
                        taskClass += ' overdue';
                    } else if (hasCheckedIn) {
                        taskClass += ' completed';
                    }
                    
                    taskEl.className = taskClass;
                    
                    const rejectionReason = hasRejectedRecording ? 
                        appData.recordings.find(recording => 
                            recording.taskId === task.id && 
                            recording.checkpointIndex === checkpointIndex &&
                            recording.status === 'rejected'
                        )?.rejectionReason : '';
                    
                    taskEl.innerHTML = `
                        <div class="task-header">
                            <div class="task-name">${task.subject} - ${task.name}</div>
                            <div class="task-status ${hasRejectedRecording ? 'status-rejected' : (hasPendingRecording ? 'status-pending-review' : (hasCheckedIn ? 'status-completed' : (isOverdue ? 'status-overdue' : 'status-today')))}">
                                ${isOverdue ? `é€¾æœŸ${daysSinceStart - checkpointDay}å¤©` : `ç¬¬${checkpointDay}å¤©`} ${hasCheckedIn ? 'âœ“' : (hasPendingRecording ? 'å¾…éªŒæ”¶' : (hasRejectedRecording ? 'éœ€é‡åš' : ''))}
                            </div>
                        </div>
                        <p>${task.description || ''}</p>
                        ${rejectionReason ? `<div class="rejection-reason">ä¸åˆæ ¼åŸå› : ${rejectionReason}</div>` : ''}
                        <div class="task-actions">
                            ${!hasCheckedIn && !hasPendingRecording ? 
                                `<button class="btn btn-primary" onclick="startCheckin(${task.id}, ${checkpointIndex})">
                                    ${hasRejectedRecording ? 'é‡æ–°æ‰“å¡' : 'æ‰“å¡'}
                                </button>` : ''}
                            ${hasPendingRecording ? 
                                `<button class="btn btn-secondary" onclick="viewPendingRecording(${task.id}, ${checkpointIndex})">
                                    æŸ¥çœ‹å¾…éªŒæ”¶å½•éŸ³
                                </button>` : ''}
                        </div>
                    `;
                    
                    selectedDateTasksEl.appendChild(taskEl);
                }
            });
            
            if (!hasTasks) {
                selectedDateTasksEl.innerHTML += `
                    <div class="empty-state">
                        <i>ğŸ“…</i>
                        <p>è¿™ä¸€å¤©æ²¡æœ‰æ‰“å¡ä»»åŠ¡</p>
                    </div>
                `;
            }
        }

        // æ¸²æŸ“å½•éŸ³è®°å½•
        function renderRecordings() {
            recordingsListEl.innerHTML = '';
            
            const unconfirmedRecordings = appData.recordings.filter(recording => {
                const task = appData.tasks.find(t => t.id === recording.taskId);
                if (!task) return false;
                
                return !task.checkins.some(checkin => checkin.recordingId === recording.id);
            });
            
            if (unconfirmedRecordings.length === 0) {
                recordingsListEl.innerHTML = `
                    <div class="empty-state">
                        <i>ğŸ¤</i>
                        <p>è¿˜æ²¡æœ‰ä»»ä½•æ‰“å¡è®°å½•</p>
                    </div>
                `;
                return;
            }
            
            unconfirmedRecordings.forEach(recording => {
                const recordingEl = document.createElement('div');
                recordingEl.className = 'recording-item';
                
                const task = appData.tasks.find(t => t.id === recording.taskId);
                const taskName = task ? `${task.subject} - ${task.name}` : 'æœªçŸ¥ä»»åŠ¡';
                const checkpointDay = checkinSchedule[recording.checkpointIndex];
                const date = new Date(recording.date).toLocaleString();
                
                recordingEl.innerHTML = `
                    <div class="recording-info">
                        <div class="recording-name">${taskName} - ç¬¬${checkpointDay}å¤©</div>
                        <div class="recording-duration">${date} | æ—¶é•¿: ${formatTime(recording.duration)}</div>
                        ${recording.status === 'rejected' ? 
                            `<div class="rejection-reason">ä¸åˆæ ¼åŸå› : ${recording.rejectionReason}</div>` : ''}
                    </div>
                    <div class="task-actions">
                        <button class="btn btn-secondary" onclick="playSavedRecording(${recording.id})" id="play-saved-${recording.id}">æ’­æ”¾</button>
                        ${recording.status !== 'rejected' ? 
                            `<button class="btn btn-primary" onclick="showApprovalModal(${recording.id})">ç¡®è®¤ç­¾æ”¶</button>
                             <button class="btn btn-danger" onclick="showRejectionModal(${recording.id})">éªŒæ”¶ä¸åˆæ ¼</button>` :
                            `<button class="btn btn-warning" onclick="showRejectionDetails(${recording.id})">æŸ¥çœ‹ä¸åˆæ ¼è¯¦æƒ…</button>`
                        }
                    </div>
                `;
                
                recordingsListEl.appendChild(recordingEl);
            });
        }

        // æ˜¾ç¤ºä¸åˆæ ¼è¯¦æƒ…
        function showRejectionDetails(recordingId) {
            const recording = appData.recordings.find(r => r.id === recordingId);
            if (!recording) return;
            
            const task = appData.tasks.find(t => t.id === recording.taskId);
            const taskName = task ? `${task.subject} - ${task.name}` : 'æœªçŸ¥ä»»åŠ¡';
            const checkpointDay = checkinSchedule[recording.checkpointIndex];
            const rejectionDate = new Date(recording.rejectedAt).toLocaleString();
            
            alert(`ä¸åˆæ ¼è¯¦æƒ…\n\nä»»åŠ¡: ${taskName}\næ‰“å¡ç‚¹: ç¬¬${checkpointDay}å¤©\nä¸åˆæ ¼åŸå› : ${recording.rejectionReason}\nåé¦ˆæ—¶é—´: ${rejectionDate}`);
        }

        // å¼€å§‹æ‰“å¡
        function startCheckin(taskId, checkpointIndex = null) {
            const task = appData.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            appData.currentTask = task;
            
            if (checkpointIndex === null) {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                const taskDate = new Date(task.createDate);
                taskDate.setHours(0, 0, 0, 0);
                
                const daysSinceStart = Math.floor((today - taskDate) / (1000 * 60 * 60 * 24));
                checkpointIndex = checkinSchedule.findIndex(day => day === daysSinceStart);
                
                if (checkpointIndex === -1) {
                    const overdueCheckpoints = [];
                    for (let i = 0; i < checkinSchedule.length; i++) {
                        if (checkinSchedule[i] < daysSinceStart && 
                            !task.checkins.some(checkin => checkin.checkpointIndex === i)) {
                            overdueCheckpoints.push({
                                index: i,
                                day: checkinSchedule[i]
                            });
                        }
                    }
                    
                    overdueCheckpoints.sort((a, b) => a.day - b.day);
                    
                    if (overdueCheckpoints.length > 0) {
                        checkpointIndex = overdueCheckpoints[0].index;
                    }
                }
            }
            
            appData.currentCheckpointIndex = checkpointIndex;
            
            switchTab('recorder');
            
            const checkpointDay = checkinSchedule[checkpointIndex];
            recorderTaskNameEl.textContent = `${task.subject} - ${task.name}`;
            recorderCheckpointEl.textContent = `ç¬¬${checkpointDay}å¤©æ‰“å¡`;
            
            uploadTaskNameEl.textContent = `${task.subject} - ${task.name}`;
            uploadCheckpointEl.textContent = `ç¬¬${checkpointDay}å¤©æ‰“å¡`;
            
            resetRecorder();
            resetUpload();
        }

        // å¼€å§‹å½•éŸ³
        async function startRecording() {
            if (!appData.currentTask) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªä»»åŠ¡ï¼');
                return;
            }
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                appData.mediaRecorder = new MediaRecorder(stream);
                appData.audioChunks = [];
                
                appData.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        appData.audioChunks.push(event.data);
                    }
                };
                
                appData.mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(appData.audioChunks, { type: 'audio/wav' });
                    
                    const reader = new FileReader();
                    reader.onload = function() {
                        const base64Audio = reader.result;
                        
                        const recording = {
                            id: Date.now(),
                            taskId: appData.currentTask.id,
                            checkpointIndex: appData.currentCheckpointIndex,
                            date: new Date().toISOString(),
                            duration: appData.recordingTime,
                            audioData: base64Audio,
                            mimeType: 'audio/wav'
                        };
                        
                        createAudioUrlFromData(recording);
                        
                        // åˆ é™¤åŒä¸€ä»»åŠ¡çš„æ‰€æœ‰æ—§å½•éŸ³
                        appData.recordings = appData.recordings.filter(r => 
                            r.taskId !== recording.taskId
                        );
                        
                        appData.currentRecording = recording;
                        appData.recordings.push(recording);
                        saveRecordings();
                        
                        stream.getTracks().forEach(track => track.stop());
                        clearRecordingState();
                        
                        console.log('å½•éŸ³ä¿å­˜å®Œæˆï¼ŒID:', recording.id);
                    };
                    reader.readAsDataURL(audioBlob);
                };
                
                appData.isRecording = true;
                appData.isPaused = false;
                appData.recordingTime = 0;
                
                recordBtn.classList.add('recording');
                pauseBtn.classList.remove('hidden');
                stopBtn.classList.remove('hidden');
                recordBtn.classList.add('hidden');
                
                updatePlaybackStatus('å½•éŸ³ä¸­...', 'status-recording');
                
                appData.mediaRecorder.start();
                
                appData.timerInterval = setInterval(() => {
                    appData.recordingTime += 10;
                    updateTimer();
                    updateWaveform();
                }, 10);
                
            } catch (error) {
                console.error('å½•éŸ³å¯åŠ¨å¤±è´¥:', error);
                alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
            }
        }

        // æš‚åœå½•éŸ³
        function togglePause() {
            if (!appData.mediaRecorder) return;
            
            if (appData.isPaused) {
                appData.mediaRecorder.resume();
                appData.isPaused = false;
                pauseBtn.innerHTML = 'âšâš';
                updatePlaybackStatus('å½•éŸ³ä¸­...', 'status-recording');
                
                appData.timerInterval = setInterval(() => {
                    appData.recordingTime += 10;
                    updateTimer();
                    updateWaveform();
                }, 10);
            } else {
                appData.mediaRecorder.pause();
                appData.isPaused = true;
                clearInterval(appData.timerInterval);
                pauseBtn.innerHTML = 'â–¶';
                updatePlaybackStatus('å½•éŸ³å·²æš‚åœ', 'status-playing');
                saveRecordingState();
            }
        }

        // åœæ­¢å½•éŸ³
        function stopRecording() {
            if (!appData.mediaRecorder || appData.mediaRecorder.state === 'inactive') return;
            
            appData.mediaRecorder.stop();
            appData.isRecording = false;
            appData.isPaused = false;
            
            clearInterval(appData.timerInterval);
            
            recordBtn.classList.remove('recording', 'hidden');
            pauseBtn.classList.add('hidden');
            stopBtn.classList.add('hidden');
            playBtn.classList.remove('hidden');
            submitRecordingBtn.disabled = false;
            
            recordingStatusEl.classList.add('hidden');
            clearRecordingState();
        }

        // æ’­æ”¾å½•éŸ³
        function playRecording() {
            if (!appData.currentRecording) {
                console.log('æ²¡æœ‰å½“å‰å½•éŸ³å¯æ’­æ”¾');
                return;
            }
            
            if (!appData.currentRecording.audioUrl && appData.currentRecording.audioData) {
                createAudioUrlFromData(appData.currentRecording);
            }
            
            if (appData.currentRecording.audioUrl) {
                audioPlayer.src = appData.currentRecording.audioUrl;
                audioPlayer.classList.remove('hidden');
                audioPlayer.play().catch(error => {
                    console.error('æ’­æ”¾å¤±è´¥:', error);
                    alert('æ’­æ”¾å½•éŸ³å¤±è´¥');
                });
            } else {
                alert('å½•éŸ³æ•°æ®ä¸å¯ç”¨ï¼Œå¯èƒ½å·²æŸå');
            }
        }

        // æäº¤å½•éŸ³
        function submitRecording() {
            if (!appData.currentRecording) {
                alert('è¯·å…ˆå®Œæˆå½•éŸ³ï¼');
                return;
            }
            
            alert('æ‰“å¡æäº¤æˆåŠŸï¼ç­‰å¾…ç­¾æ”¶ç¡®è®¤ã€‚');
            resetRecorder();
            renderRecordings();
            renderTodayTasks();
            renderAllTasks();
            renderCalendar();
            renderDataStats();
        }

        // æ˜¾ç¤ºéªŒæ”¶æ¨¡æ€æ¡†
        function showApprovalModal(recordingId) {
            appData.pendingApprovalRecordingId = recordingId;
            approvalModal.classList.remove('hidden');
            approvalPasswordInput.value = '';
        }

        // éšè—éªŒæ”¶æ¨¡æ€æ¡†
        function hideApprovalModal() {
            approvalModal.classList.add('hidden');
            appData.pendingApprovalRecordingId = null;
        }

        // å¤„ç†éªŒæ”¶
        function handleApproval() {
            const password = approvalPasswordInput.value;
            
            if (password !== appData.approvalPassword) {
                alert('å¯†ç é”™è¯¯ï¼Œè¯·é‡è¯•');
                return;
            }
            
            confirmCheckin(appData.pendingApprovalRecordingId);
            hideApprovalModal();
        }

        // æ˜¾ç¤ºéªŒæ”¶ä¸åˆæ ¼æ¨¡æ€æ¡†
        function showRejectionModal(recordingId) {
            appData.pendingRejectionRecordingId = recordingId;
            rejectionModal.classList.remove('hidden');
            rejectionReasonInput.value = '';
        }

        // éšè—éªŒæ”¶ä¸åˆæ ¼æ¨¡æ€æ¡†
        function hideRejectionModal() {
            rejectionModal.classList.add('hidden');
            appData.pendingRejectionRecordingId = null;
        }

        // ç¡®è®¤éªŒæ”¶ä¸åˆæ ¼
        function confirmRejection() {
            const reason = rejectionReasonInput.value.trim();
            const recordingId = appData.pendingRejectionRecordingId;
            
            if (!reason) {
                alert('è¯·å¡«å†™ä¸åˆæ ¼åŸå› ');
                return;
            }
            
            const recording = appData.recordings.find(r => r.id === recordingId);
            if (!recording) return;
            
            // æ ‡è®°å½•éŸ³ä¸ºä¸åˆæ ¼
            recording.status = 'rejected';
            recording.rejectionReason = reason;
            recording.rejectedAt = new Date().toISOString();
            
            // ä»ä»»åŠ¡æ‰“å¡è®°å½•ä¸­ç§»é™¤ï¼ˆå¦‚æœå·²ç»ç­¾æ”¶äº†ï¼‰
            const task = appData.tasks.find(t => t.id === recording.taskId);
            if (task) {
                task.checkins = task.checkins.filter(checkin => 
                    checkin.recordingId !== recordingId
                );
            }
            
            saveRecordings();
            saveTasks();
            
            alert('å·²æ ‡è®°ä¸ºéªŒæ”¶ä¸åˆæ ¼ï¼Œç”¨æˆ·å¯ä»¥é‡æ–°å½•éŸ³ã€‚');
            hideRejectionModal();
            renderRecordings();
            renderTodayTasks();
            renderAllTasks();
            renderDataStats();
        }

        // ç¡®è®¤ç­¾æ”¶
        function confirmCheckin(recordingId) {
            const recording = appData.recordings.find(r => r.id === recordingId);
            if (!recording) return;
            
            const task = appData.tasks.find(t => t.id === recording.taskId);
            if (!task) return;
            
            const alreadyCheckedIn = task.checkins.some(
                checkin => checkin.checkpointIndex === recording.checkpointIndex
            );
            
            if (alreadyCheckedIn) {
                alert('è¿™ä¸ªæ‰“å¡ç‚¹å·²ç»ç­¾æ”¶è¿‡äº†ï¼');
                return;
            }
            
            task.checkins.push({
                checkpointIndex: recording.checkpointIndex,
                date: recording.date,
                recordingId: recording.id
            });
            
            if (task.checkins.length === checkinSchedule.length) {
                task.status = 'completed';
                alert(`æ­å–œï¼ä»»åŠ¡"${task.name}"å·²å®Œæˆï¼`);
            } else {
                alert('æ‰“å¡ç­¾æ”¶æˆåŠŸï¼');
            }
            
            saveTasks();
            renderAllTasks();
            renderTodayTasks();
            renderRecordings();
            renderCalendar();
            renderDataStats();
        }

        // é‡ç½®å½•éŸ³å™¨
        function resetRecorder() {
            appData.isRecording = false;
            appData.isPaused = false;
            appData.recordingTime = 0;
            
            clearInterval(appData.timerInterval);
            
            recordBtn.classList.remove('recording', 'hidden');
            pauseBtn.classList.add('hidden');
            stopBtn.classList.add('hidden');
            playBtn.classList.add('hidden');
            submitRecordingBtn.disabled = true;
            
            audioPlayer.classList.add('hidden');
            audioPlayer.src = '';
            recordingStatusEl.classList.add('hidden');
            
            updateTimer();
            clearWaveform();
            clearRecordingState();
        }

        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('audio/')) {
                alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶ï¼');
                resetUpload();
                return;
            }
            
            if (file.size > 10 * 1024 * 1024) {
                alert('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡10MB');
                resetUpload();
                return;
            }
            
            fileNameEl.textContent = file.name;
            fileSizeEl.textContent = formatFileSize(file.size);
            fileDurationEl.textContent = 'è®¡ç®—ä¸­...';
            fileInfoEl.classList.remove('hidden');
            
            const tempAudio = new Audio();
            const tempUrl = URL.createObjectURL(file);
            tempAudio.src = tempUrl;
            
            tempAudio.addEventListener('loadedmetadata', () => {
                const duration = Math.floor(tempAudio.duration * 1000);
                fileDurationEl.textContent = formatTime(duration);
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    appData.uploadedAudio = {
                        file: file,
                        duration: duration,
                        audioData: e.target.result,
                        mimeType: file.type
                    };
                    
                    uploadedAudioPlayer.src = e.target.result;
                    uploadedAudioPlayer.classList.remove('hidden');
                    
                    submitUploadBtn.disabled = false;
                    
                    URL.revokeObjectURL(tempUrl);
                };
                reader.readAsDataURL(file);
            });
            
            tempAudio.addEventListener('error', () => {
                fileDurationEl.textContent = 'è®¡ç®—å¤±è´¥';
                alert('æ— æ³•è¯»å–éŸ³é¢‘æ–‡ä»¶ï¼Œè¯·é€‰æ‹©å…¶ä»–æ–‡ä»¶');
                resetUpload();
                URL.revokeObjectURL(tempUrl);
            });
        }

        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / 1048576).toFixed(1) + ' MB';
        }

        // æäº¤ä¸Šä¼ çš„éŸ³é¢‘
        function submitUploadedAudio() {
            if (!appData.uploadedAudio || !appData.currentTask) return;
            
            const recording = {
                id: Date.now(),
                taskId: appData.currentTask.id,
                checkpointIndex: appData.currentCheckpointIndex,
                date: new Date().toISOString(),
                duration: appData.uploadedAudio.duration,
                audioData: appData.uploadedAudio.audioData,
                mimeType: appData.uploadedAudio.mimeType,
                source: 'upload'
            };
            
            createAudioUrlFromData(recording);
            
            // åˆ é™¤åŒä¸€ä»»åŠ¡çš„æ‰€æœ‰æ—§å½•éŸ³
            appData.recordings = appData.recordings.filter(r => 
                r.taskId !== recording.taskId
            );
            
            appData.recordings.push(recording);
            saveRecordings();
            
            alert('æ‰“å¡æäº¤æˆåŠŸï¼ç­‰å¾…ç­¾æ”¶ç¡®è®¤ã€‚');
            resetUpload();
            renderRecordings();
            renderTodayTasks();
            renderAllTasks();
            renderCalendar();
            renderDataStats();
        }

        // é‡ç½®ä¸Šä¼ ç•Œé¢
        function resetUpload() {
            audioFileInput.value = '';
            fileInfoEl.classList.add('hidden');
            uploadedAudioPlayer.classList.add('hidden');
            uploadedAudioPlayer.src = '';
            submitUploadBtn.disabled = true;
            appData.uploadedAudio = null;
        }

        // æ›´æ–°è®¡æ—¶å™¨
        function updateTimer() {
            timerEl.textContent = formatTime(appData.recordingTime);
        }

        // æ ¼å¼åŒ–æ—¶é—´
        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            const ms = Math.floor((milliseconds % 1000) / 10);
            
            if (hours > 0) {
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }

        // æ›´æ–°æ³¢å½¢å›¾
        function updateWaveform() {
            if (Math.random() < 0.3) {
                const bar = document.createElement('div');
                bar.className = 'waveform-bar';
                bar.style.height = `${10 + Math.random() * 80}px`;
                bar.style.left = `${Math.random() * 95}%`;
                waveformEl.appendChild(bar);
                
                if (waveformEl.children.length > 50) {
                    waveformEl.removeChild(waveformEl.firstChild);
                }
            }
        }

        // æ¸…ç©ºæ³¢å½¢å›¾
        function clearWaveform() {
            waveformEl.innerHTML = '';
        }

        // æŸ¥çœ‹ä»»åŠ¡è¯¦æƒ…
        function viewTaskDetails(taskId) {
            const task = appData.tasks.find(t => t.id === taskId);
            if (!task) return;
            
            const checkinDetails = checkinSchedule.map((day, index) => {
                const checkin = task.checkins.find(c => c.checkpointIndex === index);
                const hasPendingRecording = appData.recordings.some(recording => 
                    recording.taskId === taskId && 
                    recording.checkpointIndex === index &&
                    !task.checkins.some(c => c.recordingId === recording.id) &&
                    recording.status !== 'rejected'
                );
                
                const hasRejectedRecording = appData.recordings.some(recording => 
                    recording.taskId === taskId && 
                    recording.checkpointIndex === index &&
                    recording.status === 'rejected'
                );
                
                let status = checkin ? 'å®Œæˆ' : 'æœªå®Œæˆ';
                let statusIcon = checkin ? 'âœ…' : 'âŒ';
                let statusClass = checkin ? 'status-completed-icon' : 'status-missed-icon';
                
                if (hasRejectedRecording) {
                    status = 'éœ€é‡åš';
                    statusIcon = 'ğŸ”„';
                    statusClass = 'status-pending-icon';
                } else if (hasPendingRecording) {
                    status = 'å¾…éªŒæ”¶';
                    statusIcon = 'â³';
                    statusClass = 'status-pending-icon';
                }
                
                return `
                    <div class="checkin-item">
                        <div class="checkin-day">ç¬¬${day.toString().padStart(3, ' ')}å¤©:</div>
                        <div class="checkin-status">
                            <span class="status-icon ${statusClass}">${statusIcon}</span>
                            <span>${status}</span>
                        </div>
                    </div>
                `;
            }).join('');
            
            // è·å–ä¸åˆæ ¼å†å²
            const rejectionHistory = appData.recordings
                .filter(recording => recording.taskId === taskId && recording.status === 'rejected')
                .map(recording => {
                    const checkpointDay = checkinSchedule[recording.checkpointIndex];
                    const date = new Date(recording.rejectedAt).toLocaleDateString();
                    return `
                        <div class="rejection-history-item">
                            <div class="rejection-date">ç¬¬${checkpointDay}å¤© - ${date}</div>
                            <div class="rejection-reason-text">${recording.rejectionReason}</div>
                        </div>
                    `;
                }).join('');
            
            taskDetailsTitle.textContent = `${task.subject} - ${task.name}`;
            taskDetailsContent.innerHTML = `
                <div class="form-group">
                    <label>ä»»åŠ¡æè¿°</label>
                    <p>${task.description || 'æ— æè¿°'}</p>
                </div>
                <div class="form-group">
                    <label>åˆ›å»ºæ—¥æœŸ</label>
                    <p>${new Date(task.createDate).toLocaleDateString()}</p>
                </div>
                <div class="checkin-progress">
                    <h4>æ‰“å¡è¿›åº¦</h4>
                    ${checkinDetails}
                </div>
                ${rejectionHistory ? `
                <div class="rejection-history">
                    <h4>ä¸åˆæ ¼å†å²</h4>
                    ${rejectionHistory}
                </div>
                ` : ''}
            `;
            
            taskDetailsModal.classList.remove('hidden');
        }

        // éšè—ä»»åŠ¡è¯¦æƒ…
        function hideTaskDetails() {
            taskDetailsModal.classList.add('hidden');
        }

        // åˆ é™¤ä»»åŠ¡
        function deleteTask(taskId) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä»»åŠ¡å—ï¼Ÿ')) {
                appData.tasks = appData.tasks.filter(t => t.id !== taskId);
                saveTasks();
                renderAllTasks();
                renderTodayTasks();
                renderCalendar();
                renderDataStats();
            }
        }

        // æ•°æ®ç®¡ç†åŠŸèƒ½
        function showDataManagementModal() {
            dataManagementModal.classList.remove('hidden');
            updateDataStats();
        }

        function hideDataManagementModal() {
            dataManagementModal.classList.add('hidden');
        }

        function updateDataStats() {
            const totalTasks = appData.tasks.length;
            const completedTasks = appData.tasks.filter(task => task.status === 'completed').length;
            const totalRecordings = appData.recordings.length;
            const pendingRecordings = appData.recordings.filter(recording => {
                const task = appData.tasks.find(t => t.id === recording.taskId);
                if (!task) return false;
                return !task.checkins.some(checkin => checkin.recordingId === recording.id);
            }).length;
            
            const rejectedRecordings = appData.recordings.filter(recording => 
                recording.status === 'rejected'
            ).length;
            
            const dataSize = calculateDataSize();

            document.getElementById('stat-total-tasks').textContent = totalTasks;
            document.getElementById('stat-completed-tasks').textContent = completedTasks;
            document.getElementById('stat-total-recordings').textContent = totalRecordings;
            document.getElementById('stat-pending-recordings').textContent = pendingRecordings;
            document.getElementById('stat-rejected-recordings').textContent = rejectedRecordings;
            document.getElementById('stat-data-size').textContent = dataSize.totalSize;
        }

        function renderDataStats() {
            const totalTasks = appData.tasks.length;
            const completedTasks = appData.tasks.filter(task => task.status === 'completed').length;
            const totalRecordings = appData.recordings.length;
            
            const totalDuration = appData.recordings.reduce((total, recording) => total + recording.duration, 0);
            const totalMinutes = Math.floor(totalDuration / 60000);
            
            const rejectedCount = appData.recordings.filter(recording => 
                recording.status === 'rejected'
            ).length;
            
            const dataSize = calculateDataSize();

            document.getElementById('stats-total-tasks').textContent = totalTasks;
            document.getElementById('stats-completed-tasks').textContent = completedTasks;
            document.getElementById('stats-total-recordings').textContent = totalRecordings;
            document.getElementById('stats-total-duration').textContent = `${totalMinutes}åˆ†é’Ÿ`;
            document.getElementById('stats-data-size').textContent = dataSize.totalSize;
            document.getElementById('stats-rejected-count').textContent = rejectedCount;
            
            // æ˜¾ç¤ºå­˜å‚¨è­¦å‘Š
            showStorageWarning();
        }

        function exportData() {
            const exportData = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                tasks: appData.tasks,
                recordings: appData.recordings
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `å¤ä¹ æ‰“å¡è®¡åˆ’å¤‡ä»½_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            alert('æ•°æ®å¯¼å‡ºæˆåŠŸï¼');
        }

        function handleImportFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.json')) {
                alert('è¯·é€‰æ‹©JSONæ ¼å¼çš„æ–‡ä»¶ï¼');
                resetImportFile();
                return;
            }
            
            importFileName.textContent = file.name;
            importFileSize.textContent = formatFileSize(file.size);
            importFileInfo.classList.remove('hidden');
            importDataBtn.disabled = false;
        }

        function importData() {
            const file = importDataFile.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!importedData.tasks || !importedData.recordings) {
                        throw new Error('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘å¿…è¦çš„æ•°æ®å­—æ®µ');
                    }
                    
                    if (!confirm('å¯¼å…¥æ•°æ®å°†è¦†ç›–å½“å‰æ‰€æœ‰æ•°æ®ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ')) {
                        return;
                    }
                    
                    appData.tasks = importedData.tasks;
                    appData.recordings = importedData.recordings;
                    
                    restoreRecordingUrls();
                    
                    saveTasks();
                    saveRecordings();
                    
                    appData.currentTask = null;
                    appData.currentRecording = null;
                    appData.selectedCalendarDate = null;
                    appData.editingTask = null;
                    appData.currentCheckpointIndex = null;
                    
                    renderTodayTasks();
                    renderAllTasks();
                    renderCalendar();
                    renderRecordings();
                    renderDataStats();
                    
                    hideDataManagementModal();
                    resetImportFile();
                    
                    alert('æ•°æ®å¯¼å…¥æˆåŠŸï¼');
                    
                } catch (error) {
                    console.error('æ•°æ®å¯¼å…¥å¤±è´¥:', error);
                    alert('æ•°æ®å¯¼å…¥å¤±è´¥ï¼š' + error.message);
                }
            };
            reader.onerror = function() {
                alert('æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•');
            };
            reader.readAsText(file);
        }

        function resetImportFile() {
            importDataFile.value = '';
            importFileInfo.classList.add('hidden');
            importDataBtn.disabled = true;
        }

        function clearAllData() {
            if (!confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼')) {
                return;
            }
            
            if (!confirm('å†æ¬¡ç¡®è®¤ï¼šè¿™å°†åˆ é™¤æ‰€æœ‰ä»»åŠ¡å’Œå½•éŸ³è®°å½•ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ')) {
                return;
            }
            
            appData.tasks = [];
            appData.recordings = [];
            
            localStorage.removeItem('checkinTasks');
            localStorage.removeItem('checkinRecordings');
            localStorage.removeItem('recordingState');
            
            appData.currentTask = null;
            appData.currentRecording = null;
            appData.selectedCalendarDate = null;
            appData.editingTask = null;
            appData.currentCheckpointIndex = null;
            
            renderTodayTasks();
            renderAllTasks();
            renderCalendar();
            renderRecordings();
            renderDataStats();
            
            alert('æ‰€æœ‰æ•°æ®å·²æ¸…é™¤ï¼');
        }

        // åˆå§‹åŒ–åº”ç”¨
        window.onload = initApp;
    </script>
</body>
</html>